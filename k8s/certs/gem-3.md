Конечно, вот оптимальная стратегия использования сертификатов для Deckhouse в изолированном корпоративном окружении с ручным выпуском сертификатов.

Стратегия основана на ручном обновлении Kubernetes Secrets, которые Deckhouse использует для предоставления TLS-сертификатов своим компонентам, таким как Ingress-контроллер и веб-интерфейс.

### Основные принципы стратегии

1.  **Централизованное хранение:** Все TLS-сертификаты хранятся в виде стандартных Kubernetes-секретов типа `kubernetes.io/tls`.
2.  **Ручное обновление:** Процесс обновления сертификатов инициируется вручную администратором кластера по мере приближения срока их истечения.
3.  **Автоматическое применение:** Компоненты Deckhouse (например, Nginx Ingress Controller) автоматически отслеживают изменения в секретах и применяют новые сертификаты без перезагрузки или простоя.
4.  **Мониторинг:** Настроен автоматический мониторинг сроков действия сертификатов, хранящихся в секретах, с помощью встроенных в Deckhouse инструментов (Prometheus).

---

### Пошаговая стратегия

#### Шаг 1: Определение необходимых сертификатов

В первую очередь, необходимо составить список всех доменов, для которых требуются TLS-сертификаты. В типовом развертывании Deckhouse это как минимум:

*   **Сертификат для Ingress-контроллера:** Wildcard-сертификат (например, `*.kube.mycompany.local`) или отдельные сертификаты для каждого приложения, доступного извне.
*   **Сертификат для веб-интерфейса Deckhouse:** (например, `deckhouse.mycompany.local`).
*   **Сертификат для Grafana, Prometheus, OpenSearch Dashboards и т.д.:** Если они публикуются через Ingress.

#### Шаг 2: Подготовка файлов сертификатов

Корпоративный центр сертификации (CA) должен предоставить вам файлы для каждого домена. Обычно это архив, содержащий:

1.  `cert.pem` или `tls.crt`: Сам сертификат сервера.
2.  `chain.pem` или `intermediate.crt`: Цепочка промежуточных сертификатов.
3.  `fullchain.pem`: Полная цепочка (сертификат сервера + промежуточные). **Это предпочтительный файл.**
4.  `privkey.pem` или `tls.key`: Приватный ключ сертификата.
5.  `root_ca.crt`: Корневой сертификат вашей организации (понадобится отдельно).

**Важно:** Для Kubernetes-секрета типа `kubernetes.io/tls` файл сертификата (`tls.crt`) должен содержать полную цепочку доверяемых сертификатов (сертификат сервера + промежуточные).

#### Шаг 3: Создание/Обновление Kubernetes Secret

Для каждого сертификата необходимо создать или обновить соответствующий секрет в кластере.

1.  **Определите имя и namespace секрета.** Рекомендуется хранить все сертификаты в одном пространстве имен, например, `d8-ingress-tls`.

2.  **Выполните команду `kubectl`:**
    Используйте следующую команду для создания секрета. Если секрет уже существует, его нужно сначала удалить, а затем создать заново, либо обновить через `kubectl apply`.

    ```bash
    kubectl create secret tls <имя-секрета> \
      --cert=<путь/до/fullchain.pem> \
      --key=<путь/до/privkey.pem> \
      --namespace=<пространство-имен>
    ```

    *   `<имя-секрета>`: например, `my-corp-wildcard-tls`.
    *   `--cert`: путь к файлу с полной цепочкой сертификатов (сертификат + промежуточные).
    *   `--key`: путь к приватному ключу.
    *   `--namespace`: пространство имен, где будет храниться секрет.

    **Пример для wildcard-сертификата:**
    ```bash
    kubectl create secret tls my-corp-wildcard-tls \
      --cert=./certs/fullchain.pem \
      --key=./certs/privkey.pem \
      --namespace=d8-ingress-tls
    ```

#### Шаг 4: Настройка компонентов Deckhouse для использования сертификатов

Теперь нужно указать Deckhouse, какие секреты использовать.

##### Для Ingress-контроллера (глобальный сертификат по умолчанию)

Чтобы установить сертификат по умолчанию для всех Ingress-ресурсов, которые не указывают собственный сертификат, необходимо отредактировать `IngressNginxController`.

1.  **Найдите нужный контроллер:**
    ```bash
    kubectl get ingressnginxcontrollers.deckhouse.io
    ```
    Обычно он называется `main`.

2.  **Отредактируйте его:**
    ```bash
    kubectl edit ingressnginxcontrollers.deckhouse.io main
    ```

3.  **Добавьте или измените секцию `spec.defaultSSLCertificate`:**
    Укажите имя и namespace секрета, созданного на предыдущем шаге.

    ```yaml
    apiVersion: deckhouse.io/v1alpha1
    kind: IngressNginxController
    metadata:
      name: main
    spec:
      # ... другие параметры
      defaultSSLCertificate:
        secretRef:
          name: my-corp-wildcard-tls # Имя вашего секрета
          namespace: d8-ingress-tls   # Namespace вашего секрета
    ```
    Ingress-контроллер автоматически подхватит изменения.

##### Для отдельных Ingress-ресурсов

Если вам нужно использовать специфический сертификат для конкретного приложения, укажите его напрямую в манифесте `Ingress`:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - my-app.mycompany.local
    secretName: my-app-tls-secret # Секрет для этого конкретного приложения
  rules:
  - host: my-app.mycompany.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-app-service
            port:
              number: 80
```

##### Доверие к корпоративному CA

Если вашим внутренним сервисам в кластере нужно доверять другим сервисам, использующим сертификаты, выданные вашим корпоративным CA, этот CA нужно добавить в доверенные на уровне кластера.

1.  **Создайте `Secret` с корневым сертификатом:**
    ```bash
    kubectl create secret generic corporate-root-ca --from-file=ca.crt=./path/to/root_ca.crt -n d8-system
    ```

2.  **Укажите его в конфигурации Deckhouse:**
    Отредактируйте `ClusterConfiguration`, добавив ссылку на этот секрет.
    ```bash
    d8 system edit cluster-configuration
    ```
    Добавьте секцию `customCA`:
    ```yaml
    apiVersion: deckhouse.io/v1
    kind: ClusterConfiguration
    # ...
    customCA:
      secretName: corporate-root-ca
      namespace: d8-system
    ```

---

### Стратегия обновления сертификатов

Процесс обновления практически идентичен созданию.

1.  **Получите новые файлы сертификата и ключа** от вашего центра сертификации.
2.  **Удалите старый секрет и создайте новый с тем же именем**, используя команду `kubectl create secret tls`. Это самый простой способ.
    ```bash
    kubectl delete secret tls my-corp-wildcard-tls -n d8-ingress-tls

    kubectl create secret tls my-corp-wildcard-tls \
      --cert=./new-certs/fullchain.pem \
      --key=./new-certs/privkey.pem \
      --namespace=d8-ingress-tls
    ```
    **Альтернатива (бесшовное обновление):** Вместо удаления и создания можно подготовить YAML-файл секрета и применить его через `kubectl apply`. Это позволяет избежать короткого промежутка времени, когда секрета не существует.

    ```bash
    # Получить текущий секрет в формате YAML
    kubectl get secret my-corp-wildcard-tls -n d8-ingress-tls -o yaml > secret.yaml

    # Заменить значения полей data.tls\.crt и data.tls\.key на новые, закодированные в base64
    # Например:
    # cat ./new-certs/fullchain.pem | base64 -w 0
    # cat ./new-certs/privkey.pem | base64 -w 0

    # Применить обновленный манифест
    kubectl apply -f secret.yaml
    ```
Компоненты, использующие этот секрет (например, Ingress-контроллер), автоматически обнаружат обновление и начнут использовать новый сертификат.

### Мониторинг и оповещения

Ключевая часть стратегии в ручном режиме — это своевременное оповещение об истечении срока действия сертификатов.

Deckhouse включает в себя Prometheus и Grafana, которые можно использовать для этой цели. В `kube-state-metrics` (входит в Deckhouse) есть метрика, отслеживающая дату истечения сертификатов в секретах типа `kubernetes.io/tls`.

*   **Метрика:** `kube_secret_cert_not_after`
*   **Prometheus Alert Rule:** Вы можете настроить правило в Prometheus, которое будет срабатывать, если до истечения сертификата осталось меньше 30 дней.

Пример правила для Prometheus:

```yaml
- alert: KubeSecretCertificateExpiresSoon
  expr: |
    kube_secret_cert_not_after{type="kubernetes.io/tls"} - time() < 30 * 24 * 60 * 60
  for: 1h
  labels:
    severity: warning
  annotations:
    summary: "Сертификат в секрете {{ $labels.namespace }}/{{ $labels.secret }} скоро истечет"
    description: "TLS сертификат в секрете '{{ $labels.namespace }}/{{ $labels.secret }}' истекает {{ humanize ( $value ) }}. Необходимо его обновить."
```

Это правило отправит оповещение, которое даст администраторам достаточно времени на ручное обновление.

### Резюме оптимальной стратегии

1.  **Подготовка:** Определите все домены и получите для них сертификаты (файл с полной цепочкой и ключ).
2.  **Создание:** Для каждого сертификата создайте `Secret` типа `kubernetes.io/tls` в выделенном namespace (например, `d8-ingress-tls`).
3.  **Интеграция:** Настройте `IngressNginxController` для использования wildcard-сертификата по умолчанию и/или укажите секреты в конкретных `Ingress`-ресурсах.
4.  **Доверие:** При необходимости добавьте корневой сертификат компании в `ClusterConfiguration` как `customCA`.
5.  **Мониторинг:** Настройте оповещения в Prometheus на основе метрики `kube_secret_cert_not_after` для упреждающего уведомления об истечении срока действия.
6.  **Обновление:** По получении оповещения повторите процедуру получения и обновления секрета в Kubernetes. Используйте `kubectl apply` для бесшовного обновления.
