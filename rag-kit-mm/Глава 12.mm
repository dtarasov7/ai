
# Глава 12: RAG + AI-агенты + LangGraph

## Основы AI-агентов

### Что такое AI-агент
- LLM + цикл выполнения
- Завершается при выполнении задачи
- Простая концепция, мощный результат

### Преимущества агентов
- Разбиение сложных задач на подзадачи
- Использование способностей к рассуждению
- Многошаговые процессы RAG
- Адаптация к новым обстоятельствам

### LLM как мозг агента
- Определяет качество рассуждений
- Можно заменить "мозг" в любой момент
- Возможность использовать несколько LLM
- Проверка друг друга

## LangGraph

### Основная информация
- Представлен в 2024 году
- Расширение поверх LCEL
- Для композиционных агентных процессов

### Ключевые возможности
- Определение циклов (цикличные графы)
- Встроенная память
- Персистентность состояния
- Человек в цикле (human-in-the-loop)

### Замена AgentExecutor
- Старый способ управления агентами
- Теперь рекомендуется LangGraph
- Графовый подход к организации

## Теория графов

### Основные элементы
- **Узлы (nodes)** - объекты/шаги
- **Рёбра (edges)** - связи между узлами
- **Условные рёбра** - точки принятия решений

### Типы узлов в RAG-агенте
- Start - начало
- Agent - агент принимает решения
- Retrieve - поиск информации
- Generate - генерация ответа
- Improve - улучшение запроса
- Observe - наблюдение
- End - завершение

### Циклический граф
- Повторение до выполнения задачи
- Условные переходы
- Контроль потока выполнения

## Подход ReAct

### Концепция
- Reason + Act (рассуждение + действие)
- Одна из первых парадигм агентов

### Процесс
1. Анализ ситуации
2. Размышление о действии
3. Выбор действия
4. Выполнение в среде
5. Получение результата наблюдения
6. Повторение цикла

### Преимущества
- Структурированный подход
- Ясный поток управления
- Предотвращение ошибок

## Инструменты (Tools)

### Концепция инструментов
- Действия для выполнения задач
- Предоставляются агенту
- Список доступных инструментов

### Примеры инструментов

#### Web Search (Tavily)
- Поиск информации в интернете
- max_results параметр
- API ключ требуется

#### Retriever Tool
- Поиск в индексе RAG
- Использует ensemble_retriever
- Описательное название

### Toolkits
- Наборы связанных инструментов
- Для конкретных задач
- Примеры: pandas DataFrame, GitHub
- Готовые интеграции LangChain

### Работа с инструментами
- LLM выбирает инструмент
- Определяет способ применения
- Передаёт необходимые данные
- Важность правильных названий

## Состояние агента (AgentState)

### Определение
- Ключевой компонент LangGraph
- Отслеживание состояния во времени
- Локальный механизм для графа

### Компоненты

#### Класс AgentState
```python
class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], add_messages]
```

#### BaseMessage
- Базовый класс сообщений
- Структура диалога
- Свойства сообщений

#### HumanMessage
- Сообщения от пользователя
- Формирование промтов
- Часть истории диалога

### Персистентность
- Сохранение памяти агента
- История всех действий
- Поддержка нескольких разговоров

## Узлы графа

### Agent Node
- Вызов модели агента
- Генерация ответа
- Решение об использовании инструментов
- bind_tools для связывания

### Retrieve Node
- ToolNode с инструментами
- Web search или retriever
- Получение информации

### Improve Node
- Переформулирование запроса
- Улучшение семантики
- Возврат к агенту

### Generate Node
- Формирование итогового ответа
- Использование generation_prompt
- RAG цепочка (prompt | llm | parser)

### Score Documents
- Оценка релевантности
- Условное ребро
- Решение: generate или improve

## Условные рёбра

### score_documents функция

#### Модель оценки
```python
class scoring(BaseModel):
    binary_score: str = Field(description="'yes' or 'no'")
```

#### Процесс оценки
1. Получение состояния
2. Извлечение документов
3. Оценка релевантности LLM
4. Возврат решения

#### Результаты
- "yes" → generate (релевантно)
- "no" → improve (нерелевантно)

### tools_condition
- Готовая функция LangGraph
- Определение использования инструментов
- "tools" → retrieve
- END → завершение

## Настройка графа

### Создание workflow
```python
workflow = StateGraph(AgentState)
```

### Добавление узлов
- workflow.add_node("agent", agent)
- workflow.add_node("retrieve", retrieve)
- workflow.add_node("improve", improve)
- workflow.add_node("generate", generate)

### Определение рёбер

#### Входная точка
- set_entry_point("agent")

#### Условные рёбра
- add_conditional_edges("agent", tools_condition)
- add_conditional_edges("retrieve", score_documents)

#### Обычные рёбра
- add_edge("generate", END)
- add_edge("improve", "agent")

### Компиляция
```python
graph = workflow.compile()
```

## Промты

### Generation Prompt
- Шаблон для генерации ответа
- Использует контекст и вопрос
- Инструкции для LLM

### Improve Prompt
- Анализ семантического намерения
- Формулировка улучшенного вопроса
- Возврат агенту

### Score Prompt
- Оценка релевантности документа
- Бинарная оценка yes/no
- Ключевые слова или семантика

## Конфигурация LLM

### Основная LLM
```python
llm = ChatOpenAI(model_name="gpt-4o", temperature=0, streaming=True)
```

### Agent LLM
```python
agent_llm = ChatOpenAI(model_name="gpt-4o", temperature=0, streaming=True)
```

### Параметры
- model_name - выбор модели
- temperature=0 - детерминированность
- streaming=True - потоковая передача

### Специализация
- Разные модели для разных задач
- Быстрые модели для простых задач
- Кастомные/fine-tuned модели

## Выполнение агента

### Входные данные
```python
inputs = {
    "messages": [("user", user_query)]
}
```

### Потоковое выполнение
- graph.stream(inputs)
- Наблюдение промежуточных результатов
- Отображение процесса мышления

### Выходные данные
- Output от каждого узла
- Промежуточные решения
- Итоговый ответ в final_answer

### Визуализация
- Отображение графа
- Mermaid диаграммы
- IPython display

## Пакеты и зависимости

### Основные библиотеки
- tiktoken - токенизация OpenAI
- langgraph - фреймворк агентов
- langchain - базовая функциональность

### Инструменты
- langchain_community.tools.tavily_search
- langchain.tools.retriever

### Типизация
- typing (Annotated, Literal, Sequence, TypedDict)
- pydantic (BaseModel, Field)

### Утилиты
- IPython.display - визуализация
- pprint - форматированный вывод

## Преимущества подхода

### Контроль потока
- Предотвращение неуправляемых агентов
- Четкая логика выполнения
- Завершение циклов

### Гибкость
- Замена компонентов
- Добавление инструментов
- Настройка под задачи

### Мощность
- Многошаговые процессы
- Сложные RAG-задачи
- Адаптивное поведение

### Прозрачность
- Видимость решений
- Отладка процессов
- Понимание логики

## Практическое применение

### Сценарии использования
- Сложные RAG-приложения
- Многоисточниковый поиск
- Динамическое улучшение запросов
- Чат-системы с контекстом

### Расширения
- Мультиагентные системы
- Интеграция графов знаний
- Различные фреймворки
- Архитектурные подходы

### Оптимизация
- Выбор моделей
- Настройка промтов
- Конфигурация инструментов
- Баланс скорости и качества
