ffff
ggg

#!/bin/bash

set -euo pipefail

# === Проверка переменных окружения ===
if [[ -z "${VAULT_ADDR:-}" ]]; then
    echo "Ошибка: не установлена переменная окружения VAULT_ADDR" >&2
    exit 1
fi

if [[ -z "${VAULT_TOKEN:-}" ]]; then
    echo "Ошибка: не установлен VAULT_TOKEN" >&2
    exit 1
fi

# === Аргументы ===
if [[ $# -lt 2 ]]; then
    echo "Использование:" >&2
    echo "  $0 <vault_base_path> <file_or_dir>" >&2
    echo "Примеры:" >&2
    echo "  $0 myapp ./secrets/myapp_db.json" >&2
    echo "  $0 myapp ./secrets/" >&2
    exit 1
fi

VAULT_BASE_PATH="$1"
INPUT_PATH="$2"

# Убираем начальные/конечные слэши у базового пути
VAULT_BASE_PATH="${VAULT_BASE_PATH#/}"
VAULT_BASE_PATH="${VAULT_BASE_PATH%/}"

# === Функция: получить текущий секрет из Vault (KV v2) ===
get_vault_secret() {
    local rel_path="$1"
    local vault_path="secret/data/${VAULT_BASE_PATH:+$VAULT_BASE_PATH/}${rel_path}"
    local url="${VAULT_ADDR}/v1/${vault_path}"

    local resp
    resp=$(curl -sS \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        --header "Accept: application/json" \
        "$url") || return 1

    # Проверяем, есть ли ошибка (например, 404)
    if echo "$resp" | jq -e '.errors // empty' >/dev/null; then
        return 1  # секрет не существует или ошибка доступа
    fi

    # Возвращаем только данные (без metadata)
    echo "$resp" | jq -r '.data.data'
}

# === Функция: загрузить файл в Vault ===
import_file() {
    local json_file="$1"
    local rel_path="$2"

    if [[ ! -f "$json_file" ]]; then
        echo "⚠️  Файл не найден: $json_file" >&2
        return 1
    fi

    if ! jq empty "$json_file" >/dev/null 2>&1; then
        echo "⚠️  Невалидный JSON в файле: $json_file" >&2
        return 1
    fi

    echo "🔍 Проверка секрета: $rel_path"

    # Получаем текущее значение из Vault (если есть)
    local current_data=""
    if current_data=$(get_vault_secret "$rel_path" 2>/dev/null) && [[ -n "$current_data" ]]; then
        # Секрет существует — сравниваем
        if jq --exit-status --argjson a "$(<"$json_file")" --argjson b "$current_data" -n '($a | (type == "object" and . == {})) or ($a | sort_keys) == ($b | sort_keys)' 2>/dev/null; then
            echo "⏭️  Пропущен (данные идентичны): $rel_path"
            return 0
        else
            echo "🔄 Данные отличаются — обновляем: $rel_path"
        fi
    else
        echo "🆕 Секрет отсутствует — создаём: $rel_path"
    fi

    # Формируем payload
    local payload
    payload=$(jq '{data: .}' "$json_file")

    # Отправляем в Vault
    local vault_full_path="secret/data/${VAULT_BASE_PATH:+$VAULT_BASE_PATH/}${rel_path}"
    local response
    response=$(curl -sS \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        --header "Content-Type: application/json" \
        --data-binary "$payload" \
        "${VAULT_ADDR}/v1/${vault_full_path}") || {
        echo "❌ Ошибка при загрузке $json_file" >&2
        return 1
    }

    if echo "$response" | jq -e '.errors // empty' >/dev/null; then
        echo "❌ Ошибка Vault: $(echo "$response" | jq -r '.errors | join(", ")')" >&2
        return 1
    fi

    echo "✅ Успешно загружено: $rel_path"
}

# === Основная логика ===
if [[ -f "$INPUT_PATH" ]]; then
    filename=$(basename "$INPUT_PATH")
    if [[ "$filename" != *.json ]]; then
        echo "⚠️  Файл должен иметь расширение .json" >&2
        exit 1
    fi

    rel_path="${filename%.json}"
    rel_path="${rel_path//_//}"
    import_file "$INPUT_PATH" "$rel_path"

elif [[ -d "$INPUT_PATH" ]]; then
    shopt -s nullglob
    files=("$INPUT_PATH"/*.json)
    shopt -u nullglob

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "⚠️  В каталоге нет файлов .json" >&2
        exit 1
    fi

    for file in "${files[@]}"; do
        filename=$(basename "$file")
        rel_path="${filename%.json}"
        rel_path="${rel_path//_//}"
        import_file "$file" "$rel_path"
    done

else
    echo "❌ Путь не является файлом или каталогом: $INPUT_PATH" >&2
    exit 1
fi

echo "✅ Импорт завершён."


@-------------------
    if current_data=$(get_vault_secret "$rel_path" 2>/dev/null) && [[ -n "$current_data" ]]; then
        # Секрет существует — сравниваем
        if jq --exit-status --arg new_data "$(<"$json_file")" --arg current_data "$current_data" -n '
            ($new_data | fromjson) as $new |
            ($current_data | fromjson) as $cur |
            ($new | type == "object" and ($new | length) == 0) or
            ($new | (type != "object") and ($new == $cur)) or
            ($new | type == "object" and ($new | to_entries | sort_by(.key)) == ($cur | to_entries | sort_by(.key)))
        ' 2>/dev/null; then
            echo "⏭️  Пропущен (данные идентичны): $rel_path"
            return 0
-------------
if current_raw=$(get_vault_secret "$rel_path" 2>/dev/null) && [[ -n "$current_raw" ]]; then
        # Приводим оба значения к каноническому виду: сортируем ключи, убираем пробелы
        local new_canonical current_canonical
        new_canonical=$(jq -S -c . "$json_file" 2>/dev/null)
        current_canonical=$(echo "$current_raw" | jq -S -c . 2>/dev/null)

        if [[ "$new_canonical" == "$current_canonical" ]]; then
            echo "⏭️  Пропущен (данные идентичны): $rel_path"
            return 0
        else
            echo "🔄 Данные отличаются — обновляем: $rel_path"
        fi
