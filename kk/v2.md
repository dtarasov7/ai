Отлично, спасибо за уточнение! Проблема в том, что имя ключа содержит **спецсимволы**, которые ломают обработку в `jq` или в интерпретации пути при рекурсивном обходе.

Конкретно в вашем случае ключ называется:
```
xxx-yyy[n,d],-pre[1,2]
```

Это **валидное имя ключа в Vault**, но оно содержит:
- квадратные скобки `[ ]`
- запятые `,`
- дефисы и точки — они безопасны, но скобки и запятые **могут нарушить работу `jq` или shell-интерпретации**, особенно если где-то используется неправильное цитирование.

---

### 🔍 Где именно ломается?

Скорее всего — в этом участке:
```bash
echo "$list_resp" | jq -r '.data.keys[]' | while IFS= read -r key; do
```

Если `jq` выводит строку с `[`, `]`, `,` — это **не проблема для `jq`**, но **если в ответе от Vault есть спецсимволы, и вы их не экранируете при построении URL**, то `curl` может получить **некорректный путь**.

Однако основная проблема — **в том, как Vault возвращает имена "директорий"**.

> ⚠️ В KV v2 (и в Vault в целом) **ключи, заканчивающиеся на `/`**, считаются "псевдодиректориями".  
> Например: `"xxx-yyy[n,d],-pre[1,2]/"` — обратите внимание на **завершающий слэш**!

Если вы не уберёте его аккуратно, то при построении пути получится:
```
secret/data/xxx-yyy[n,d],-pre[1,2]//
```
— и это вызовет ошибку 404 или 400.

Но **главная опасность** — в том, что **скобки `[` и `]` имеют особое значение в URL** (хотя и разрешены в path, но некоторые HTTP-клиенты или прокси могут их неправильно обработать). Однако `curl` сам по себе с ними справляется, **если путь правильно закодирован**.

Но **Vault не требует URL-кодирования имён ключей** — он принимает их "как есть", если передавать в правильном виде.

---

### ✅ Решение: безопасная обработка ключей

Нужно:
1. Убедиться, что **завершающий `/` удаляется корректно**.
2. **Не использовать ключ напрямую в shell-аргументах без кавычек**.
3. **Передавать путь в `curl` без изменений** — Vault принимает спецсимволы "как есть".

---

### 🛠 Исправленный фрагмент скрипта (только функция `walk_path`)

Замените в вашем скрипте функцию `walk_path` на эту версию:

```bash
walk_path() {
    local rel_path="$1"  # относительный путь, например: myapp или myapp/xxx-yyy[n,d],-pre[1,2]

    echo "📁 Проверка пути: $rel_path"

    # Формируем путь для LIST (metadata)
    local metadata_path="secret/metadata/${rel_path}"

    # Выполняем LIST-запрос
    local list_resp
    list_resp=$(vault_list "$metadata_path" 2>/dev/null) || {
        # Не удалось сделать list — пробуем прочитать как секрет
        local data_path="secret/data/${rel_path}"
        local read_resp
        if read_resp=$(vault_read "$data_path" 2>/dev/null); then
            if echo "$read_resp" | jq -e '.data.data' >/dev/null 2>&1; then
                echo "📥 Экспорт секрета: $rel_path"
                # Безопасное имя файла: заменяем / на _, остальное — как есть
                local safe_filename="${rel_path//\//_}"
                echo "$read_resp" | jq -r '.data.data' > "$OUTPUT_DIR/${safe_filename}.json"
                return 0
            fi
        fi
        echo "⚠️  Путь недоступен: $rel_path"
        return 1
    }

    # Проверяем наличие .data.keys
    if ! echo "$list_resp" | jq -e '.data.keys // empty' >/dev/null; then
        echo "⚠️  Нет ключей в ответе для: $rel_path"
        return 1
    fi

    # Получаем ключи — ОБЯЗАТЕЛЬНО в кавычках при чтении!
    echo "$list_resp" | jq -r '.data.keys[]' | while IFS= read -r -d $'\n' key; do
        # Пропускаем пустые строки
        [[ -z "$key" ]] && continue

        # Удаляем завершающий слэш, если есть (важно для "директорий")
        key="${key%/}"

        # Рекурсивный вызов — передаём как есть, в кавычках всё обрабатывается внутри функции
        walk_path "${rel_path}/${key}"
    done
}
```

---

### 🔒 Дополнительно: безопасное имя файла

В строке:
```bash
local safe_filename="${rel_path//\//_}"
```
мы **только заменяем `/` на `_`**, потому что `/` недопустим в имени файла.  
Остальные символы (`[`, `]`, `,`, `-`, `.`) — **разрешены в именах файлов в Linux**, так что их трогать не нужно.

Если вы хотите **ещё больше обезопасить** (например, для Windows или архивов), можно сделать:
```bash
safe_filename=$(printf '%s' "$rel_path" | sed 's/[^a-zA-Z0-9._-]/_/g')
```
— но это уже опционально.

---

### 💡 Почему падало?

Скорее всего, один из этих сценариев:
1. Ключ приходил как `"xxx-yyy[n,d],-pre[1,2]/"` → после `${key%/}` всё ок, но если где-то забыты кавычки — shell мог попытаться интерпретировать `[n,d]` как glob-паттерн (например, в `echo $key` без кавычек).
2. Или при построении пути получался двойной слэш, и Vault возвращал 404.

Но с **правильным цитированием (`"$key"`, `"$rel_path"`) и аккуратным удалением `/`** — всё должно работать.

---

### ✅ Проверка

Попробуйте вручную запросить такой ключ:
```bash
curl -H "X-Vault-Token: $VAULT_TOKEN" \
  "$VAULT_ADDR/v1/secret/metadata/xxx-yyy[n,d],-pre[1,2]"
```

Если Vault отвечает — значит, путь валиден, и скрипт должен с ним справиться.

---

Если после исправления всё ещё падает — пришлите **точное сообщение об ошибке** и **пример ответа от Vault** (можно замаскировать данные), и я помогу точно локализовать проблему.
