Вот готовый **Bash-скрипт для загрузки данных из JSON-файлов обратно в HashiCorp Vault (KV v2)** с использованием `curl` и `jq`.

Скрипт поддерживает:
- Загрузку **одного файла** или **всех `.json` файлов из каталога**
- Восстановление структуры путей на основе имён файлов (например, `myapp_db.json` → `secret/myapp/db`)
- Работу с KV v2 через HTTP API
- Безопасную сериализацию данных (автоматическое экранирование `\n`, кавычек и т.д.)

---

### ✅ Требования:
- Установлены: `curl`, `jq`
- Переменные окружения:
  ```bash
  export VAULT_ADDR=https://your-vault:8200
  export VAULT_TOKEN=s.your.token
  ```

---

### 📜 Скрипт: `vault_import_kv2.sh`

```bash
#!/bin/bash

set -euo pipefail

# === Проверка переменных окружения ===
if [[ -z "${VAULT_ADDR:-}" ]]; then
    echo "Ошибка: не установлена переменная окружения VAULT_ADDR" >&2
    exit 1
fi

if [[ -z "${VAULT_TOKEN:-}" ]]; then
    echo "Ошибка: не установлен VAULT_TOKEN" >&2
    exit 1
fi

# === Аргументы ===
if [[ $# -lt 2 ]]; then
    echo "Использование:" >&2
    echo "  $0 <vault_base_path> <file_or_dir>" >&2
    echo "Примеры:" >&2
    echo "  $0 myapp ./secrets/myapp_db.json" >&2
    echo "  $0 myapp ./secrets/" >&2
    exit 1
fi

VAULT_BASE_PATH="$1"
INPUT_PATH="$2"

# Убираем начальные/конечные слэши у базового пути
VAULT_BASE_PATH="${VAULT_BASE_PATH#/}"
VAULT_BASE_PATH="${VAULT_BASE_PATH%/}"

# === Функция загрузки одного файла ===
import_file() {
    local json_file="$1"
    local rel_path="$2"  # относительный путь в Vault (без secret/)

    if [[ ! -f "$json_file" ]]; then
        echo "⚠️  Файл не найден: $json_file" >&2
        return 1
    fi

    # Проверяем, что файл содержит валидный JSON
    if ! jq empty "$json_file" >/dev/null 2>&1; then
        echo "⚠️  Невалидный JSON в файле: $json_file" >&2
        return 1
    fi

    # Формируем полный путь в Vault
    local vault_full_path="secret/data/${VAULT_BASE_PATH:+$VAULT_BASE_PATH/}${rel_path}"

    echo "📤 Загрузка в Vault: $vault_full_path"

    # Генерируем payload: {"data": { ...содержимое файла... }}
    # jq автоматически экранирует спецсимволы (включая \n → \\n)
    local payload
    payload=$(jq '{data: .}' "$json_file")

    # Отправляем в Vault
    local response
    response=$(curl -sS \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        --header "Content-Type: application/json" \
        --data-binary "$payload" \
        "${VAULT_ADDR}/v1/${vault_full_path}") || {
        echo "❌ Ошибка при загрузке $json_file" >&2
        return 1
    }

    # Проверяем успешность (Vault возвращает 200/204 при успехе)
    if echo "$response" | jq -e '.errors // empty' >/dev/null; then
        echo "❌ Ошибка Vault: $(echo "$response" | jq -r '.errors | join(", ")')" >&2
        return 1
    fi

    echo "✅ Успешно загружено: $rel_path"
}

# === Основная логика ===
if [[ -f "$INPUT_PATH" ]]; then
    # Один файл
    filename=$(basename "$INPUT_PATH")
    if [[ "$filename" != *.json ]]; then
        echo "⚠️  Файл должен иметь расширение .json" >&2
        exit 1
    fi

    # Преобразуем имя файла в путь: myapp_db.json → myapp/db
    rel_path="${filename%.json}"
    rel_path="${rel_path//_//}"

    import_file "$INPUT_PATH" "$rel_path"

elif [[ -d "$INPUT_PATH" ]]; then
    # Каталог — ищем все .json файлы
    shopt -s nullglob
    files=("$INPUT_PATH"/*.json)
    shopt -u nullglob

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "⚠️  В каталоге нет файлов .json" >&2
        exit 1
    fi

    for file in "${files[@]}"; do
        filename=$(basename "$file")
        rel_path="${filename%.json}"
        rel_path="${rel_path//_//}"
        import_file "$file" "$rel_path"
    done

else
    echo "❌ Путь не является файлом или каталогом: $INPUT_PATH" >&2
    exit 1
fi

echo "✅ Импорт завершён."
```

---

### ▶️ Как использовать:

#### 1. Экспорт был сделан как:
```bash
./vault_export_kv2_curl.sh myapp ./secrets
# → создаёт файлы: ./secrets/myapp_db.json, ./secrets/myapp_api_keys.json
```

#### 2. Импорт обратно:
```bash
# Загрузить всё из каталога
./vault_import_kv2.sh myapp ./secrets

# Или один файл
./vault_import_kv2.sh myapp ./secrets/myapp_db.json
```

→ В Vault появятся секреты:
- `secret/myapp/db`
- `secret/myapp/api/keys`

---

### 🔁 Как работает преобразование имён файлов?

Скрипт предполагает, что **имена файлов используют `_` вместо `/`**, как в экспорте:
- `myapp_db.json` → `myapp/db`
- `myapp_api_keys.json` → `myapp/api/keys`

Если вы использовали **другой способ именования** (например, вложенные директории), скрипт можно адаптировать — дайте знать.

---

### 🔒 Важно:
- Скрипт **автоматически экранирует** все спецсимволы через `jq`, включая `\n` в сертификатах.
- Убедитесь, что у токена есть права `write` на `secret/data/...`.
- Используется **KV v2** (путь `secret/data/...`).

---

### 💡 Совет: если структура сложная

Если вы хотите сохранять **реальную иерархию директорий** (а не плоские имена), лучше модифицировать **экспортный скрипт**, чтобы он создавал вложенные папки, и тогда импорт будет проще. Но текущая реализация — прямая обратная операция к вашему экспорту.

---

Готов адаптировать под ваш формат имён файлов или структуру!
