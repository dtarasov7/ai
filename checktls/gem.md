Конечно, вот скрипт на Bash, который решает эту задачу. Он использует `openssl s_client` для попытки TLS-рукопожатия и анализирует результат, чтобы определить тип ожидаемого соединения.

### Как это работает:

1.  **Попытка TLS-соединения:** Скрипт сначала пытается установить TLS-соединение с помощью `openssl s_client`.
2.  **Анализ mTLS:** Если соединение установлено, скрипт ищет в выводе `openssl` строку `"Certificate Request"`. Это сообщение сервер отправляет, когда требует от клиента предоставить свой сертификат. Если строка найдена — это **mTLS**.
3.  **Анализ TLS:** Если соединение установлено, но запроса сертификата от клиента нет, значит, сервер ожидает обычное **TLS** соединение.
4.  **Анализ обычного соединения (Plain TCP):** Если `openssl s_client` не может установить соединение (потому что сервер не "говорит" на языке TLS), скрипт делает вторую проверку с помощью `nc` (netcat). Если `nc` успешно подключается, это означает, что порт открыт, но не для TLS. Следовательно, это **обычное (plain)** соединение.
5.  **Ошибка:** Если и `openssl`, и `nc` не могут подключиться, порт, скорее всего, закрыт или недоступен.

---

### Скрипт (check_conn_type.sh)

```bash
#!/bin/bash

# Скрипт для проверки типа соединения (TLS, mTLS, обычное) на порту.
# Не использует сертификаты и не передает данные.

# --- Проверка наличия необходимых утилит ---
command -v openssl >/dev/null 2>&1 || { echo >&2 "Ошибка: утилита 'openssl' не найдена. Установите ее."; exit 1; }
command -v nc >/dev/null 2>&1 || { echo >&2 "Ошибка: утилита 'nc' (netcat) не найдена. Установите ее."; exit 1; }
command -v timeout >/dev/null 2>&1 || { echo >&2 "Ошибка: утилита 'timeout' не найдена. Установите ее (обычно в пакете coreutils)."; exit 1; }

# --- Проверка аргументов ---
if [ "$#" -ne 2 ]; then
    echo "Использование: $0 <хост> <порт>"
    echo "Пример: $0 localhost 8443"
    exit 1
fi

HOST=$1
PORT=$2
TIMEOUT_SECONDS=5

echo "Проверяю хост $HOST на порту $PORT..."

# Попытка выполнить TLS-рукопожатие с помощью openssl.
# echo -n | ... - чтобы команда не ждала ввода от пользователя и сразу закрыла соединение.
# 2>&1 - перенаправляем stderr в stdout, чтобы поймать все сообщения.
# timeout - чтобы не ждать вечно, если сервер не отвечает.
output=$(echo -n | timeout $TIMEOUT_SECONDS openssl s_client -connect "${HOST}:${PORT}" 2>&1)
exit_code=$?

# --- Анализ результата ---

if [ $exit_code -eq 0 ]; then
    # Команда openssl завершилась успешно, значит, рукопожатие TLS удалось.
    # Теперь проверяем, был ли запрос клиентского сертификата (признак mTLS).
    # "Certificate Request" или "Acceptable client certificate CA names" - надежные индикаторы.
    if echo "$output" | grep -q -E "Certificate Request|Acceptable client certificate CA names"; then
        echo "Результат: mTLS (сервер запрашивает сертификат клиента)"
    else
        echo "Результат: TLS (стандартное TLS/SSL соединение)"
    fi
else
    # Команда openssl завершилась с ошибкой.
    # Возможные причины: порт закрыт, или это plain TCP порт, который не понял "ClientHello".
    # Проверим, открыт ли порт в принципе с помощью netcat.
    # -z - сканировать, не отправляя данные.
    # -w1 - таймаут 1 секунда.
    timeout 2 nc -z -w 1 "$HOST" "$PORT" >/dev/null 2>&1
    nc_exit_code=$?

    if [ $nc_exit_code -eq 0 ]; then
        # nc подключился, а openssl нет. Значит, это обычный TCP-порт.
        echo "Результат: Обычное соединение (Plain TCP)"
    else
        # Не удалось подключиться ни openssl, ни nc.
        echo "Результат: Не удалось подключиться. Порт закрыт, заблокирован или хост недоступен."
        # Можно вывести ошибку openssl для диагностики
        # echo -e "\n--- Детали ошибки openssl ---\n$output"
    fi
fi

exit 0
```

### Как использовать:

1.  Сохраните код в файл, например, `check_conn_type.sh`.
2.  Сделайте его исполняемым: `chmod +x check_conn_type.sh`
3.  Запустите, указав хост и порт:

    ```bash
    # Проверка веб-сервера с TLS
    ./check_conn_type.sh google.com 443
    # Вывод:
    # Проверяю хост google.com на порту 443...
    # Результат: TLS (стандартное TLS/SSL соединение)

    # Проверка сервера, требующего mTLS (пример, если у вас есть такой)
    ./check_conn_type.sh my-mtls-server.com 8443
    # Вывод:
    # Проверяю хост my-mtls-server.com на порту 8443...
    # Результат: mTLS (сервер запрашивает сертификат клиента)

    # Проверка SSH-порта (обычное TCP-соединение)
    ./check_conn_type.sh localhost 22
    # Вывод:
    # Проверяю хост localhost на порту 22...
    # Результат: Обычное соединение (Plain TCP)

    # Проверка закрытого порта
    ./check_conn_type.sh localhost 9999
    # Вывод:
    # Проверяю хост localhost на порту 9999...
    # Результат: Не удалось подключиться. Порт закрыт, заблокирован или хост недоступен.
    ```
