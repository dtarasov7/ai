Задача - хранить и визуализировать информацию о версиях 
opensource ПО серверах и о смене версии.

Предлагается следующее решение.

В качестве хранилища - prometheus v2.49
Визуализация - grafana v11

Написан скрипт на bash, который по cron (1 раз в час - настраивается, может быть меньше или больше)
запускается на целевом сервере и
получает версию установленного на сервере ПО.

Скрипт раскладывается на сервера через ansible роль.

Cкрипт формирует файл state.json, в котором 
сохраняет для каждого ПО  текущую версию, предыдущую версию и время смены версии.
Пример
{
  "apps": {
    "nginx": {
      "current": "1.25.4",
      "previous": "1.24.0",
      "changes_total": 3,
      "change_time": 1728624005
    },
    "openssl": { ... }
  }
}

При запуске: читается состояние сохраненое при предыдущем запуске, 
в процессе работы сравниваются current с обнаруженными версиями,
при изменении — инкрементировать changes_total 
и обновляется previous/current/change_time.

Результат с версиями сохраняется в виде метрик в файле 
в формате Prometheus и загружается в prometheus 
через node-exporter (textfile-collector), работающем на этом целево сервере.
Метрика имеет имя app_version_info и метки 
nodename, appname, current_version, previous_version, change_time.

Значение метрик - это число, полученное из текстовой версии:

version_numeric=$(echo "$version_str" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')


Если файл state.json отсутствует, 
инициализировать его текущими версиями (без фиксации как "изменение").

Также скрипт создает метрику app_version_check_timestamp 
c метками nodename, appname для отслеживания последней проверки.

В grafana создан дашборд, который позволяет просматривать установленное 
на серверах ПО, их текущие версии, предыдущие версии
и время смены версии.

Настроены алерты:
Алерт на любое изменение: changes(app_version_info[2h]) > 0.
Алерт на понижение версии: app_version_info < (app_version_info offset 2h)

В скрипте реализован механизм блокировки (lock-файл) для предотвращения параллельных запусков

Проанализируй это решение и дай свои предложения по улучшению.
Использование дополнительного ПО ( postgres, clickhouse и т.д) - НЕ рассматривать.
Использование Pushgateway НЕ рассматривать.
