Задача - хранить и визуализировать информацию о версиях 
opensource ПО серверах и о смене версии.

Реализуется следующее решение.

В качестве хранилища - prometheus v2.49
Визуализация - grafana v11

Написан скрипт на bash, который по cron (1 раз в час - настраивается, может быть меньше или больше)
запускается на целевом сервере и
получает версию установленного на сервере ПО и формирует 
метрики в формате prometheus:

1. Информационная метрика (info-metric):
Имя: app_version_info
Метки: nodename, appname, version (строковое значение версии)
Значение: Всегда 1.
Пример: app_version_info{nodename="srv-1", appname="nginx", version="1.22.1"} 1
Эта метрика решает проблему высокой кардинальности, 
так как в любой момент времени для пары {nodename, appname}
активна только одна временная серия. 
Старые серии со временем уйдут из базы данных. 
Эта метрика нужна только для отображения красивой 
версии в Grafana.

2. Числовая метрика (numeric-metric):

Имя: app_version_numeric
Метки: nodename, appname
Значение: Версия ПО, закодированная в число.
Пример кодирования: Версия "1.22.1" превращается в число 1022001. 
(Major * 1000000 + Minor * 1000 + Patch).
Пример преобразования текста в число
version_numeric=$(echo "$version_str" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')

# Улучшенная функция кодирования версии
encode_version() {
    local version="$1"
    
    # Удаляем pre-release суффиксы (все после -, +, ~)
    version=$(echo "$version" | sed 's/[-+~].*//')
    
    # Поддержка до 4 компонентов, каждый до 9999
    local IFS='.'
    read -ra parts <<< "$version"
    
    # Дополняем нулями если компонентов меньше 4
    while [ ${#parts[@]} -lt 4 ]; do
        parts+=("0")
    done
    
    # Формула: v1*1000000000000 + v2*100000000 + v3*10000 + v4
    printf "%d%04d%04d%04d" "${parts[0]}" "${parts[1]}" "${parts[2]}" "${parts[3]}"
}

# Примеры:
# 1.22.1     -> 10022000100000
# 2.4.54.3   -> 20004005400003
# nginx/1.25 -> 10025000000000

Пример: app_version_numeric{nodename="srv-1", appname="nginx"} 1022001
Эта метрика идеальна для математических операций: сравнений,
поиска изменений и т.д.

3. Числовая метрика (numeric-metric):

Имя: app_version_change_time_seconds
Метки: nodename, appname
Значение: время в секундах когда произошла предыдущая смена версии.


Cкрипт формирует файл state.json, в котором 
сохраняет для каждого ПО  текущую версию, предыдущую версию и время смены версии.
Пример
{
  "apps": {
    "nginx": {
      "current": "1.25.4",
      "previous": "1.24.0",
      "changes_total": 3,
      "change_time": 1728624005
    },
    "openssl": { ... }
  }
}

Скрипт: 
- считывает файл state.json
- Получает версии ПО в виде строки.
- Для каждого ПО сравниваются current с обнаруженными версиями.
  при изменении — инкрементируется changes_total и обновляется previous/current/change_time.
- Для каждого ПО генерирует метрики.
- Атомарно записывает метрики в .prom файл для node-exporter.
- Записывает обновленный state.json

Дополнительные метрики:

- Время когда произошло сканирование версий ПО
app_version_scrape_timestamp_seconds{instance, appname} 

- для наблюдения за самим сборщиком
app_version_collector_success{instance} 0/1 
app_version_collector_duration_seconds — для наблюдения за самим сборщиком.

Grafana:
Дашборд показывает текущие версии (из меток app_version_info).
Графики показывают историю изменений версий (из app_version_numeric).
С помощью offset можно показать и предыдущую версию.
- Определить время последнего изменения:
time() - last_over_time(timestamp(app_version_numeric != app_version_numeric offset 1h)[1d:])
- Отобразить предыдущую версию:
last_over_time(app_version_numeric[1d] offset 1h)

Настроены алерты:
Алерт на любое изменение: 
app_version_numeric != app_version_numeric offset 1h
Любое изменение: changes(app_version_numeric[2h]) > 0
Либо проще: delta(app_version_numeric[2h]) != 0

Алерт на понижение версии: 
app_version_numeric < app_version_numeric offset 1h
Понижение: delta(app_version_numeric[2h]) < 0

алерта на «завис скрипт/данные устарели»:
time() - app_version_scrape_timestamp_seconds > 3h


Скрипт раскладывается на сервера через ansible роль.

В скрипте реализован механизм блокировки (lock-файл) для предотвращения параллельных запусков

Составь структурированное описание решения и архитектурные диаграммы в формате plantuml для того, 
чтобы посторонние могли легко разобраться в этом решении, понять как оно работает и какой от него профит.
