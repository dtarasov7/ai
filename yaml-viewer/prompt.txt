Сделай, пожалуйста, полноценную консольную TUI‑утилиту на Python для просмотра больших yaml файлов в виде интерактивного дерева (терминальный интерфейс на базе curses).

## Назначение

Нужно приложение для разработчика/devops, которое позволяет удобно просматривать очень большие составные yaml без загрузки всего в память, с поиском и фильтрацией полей.


## Технические требования

1. **Язык и зависимости**
   - Python 3.10+.
   - Только стандартная библиотека (можно использовать `curses`, `json`, `pathlib`, `re`, `signal`, `typing`, `os`, `sys`).
   - Один файл: `json_tui_viewer_secure.py`.

2. **Форматы входных данных**
   - Обычный yaml: один большой объект.
   - составной yaml файл: несколько yaml объектов разделенных ---.
   - Программа должна несколько обычных или сосотвных yaml файлов

3. **Архитектура**
   - используется кеширование и ленивое чтение

4. **Поведение TUI**

   Экран:
   - Верхняя строка: имя файла, количество объектов, индикатор фильтра.
   - Основная область: дерево YAML.
   - Нижние строки: статус/сообщения и подсказки по управлению.

   Отображение дерева:
   - Отступ по `depth`, маркер `+`/`-` для сворачиваемых узлов, пробел для листьев.
   - На корневых объектах (записях) индекс: `[N]`.
   - Для dict: `{...} (X keys)`.
   - Для list: `[...] (X items)`.
   - Строки обрезаются по ширине терминала с добавлением `...`.

   Управление (клавиши):
   - Стрелки/vi:
     - `↑` / `k` — вверх.
     - `↓` / `j` — вниз (при приближении к концу — подгружать следующие объекты).
     - `→` / `l` — развернуть узел (если не лист).
     - `←` — свернуть узел; если уже свернут — перейти к родителю.
   - Enter:
     - На листовом узле — открыть полноэкранный просмотр значения с прокруткой (строки и столбцы).
     - На нелистовом — toggle (expand/collapse).
   - Объекты:
     - `a` — развернуть весь текущий объект (только этот объект), рекурсивно, с лимитом по числу узлов.
     - `z` — свернуть текущий объект целиком.
     - `A` — развернуть *все уже загруженные* объекты (не загружать весь файл!).
     - `Z` — свернуть все объекты.
   - Переход между объектами:
     - `g` — перейти к объекту по номеру.
     - `Home` — первый объект.
     - `End` — последний объект.
     - `PgDn` — следующий объект с сохранением относительного пути к полю (если возможно).
     - `PgUp` — предыдущий объект с сохранением относительного пути к полю (если возможно).
   - Поиск:
     - `s` — поиск по текущему полю:
       - Запрос строки (подсказка “regex”).
       - Поиск по всем объектам только по этому полю.
       - Результаты — список `YamlNode`, навигация по ним `n` / `p`.
     - `F` — глобальный поиск:
       - Поиск по всем листовым полям.
       - Возврат списка совпадений и множества имен полей, в которых были найдено.
       - Автоматическое включение фильтра по этим полям.
       - Навигация по результатам `n` / `p`.
   - Фильтрация:
     - `f` — диалог выбора полей:
       - Список уникальных листовых полей (по первому объекту или по уже загруженным).
       - Переключение пробелом, Enter — применить, Esc — отмена.
       - Фильтрация так, чтобы:
         - Лист отображается только если его ключ в фильтре.
         - Внутренние узлы отображаются, если где-то в поддереве есть подходящий лист.
   - Выход:
     - `q` / `Esc` — выход.

5. **Производительность и ленивость**

   - При старте:
     - Если одиночный YAML — загрузить целиком, построить корневой объект.
     - Если составной YAML — построить только индекс смещений (позиции строк), сами объекты не загружать.
   - Подгрузка:
     - При первом показе — предзагрузить только `max(list_height + 10, 20)` объектов.
     - При прокрутке вниз, если курсор приближается к концу списка видимых узлов — подгружать следующую пачку (например, по 5 объектов).
   - Кэш:
     - Не хранить всех объектов в памяти.
     - LRU‑кэш на ~200 объектов: при переполнении выкидывать самые старые.
   - `expand_all`:
     - Работает только по уже загруженным объектам.
     - Учитывать лимит общего количества узлов, чтобы не съесть всю память.

6. **Безопасность**

   Реализовать защиту от следующих рисков (без использования внешних библиотек):

   1) **YAML Bomb / DoS по содержимому, а не по размеру файла**:
      - Ввести функцию `validate_yaml_object(obj, depth=0, path="root")`, которая рекурсивно проверяет объект и выбрасывает `SecurityError`, если:
        - Глубина вложенности > `MAX_yaml_DEPTH` (например, 100).
        - Длина строки > `MAX_STRING_LENGTH` (например, 10 MB).
        - Число содержит > `MAX_NUMBER_DIGITS` цифр (например, 4300 — как защита от CVE‑2020‑10735).
        - Массив содержит > `MAX_ARRAY_ITEMS` элементов (например, 1 000 000).
        - Dict содержит > `MAX_OBJECT_KEYS` ключей (например, 100 000).
      - Эту функцию вызывать:
        - Для одиночного yaml — сразу после `yaml.load`.
        - Для составного yaml — в `__getitem__` после `yaml.loads(line)` для каждого объекта.
      - Если объект “опасный”:
        - Не падать целиком.
        - Либо выбрасывать `SecurityError` при загрузке одиночного файла.
        - Либо для составного YAML:
          - Писать предупреждение в stdout.
          - Возвращать объект‑заглушку вида `{"_error": "Объект N пропущен по соображениям безопасности: ... "}`.

   2) **ReDoS (Regular Expression DoS)**:
      - Пользователь вводит паттерн (строка) для `s` и `F`.
      - Нужно:
        - Скомпилировать regex с ограничением времени (например, через `signal.SIGALRM` на Unix).
        - Ввести функции:
          - `safe_regex_compile(pattern_str, timeout=2)` — компиляция с таймаутом, при истечении — `TimeoutError` и переход на простой поиск подстроки.
          - `safe_regex_search(pattern, text, timeout=2)` — поиск с таймаутом и обрезкой слишком длинных строк (например, до 10 000 символов).
        - Если regex слишком сложный (таймаут или ошибка компиляции) — использовать поиск как `pattern_str.lower() in text.lower()`.

   3) **Resource Exhaustion при `expand_all`**:
      - В `yamlNode.expand_all(node_counter)`:
        - Параметр `node_counter: List[int]` — счётчик уже созданных узлов.
        - Перед созданием новых детей проверять, что `node_counter[0] <= MAX_EXPAND_NODES` (например, 100 000).
        - При превышении — выбросить `SecurityError`.
      - Клавиша `A` должна:
        - НЕ делать цикл `for i in range(len(yaml_file))` с загрузкой всех объектов.
        - А:
          - Пройти только по `root.children` (уже загруженные объекты).
          - Для каждого вызвать `expand_all(node_counter)`.
          - Вывести в статусе, сколько узлов было развёрнуто.
      - Клавиша `a` — только по текущему объекту с тем же лимитом.

   4) **Path / device safety**:
      - Файл открывается с путём из аргумента командной строки.
      - Ввести `validate_file_path(filepath: str) -> Path`, которая:
        - Нормализует путь через `Path.resolve()`.
        - Проверяет, что файл существует и это обычный файл (`is_file()`).
        - Запрещает пути, начинающиеся с `/dev/`, `/proc/`, `/sys/` (чтение псевдо‑устройств типа `/dev/zero` и т.п.).
      - При нарушении — выбросить `SecurityError` и вывести пользователю понятное сообщение.

7. **Пользовательский опыт**

   - При старте:
     - Понятное сообщение об ошибках (файл не найден, невалидный yaml, опасная структура и т.п.).
   - В статусной строке:
     - Отображать:
       - Индекс текущего объекта.
       - Общее количество объектов.
       - Количество видимых узлов.
       - Позицию курсора (N/M).
       - Краткие сообщения о результатах поиска, фильтров, ошибок безопасности.
   - Диалоговые окна (`input_string`, выбор полей, просмотр значения) должны корректно обрабатывать Esc/`q`.

8. **Качество кода**

   - Обязательно:
     - Читаемые имена переменных и функций.
     - Краткие docstring’и у основных классов и функций.
     - Однострочные комментарии на русском языке только в местах, где логика неочевидна (например, восстановление пути при PgUp/PgDn, защита от DoS, работа кэша).
   - Код должен быть готов к прямому запуску:
     - `python yaml_tui_viewer_secure.py path/to/file.yaml [path/to/file2.yaml[]]`.

***

Сформируй полный исходный код `yaml_tui_viewer_secure.py`, строго удовлетворя требованиям выше.
