# Требования к функциональным возможностям подсистемы RBAC объектного хранилища S3

## 1. Управление пользователями и учетными записями

### 1.1 Модель пользователей
- Поддержка создания пользователей с уникальными идентификаторами (UID)
- Возможность назначения отображаемого имени (display name) для каждого пользователя
- Генерация и управление парами ключей доступа (access key / secret key) для аутентификации S3[1]
- Поддержка множественных пар ключей доступа для одного пользователя с возможностью ротации[2]
- Поддержка создания подпользователей (subusers) с собственными ключами для протокола Swift[1]
- Возможность создания системных (system) и административных (admin) пользователей с расширенными правами[1]
- Поддержка установки email адреса для пользователя (опционально)[2]

### 1.2 Мультитенантность
- Поддержка изоляции пользователей и ресурсов на уровне тенантов (tenant)[1]
- Возможность создания пользователей в контексте конкретного тенанта с синтаксисом `<tenant>$<user>`[3][1]
- Поддержка операций с бакетами через синтаксис `<tenant>:<bucket>` для доступа к ресурсам других тенантов[3][1]
- Каждый тенант должен иметь собственное пространство имен для бакетов, что позволяет использовать одинаковые имена бакетов в разных тенантах[3][1]
- Поддержка неявного тенанта (legacy tenant) с пустым именем для обратной совместимости[1]
- Возможность явного указания тенанта в S3 API через заголовок или параметр запроса[3]

## 2. Политики управления доступом

### 2.1 Bucket Policies (Политики бакетов)
- Поддержка политик на уровне бакетов в формате AWS IAM Policy (JSON)[4][1]
- Версия политик: "2012-10-17"[4][1]
- Структура политики должна включать:[1]
  - `Version` - версия формата политики
  - `Statement` - массив правил с элементами:
    - `Effect`: "Allow" или "Deny"
    - `Principal`: идентификация субъектов через ARN формата `arn:aws:iam:::user/<username>` или wildcard "*"
    - `Action`: список разрешенных/запрещенных операций S3
    - `Resource`: целевые ресурсы в формате `arn:aws:s3:::<bucket>` и `arn:aws:s3:::<bucket>/*`
    - `Condition`: опциональные условия применения правила
- Управление политиками через стандартные S3 API операции: PutBucketPolicy, GetBucketPolicy, DeleteBucketPolicy[4]

### 2.2 Поддерживаемые S3 Actions
Система должна поддерживать следующие операции S3 в политиках:[1]
- **Bucket operations**: s3:CreateBucket, s3:DeleteBucket, s3:ListBucket, s3:ListBucketVersions, s3:ListBucketMultipartUploads, s3:GetBucketLocation
- **Object operations**: s3:GetObject, s3:PutObject, s3:DeleteObject, s3:GetObjectVersion, s3:DeleteObjectVersion
- **ACL operations**: s3:GetObjectAcl, s3:PutObjectAcl, s3:GetBucketAcl, s3:PutBucketAcl
- **Multipart operations**: s3:ListMultipartUploadParts, s3:AbortMultipartUpload
- **Versioning**: s3:GetBucketVersioning, s3:PutBucketVersioning
- **Policy operations**: s3:GetBucketPolicy, s3:PutBucketPolicy, s3:DeleteBucketPolicy

### 2.3 Условные ключи (Condition Keys)
Поддержка следующих ключей условий для политик:[1]
- `aws:CurrentTime` - текущее время запроса
- `aws:EpochTime` - время в формате Unix timestamp
- `aws:PrincipalType` - тип субъекта запроса
- `aws:Referer` - HTTP referer заголовок
- `aws:SecureTransport` - использование HTTPS (булево значение)
- `aws:SourceIp` - IP-адрес источника запроса
- `aws:UserAgent` - User-Agent клиента
- `aws:username` - имя пользователя
- `s3:x-amz-acl` - предустановленные ACL при создании объектов
- `s3:prefix` - префикс для операций листинга
- `s3:delimiter` - разделитель для операций листинга

### 2.4 Операторы условий
Поддержка следующих операторов для Condition блоков в политиках:[4]
- StringEquals, StringNotEquals
- StringLike, StringNotLike
- IpAddress, NotIpAddress
- DateEquals, DateNotEquals, DateLessThan, DateGreaterThan
- Bool (для булевых условий)
- NumericEquals, NumericLessThan, NumericGreaterThan

## 3. Роли и временные учетные данные (STS)

### 3.1 Управление ролями
- Создание и управление ролями через административный API[1]
- Каждая роль должна содержать:[1]
  - Уникальный идентификатор и имя роли
  - ARN в формате `arn:aws:iam:::role/<path>/<role-name>`
  - Политику доверия (AssumeRolePolicyDocument) в формате IAM Policy
  - Максимальную длительность сессии (max_session_duration)
  - Опциональный путь (path) для организационной иерархии
- Возможность присоединения inline-политик к ролям (permission policies)[1]
- Поддержка тегов для ролей (multivalued tags)[1]
- Возможность модификации и удаления ролей через административный API[5]

### 3.2 STS API операции
- **AssumeRole**: получение временных учетных данных для доступа от имени роли[5][1]
  - Параметры: RoleArn, RoleSessionName, DurationSeconds, Policy (optional)
  - Проверка разрешений как со стороны роли (trust policy), так и со стороны вызывающего пользователя
  - Возврат временных креденциалов: AccessKeyId, SecretAccessKey, SessionToken, Expiration
  
- **AssumeRoleWithWebIdentity**: получение временных учетных данных через OpenID Connect/OAuth2.0[5][1]
  - Поддержка федеративной аутентификации через внешние Identity Provider
  - Проверка JWT токенов (валидация подписи, issuer, audience)
  - Создание shadow-пользователей в отдельном namespace 'oidc'
  - Поддержка claims в условиях trust policy (sub, azp, aud, iss и др.)
  - Параметры: RoleArn, RoleSessionName, WebIdentityToken, DurationSeconds

### 3.3 Ограничения временных учетных данных
- Временные учетные данные могут быть дополнительно ограничены через параметр Policy в запросе AssumeRole[1]
- Эффективные права определяются пересечением (intersection) прав роли и переданной политики[1]
- Длительность сессии должна быть настраиваемой (с учетом max_session_duration роли)[1]
- Минимальная длительность сессии: 900 секунд (15 минут), максимальная: определяется max_session_duration роли[5]
- Временные креденциалы должны содержать session token для идентификации временной сессии[5]

## 4. Access Control Lists (ACL)

### 4.1 Уровни применения ACL
- Поддержка ACL на уровне бакетов[2][1]
- Поддержка ACL на уровне объектов[2][1]
- Каждый grant в ACL должен иметь различную семантику для бакетов и объектов[1]
- ACL устанавливается при создании ресурса или модифицируется через PutBucketAcl/PutObjectAcl[2]

### 4.2 Стандартные разрешения ACL
- **READ** - для бакетов: листинг объектов; для объектов: чтение содержимого и метаданных[2][1]
- **WRITE** - для бакетов: создание, перезапись и удаление объектов; для объектов: не применимо[2][1]
- **READ_ACP** - чтение ACL бакета или объекта[2][1]
- **WRITE_ACP** - изменение ACL бакета или объекта[2][1]
- **FULL_CONTROL** - все вышеперечисленные разрешения[2][1]

### 4.3 Grantee типы
- Конкретные пользователи (по UID или canonical user ID)[2][1]
- Пользователи по email адресу[2][1]
- Группы по URI:[2][1]
  - `http://acs.amazonaws.com/groups/global/AllUsers` - все пользователи (публичный доступ)
  - `http://acs.amazonaws.com/groups/global/AuthenticatedUsers` - все аутентифицированные пользователи

### 4.4 Предустановленные (Canned) ACL
Поддержка следующих предустановленных ACL при создании бакетов и объектов:[2]
- `private` - владелец получает FULL_CONTROL, остальные доступа не имеют
- `public-read` - владелец получает FULL_CONTROL, группа AllUsers получает READ
- `public-read-write` - владелец получает FULL_CONTROL, группа AllUsers получает READ и WRITE
- `authenticated-read` - владелец получает FULL_CONTROL, группа AuthenticatedUsers получает READ

## 5. Интеграция с внешними системами аутентификации

### 5.1 Keystone интеграция
- Service token support для проверки Keystone токенов[1]
- Автоматическое создание пользователей на основе Keystone-токенов (implicit users)[2][1]
- Возможность включения мультитенантности на основе Keystone проектов[1]
- Генерация EC2-совместимых ключей доступа для Keystone пользователей[2]
- Поддержка Keystone API v3 для получения токенов[2]

### 5.2 LDAP поддержка
- Возможность конфигурации LDAP URI для аутентификации[1]
- Интеграция с корпоративными директориями (Active Directory, OpenLDAP)[1]
- Поддержка LDAP bind для проверки учетных данных
- Возможность маппинга LDAP атрибутов на атрибуты пользователя объектного хранилища

### 5.3 OpenID Connect (OIDC)
- Поддержка аутентификации через OIDC провайдеров (Google, Azure AD, Keycloak и др.)[5][1]
- Проверка JWT токенов с валидацией подписи по публичным ключам провайдера[1]
- Создание временных пользователей (shadow users) в namespace 'oidc'[1]
- Поддержка конфигурации нескольких OIDC провайдеров одновременно[5]
- Маппинг OIDC claims на атрибуты пользователя и условия политик[5]

## 6. Мультитенантность через Placement Targets и Pool

### 6.1 Placement Targets (Цели размещения)
**Критически важно для мультитенантности**: Система должна обеспечивать изоляцию данных различных тенантов через механизм placement targets и pools.[1]

- Поддержка множественных placement targets в конфигурации zonegroup[6][1]
- Каждый placement target должен определять:[1]
  - Уникальный идентификатор размещения (placement-id)
  - Набор storage classes
  - Опциональные теги (tags) для контроля доступа
- Начальный placement target с именем "default-placement" должен создаваться автоматически[1]
- Placement targets определяются на уровне zonegroup и применяются ко всем зонам в группе[6]

### 6.2 Storage Classes (Классы хранения)
- Каждый placement target должен поддерживать множественные storage classes[6][1]
- Обязательный класс хранения "STANDARD" для каждого placement target[6][1]
- Возможность создания дополнительных классов: STANDARD_IA, GLACIER, REDUCED_REDUNDANCY и пользовательских[7][1]
- Каждый storage class сопоставляется с конкретными пулами хранения в zone конфигурации[6][1]
- Поддержка перехода объектов между storage classes через lifecycle policies[7]
- Указание storage class при загрузке объекта через заголовок `x-amz-storage-class`[7]

### 6.3 Mapping на пулы хранения (Pool Mapping)
Для обеспечения физической изоляции данных тенантов через пулы:[1]

- Zone конфигурация должна определять mapping placement targets на конкретные пулы:
  - `index_pool` - пул для индексов бакетов (содержит метаданные объектов)
  - `data_pool` - пул для данных объектов (для каждого storage class)
  - `data_extra_pool` - пул для метаданных незавершенных multipart uploads
  
- Примерная структура в zone:[1]
```json
"placement_pools": [{
  "key": "tenant-a-placement",
  "val": {
    "index_pool": "tenant-a.buckets.index",
    "storage_classes": {
      "STANDARD": {
        "data_pool": "tenant-a.buckets.data"
      },
      "GLACIER": {
        "data_pool": "tenant-a.buckets.archive"
      }
    },
    "data_extra_pool": "tenant-a.buckets.non-ec"
  }
}]
```

- Каждый пул может иметь собственную конфигурацию репликации или erasure coding[7]
- Поддержка различных типов пулов: replicated, erasure-coded[1]
- Возможность настройки compression на уровне пулов для экономии места[7][1]

### 6.4 Назначение placement targets пользователям
- Пользователь должен иметь возможность иметь default_placement в своем профиле[6][1]
- Placement target бакета выбирается при создании и не может быть изменен после создания[6][1]
- Пользователь может переопределить placement target при создании бакета через:[1]
  - LocationConstraint в S3 CreateBucket запросе
  - X-Storage-Policy заголовок в Swift PUT Container
- При отсутствии явного указания используется default_placement пользователя или zonegroup[6]

### 6.5 Контроль доступа через placement tags
**Ключевой механизм изоляции тенантов**:[1]
- Placement target может иметь набор тегов (tags)
- Пользователь может создать бакет с определенным placement target только если:
  - У placement target нет тегов (доступен всем), ИЛИ
  - placement_tags пользователя содержит хотя бы один совпадающий тег
- Это позволяет ограничить доступ определенных пользователей к определенным типам хранилища/тенантам

Пример изоляции тенантов:[1]
- Tenant A: пользователи имеют placement_tags: ["tenant-a"], могут создавать бакеты только в placement target "tenant-a-storage" с тегами ["tenant-a"]
- Tenant B: пользователи имеют placement_tags: ["tenant-b"], могут создавать бакеты только в placement target "tenant-b-storage" с тегами ["tenant-b"]
- При этом каждый placement target mapped на отдельные пулы, обеспечивая физическую изоляцию данных

### 6.6 Управление placement через административный API
- Операции добавления placement target в zonegroup[1]
- Операции добавления zone placement info с указанием пулов[1]
- Установка default placement для zonegroup[1]
- Изменение default_placement и placement_tags для пользователей через административные операции[1]
- Получение списка доступных placement targets и их конфигурации[6]

## 7. Квоты и ограничения

### 7.1 Квоты пользователей
- Возможность установки квот на максимальное количество объектов[8][1]
- Возможность установки квот на максимальный размер хранилища (в байтах или единицах измерения)[8][1]
- Квоты должны применяться на уровне пользователя и суммироваться по всем его бакетам[1]
- Возможность включения/отключения проверки квот для конкретного пользователя[8]

### 7.2 Квоты бакетов
- Возможность установки квот на уровне отдельных бакетов[8][1]
- Поддержка операций проверки использования квот через administrative API[8][1]
- Ограничение по количеству объектов в бакете[8]
- Ограничение по размеру данных в бакете[8]

### 7.3 Rate Limiting (Ограничение скорости)
- Поддержка ограничения скорости запросов на уровне пользователя[1]
- Поддержка ограничения скорости запросов на уровне бакета[1]
- Возможность раздельного ограничения READ и WRITE операций[1]
- Ограничения в единицах операций/минуту и байт/минуту[1]
- Возможность установки burst limits для кратковременных всплесков нагрузки

### 7.4 Управление квотами
- API для установки, изменения и удаления квот[8]
- API для получения текущего использования ресурсов относительно квот[8]
- Возможность установки "мягких" предупреждающих лимитов и "жестких" блокирующих лимитов
- Системные пользователи не должны подлежать квотам[1]

## 8. Административные возможности

### 8.1 Capabilities (Административные права)
- Система capabilities для предоставления административных прав пользователям[1]
- Основные категории capabilities:[1]
  - `users` - управление пользователями (создание, модификация, удаление)
  - `buckets` - управление бакетами (создание, удаление, изменение параметров)
  - `metadata` - управление метаданными пользователей и бакетов
  - `usage` - просмотр статистики использования ресурсов
  - `zone` - управление зонами и zonegroups
  - `roles` - управление IAM ролями
  - `info` - просмотр информации о конфигурации системы
- Уровни доступа для каждой категории: `read`, `write`, или `*` (полный доступ)[1]
- Возможность назначения множественных capabilities одному пользователю

### 8.2 Системные пользователи
- Возможность создания пользователей с флагом `system`[1]
- Системные пользователи не подлежат квотам[1]
- Системные пользователи могут иметь особые права административного доступа[1]
- Системные пользователи могут использовать административный API без дополнительных capabilities

### 8.3 Игнорирование ошибок политик
- Admin и system пользователи должны игнорировать ошибки парсинга IAM политик[1]
- Это обеспечивает работоспособность административных операций даже при некорректных политиках[1]
- Возможность принудительного выполнения операций с игнорированием policy-based access control

### 8.4 Административный API
- RESTful API для управления пользователями: создание, модификация, удаление, получение информации[8]
- API для управления бакетами: листинг, получение информации, удаление, unlink от пользователя[8]
- API для управления ключами доступа: создание, удаление, модификация[8]
- API для управления capabilities: добавление, удаление[8]
- API для управления квотами: установка, получение статистики использования[8]
- API для получения usage statistics: bandwidth, операции, хранилище[8]

## 9. Безопасность и аудит

### 9.1 Аутентификация
- Поддержка AWS Signature Version 4 для подписи запросов[2][1]
- Поддержка AWS Signature Version 2 для обратной совместимости[2]
- Валидация x-amz-content-sha256 для пустых и непустых payload[1]
- Игнорирование проверки подписи для HTTP OPTIONS запросов (CORS preflight)[1]
- Поддержка временных учетных данных из STS с валидацией session token[1]
- Поддержка presigned URLs для временного доступа без передачи credentials[2]

### 9.2 Шифрование
- Политики IAM должны поддерживать проверку encryption attributes для PostObject и Multipart операций[1]
- Возможность установки default encryption key через конфигурацию[1]
- Возможность принудительного требования шифрования через bucket policies

### 9.3 Контроль доступа к административным операциям
- Административные операции должны требовать наличия соответствующих capabilities[1]
- Возможность аудита административных действий с указанием субъекта, времени и результата
- Защита от несанкционированного доступа к административному API через механизмы аутентификации

## 10. Совместимость с S3 API

### 10.1 Bucket операции
- **CreateBucket** с поддержкой LocationConstraint для выбора placement target[6][1]
- **DeleteBucket** с проверкой прав и условием пустого бакета[1]
- **ListBuckets** с возвратом списка бакетов, доступных пользователю[1]
- **HeadBucket** для проверки существования и доступа к бакету[1]
- **GetBucketLocation** для получения информации о регионе/placement[1]
- **GetBucketVersioning / PutBucketVersioning** для управления версионированием[1]
- **GetBucketPolicy / PutBucketPolicy / DeleteBucketPolicy** для управления политиками[1]
- **GetBucketAcl / PutBucketAcl** для управления ACL[2]
- **GetBucketCors / PutBucketCors / DeleteBucketCors** для настройки CORS[2]

### 10.2 Object операции
- **PutObject** с поддержкой storage class header[7][1]
- **GetObject** с поддержкой range requests[1]
- **DeleteObject** с опциональной поддержкой версионирования[1]
- **CopyObject** для копирования объектов между бакетами[1]
- **HeadObject** для получения метаданных объекта[1]
- **ListObjects / ListObjectsV2** с корректным возвратом владельцев объектов[1]
- **Multipart Upload операции**: InitiateMultipartUpload, UploadPart, CompleteMultipartUpload, AbortMultipartUpload, ListParts[1]
- **GetObjectAcl / PutObjectAcl** для управления ACL объектов[2]

### 10.3 Bucket Lifecycle
- Поддержка правил перехода объектов между storage classes[7][1]
- Автоматизация перемещения объектов на основе возраста и правил[1]
- Поддержка правил удаления (expiration) объектов и версий[7]
- PutBucketLifecycleConfiguration / GetBucketLifecycleConfiguration / DeleteBucketLifecycleConfiguration API[7]
- Поддержка фильтров по префиксам и тегам в lifecycle rules

### 10.4 Versioning
- Поддержка версионирования объектов в бакете[1]
- Возможность включения/отключения/приостановки версионирования через PutBucketVersioning[1]
- Операции с конкретными версиями объектов: GetObjectVersion, DeleteObjectVersion[1]
- ListObjectVersions для получения всех версий объектов[1]
- Поддержка version-id в операциях GetObject, HeadObject, DeleteObject

***

**Примечание**: Все функциональные возможности должны соответствовать уровню зрелости и стабильности, достигнутому в референсном решении на момент версии 17.2.7 (Quincy), без включения функциональности, появившейся в более поздних версиях.[1]

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/154680809/17f50a40-284e-4815-bd49-3eb341156955/claude-1.md)
[2](https://docs.ceph.com/en/latest/radosgw/s3/authentication/)
[3](https://docs.ceph.com/en/reef/radosgw/multitenancy/)
[4](https://docs.ceph.com/en/quincy/radosgw/bucketpolicy/)
[5](https://community.ibm.com/community/user/storage/blogs/daniel-alexander-parkes/2024/03/09/ceph-object-iam-sts-abac)
[6](https://docs.ceph.com/en/latest/radosgw/placement/)
[7](https://www.croit.io/blog/optimize-storage-allocation-with-ceph-s3)
[8](https://docs.ceph.com/en/quincy/radosgw/admin/)