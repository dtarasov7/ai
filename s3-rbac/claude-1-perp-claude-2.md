# Требования к функциональным возможностям подсистемы RBAC объектного хранилища S3

## 1. Управление пользователями и учетными записями

### 1.1 Модель пользователей
- Поддержка создания пользователей с уникальными идентификаторами (UID)
- Возможность назначения отображаемого имени (display name) для каждого пользователя
- Генерация и управление парами ключей доступа (access key / secret key) для аутентификации S3
- Поддержка множественных пар ключей доступа для одного пользователя с возможностью ротации
- Поддержка создания подпользователей (subusers) с собственными ключами для протокола Swift
- Возможность создания системных (system) и административных (admin) пользователей с расширенными правами
- Поддержка установки email адреса для пользователя (опционально)

### 1.2 Мультитенантность
- Поддержка изоляции пользователей и ресурсов на уровне тенантов (tenant)
- Возможность создания пользователей в контексте конкретного тенанта с синтаксисом `<tenant>$<user>`
- Поддержка операций с бакетами через синтаксис `<tenant>:<bucket>` для доступа к ресурсам других тенантов
- Каждый тенант должен иметь собственное пространство имен для бакетов, что позволяет использовать одинаковые имена бакетов в разных тенантах
- Поддержка неявного тенанта (legacy tenant) с пустым именем для обратной совместимости
- Возможность явного указания тенанта в S3 API через заголовок или параметр запроса

## 2. Политики управления доступом

### 2.1 Bucket Policies (Политики бакетов)
- Поддержка политик на уровне бакетов в формате AWS IAM Policy (JSON)
- Версия политик: "2012-10-17"
- Структура политики должна включать:
  - `Version` - версия формата политики
  - `Statement` - массив правил с элементами:
    - `Effect`: "Allow" или "Deny"
    - `Principal`: идентификация субъектов через ARN формата `arn:aws:iam:::user/<username>` или wildcard "*"
    - `Action`: список разрешенных/запрещенных операций S3
    - `Resource`: целевые ресурсы в формате `arn:aws:s3:::<bucket>` и `arn:aws:s3:::<bucket>/*`
    - `Condition`: опциональные условия применения правила
- Управление политиками через стандартные S3 API операции: PutBucketPolicy, GetBucketPolicy, DeleteBucketPolicy

### 2.2 Поддерживаемые S3 Actions
Система должна поддерживать следующие операции S3 в политиках:
- **Bucket operations**: s3:CreateBucket, s3:DeleteBucket, s3:ListBucket, s3:ListBucketVersions, s3:ListBucketMultipartUploads, s3:GetBucketLocation
- **Object operations**: s3:GetObject, s3:PutObject, s3:DeleteObject, s3:GetObjectVersion, s3:DeleteObjectVersion
- **ACL operations**: s3:GetObjectAcl, s3:PutObjectAcl, s3:GetBucketAcl, s3:PutBucketAcl
- **Multipart operations**: s3:ListMultipartUploadParts, s3:AbortMultipartUpload
- **Versioning**: s3:GetBucketVersioning, s3:PutBucketVersioning
- **Policy operations**: s3:GetBucketPolicy, s3:PutBucketPolicy, s3:DeleteBucketPolicy

### 2.3 Условные ключи (Condition Keys)
Поддержка следующих ключей условий для политик:
- `aws:CurrentTime` - текущее время запроса
- `aws:EpochTime` - время в формате Unix timestamp
- `aws:PrincipalType` - тип субъекта запроса
- `aws:Referer` - HTTP referer заголовок
- `aws:SecureTransport` - использование HTTPS (булево значение)
- `aws:SourceIp` - IP-адрес источника запроса
- `aws:UserAgent` - User-Agent клиента
- `aws:username` - имя пользователя
- `s3:x-amz-acl` - предустановленные ACL при создании объектов
- `s3:prefix` - префикс для операций листинга
- `s3:delimiter` - разделитель для операций листинга

### 2.4 Операторы условий
Поддержка следующих операторов для Condition блоков в политиках:
- StringEquals, StringNotEquals
- StringLike, StringNotLike
- IpAddress, NotIpAddress
- DateEquals, DateNotEquals, DateLessThan, DateGreaterThan
- Bool (для булевых условий)
- NumericEquals, NumericLessThan, NumericGreaterThan

## 3. Роли и временные учетные данные (STS)

### 3.1 Управление ролями
- Создание и управление ролями через административный API
- Каждая роль должна содержать:
  - Уникальный идентификатор и имя роли
  - ARN в формате `arn:aws:iam:::role/<path>/<role-name>`
  - Политику доверия (AssumeRolePolicyDocument) в формате IAM Policy
  - Максимальную длительность сессии (max_session_duration)
  - Опциональный путь (path) для организационной иерархии
- Возможность присоединения inline-политик к ролям (permission policies)
- Поддержка тегов для ролей (multivalued tags)
- Возможность модификации и удаления ролей через административный API

### 3.2 STS API операции
- **AssumeRole**: получение временных учетных данных для доступа от имени роли
  - Параметры: RoleArn, RoleSessionName, DurationSeconds, Policy (optional)
  - Проверка разрешений как со стороны роли (trust policy), так и со стороны вызывающего пользователя
  - Возврат временных креденциалов: AccessKeyId, SecretAccessKey, SessionToken, Expiration
  
- **AssumeRoleWithWebIdentity**: получение временных учетных данных через OpenID Connect/OAuth2.0
  - Поддержка федеративной аутентификации через внешние Identity Provider
  - Проверка JWT токенов (валидация подписи, issuer, audience)
  - Создание shadow-пользователей в отдельном namespace 'oidc'
  - Поддержка claims в условиях trust policy (sub, azp, aud, iss и др.)
  - Параметры: RoleArn, RoleSessionName, WebIdentityToken, DurationSeconds

### 3.3 Ограничения временных учетных данных
- Временные учетные данные могут быть дополнительно ограничены через параметр Policy в запросе AssumeRole
- Эффективные права определяются пересечением (intersection) прав роли и переданной политики
- Длительность сессии должна быть настраиваемой (с учетом max_session_duration роли)
- Минимальная длительность сессии: 900 секунд (15 минут), максимальная: определяется max_session_duration роли
- Временные креденциалы должны содержать session token для идентификации временной сессии

## 4. Access Control Lists (ACL)

### 4.1 Уровни применения ACL
- Поддержка ACL на уровне бакетов
- Поддержка ACL на уровне объектов
- Каждый grant в ACL должен иметь различную семантику для бакетов и объектов
- ACL устанавливается при создании ресурса или модифицируется через PutBucketAcl/PutObjectAcl

### 4.2 Стандартные разрешения ACL
- **READ** - для бакетов: листинг объектов; для объектов: чтение содержимого и метаданных
- **WRITE** - для бакетов: создание, перезапись и удаление объектов; для объектов: не применимо
- **READ_ACP** - чтение ACL бакета или объекта
- **WRITE_ACP** - изменение ACL бакета или объекта
- **FULL_CONTROL** - все вышеперечисленные разрешения

### 4.3 Grantee типы
- Конкретные пользователи (по UID или canonical user ID)
- Пользователи по email адресу
- Группы по URI:
  - `http://acs.amazonaws.com/groups/global/AllUsers` - все пользователи (публичный доступ)
  - `http://acs.amazonaws.com/groups/global/AuthenticatedUsers` - все аутентифицированные пользователи

### 4.4 Предустановленные (Canned) ACL
Поддержка следующих предустановленных ACL при создании бакетов и объектов:
- `private` - владелец получает FULL_CONTROL, остальные доступа не имеют
- `public-read` - владелец получает FULL_CONTROL, группа AllUsers получает READ
- `public-read-write` - владелец получает FULL_CONTROL, группа AllUsers получает READ и WRITE
- `authenticated-read` - владелец получает FULL_CONTROL, группа AuthenticatedUsers получает READ

## 5. Мультитенантность через Placement Targets и Pool

### 5.1 Placement Targets (Цели размещения)
**Критически важно для мультитенантности**: Система должна обеспечивать изоляцию данных различных тенантов через механизм placement targets и pools.

- Поддержка множественных placement targets в конфигурации zonegroup
- Каждый placement target должен определять:
  - Уникальный идентификатор размещения (placement-id)
  - Набор storage classes
  - Опциональные теги (tags) для контроля доступа
- Начальный placement target с именем "default-placement" должен создаваться автоматически
- Placement targets определяются на уровне zonegroup и применяются ко всем зонам в группе

### 5.2 Storage Classes (Классы хранения)
- Каждый placement target должен поддерживать множественные storage classes
- Обязательный класс хранения "STANDARD" для каждого placement target
- Возможность создания дополнительных классов: STANDARD_IA, GLACIER, REDUCED_REDUNDANCY и пользовательских
- Каждый storage class сопоставляется с конкретными пулами хранения в zone конфигурации

### 5.3 Mapping на пулы хранения (Pool Mapping)
Для обеспечения физической изоляции данных тенантов через пулы:

- Zone конфигурация должна определять mapping placement targets на конкретные пулы:
  - `index_pool` - пул для индексов бакетов (содержит метаданные объектов)
  - `data_pool` - пул для данных объектов (для каждого storage class)
  - `data_extra_pool` - пул для метаданных незавершенных multipart uploads
  
- Примерная структура в zone:
```json
"placement_pools": [{
  "key": "tenant-a-placement",
  "val": {
    "index_pool": "tenant-a.buckets.index",
    "storage_classes": {
      "STANDARD": {
        "data_pool": "tenant-a.buckets.data"
      },
      "GLACIER": {
        "data_pool": "tenant-a.buckets.archive"
      }
    },
    "data_extra_pool": "tenant-a.buckets.non-ec"
  }
}]
```

- Каждый пул может иметь собственную конфигурацию репликации или erasure coding
- Поддержка различных типов пулов: replicated, erasure-coded

### 5.4 Назначение placement targets пользователям
- Пользователь должен иметь возможность иметь default_placement в своем профиле
- Placement target бакета выбирается при создании и не может быть изменен после создания
- Пользователь может переопределить placement target при создании бакета через:
  - LocationConstraint в S3 CreateBucket запросе
  - X-Storage-Policy заголовок в Swift PUT Container
- При отсутствии явного указания используется default_placement пользователя или zonegroup

### 5.5 Контроль доступа через placement tags
**Ключевой механизм изоляции тенантов**:
- Placement target может иметь набор тегов (tags)
- Пользователь может создать бакет с определенным placement target только если:
  - У placement target нет тегов (доступен всем), ИЛИ
  - placement_tags пользователя содержит хотя бы один совпадающий тег
- Это позволяет ограничить доступ определенных пользователей к определенным типам хранилища/тенантам

Пример изоляции тенантов:
- Tenant A: пользователи имеют placement_tags: ["tenant-a"], могут создавать бакеты только в placement target "tenant-a-storage" с тегами ["tenant-a"]
- Tenant B: пользователи имеют placement_tags: ["tenant-b"], могут создавать бакеты только в placement target "tenant-b-storage" с тегами ["tenant-b"]
- При этом каждый placement target mapped на отдельные пулы, обеспечивая физическую изоляцию данных

### 5.6 Управление placement через административный API
- Операции добавления placement target в zonegroup
- Операции добавления zone placement info с указанием пулов
- Установка default placement для zonegroup
- Изменение default_placement и placement_tags для пользователей через административные операции
- Получение списка доступных placement targets и их конфигурации

## 6. Квоты и ограничения

### 6.1 Квоты пользователей
- Возможность установки квот на максимальное количество объектов
- Возможность установки квот на максимальный размер хранилища (в байтах или единицах измерения)
- Квоты должны применяться на уровне пользователя и суммироваться по всем его бакетам
- Возможность включения/отключения проверки квот для конкретного пользователя

### 6.2 Квоты бакетов
- Возможность установки квот на уровне отдельных бакетов
- Поддержка операций проверки использования квот через administrative API
- Ограничение по количеству объектов в бакете
- Ограничение по размеру данных в бакете

### 6.3 Rate Limiting (Ограничение скорости)
- Поддержка ограничения скорости запросов на уровне пользователя
- Поддержка ограничения скорости запросов на уровне бакета
- Возможность раздельного ограничения READ и WRITE операций
- Ограничения в единицах операций/минуту и байт/минуту
- Возможность установки burst limits для кратковременных всплесков нагрузки

### 6.4 Управление квотами
- API для установки, изменения и удаления квот
- API для получения текущего использования ресурсов относительно квот
- Возможность установки "мягких" предупреждающих лимитов и "жестких" блокирующих лимитов
- Системные пользователи не должны подлежать квотам

## 7. Административные возможности

### 7.1 Capabilities (Административные права)
- Система capabilities для предоставления административных прав пользователям
- Основные категории capabilities:
  - `users` - управление пользователями (создание, модификация, удаление)
  - `buckets` - управление бакетами (создание, удаление, изменение параметров)
  - `metadata` - управление метаданными пользователей и бакетов
  - `usage` - просмотр статистики использования ресурсов
  - `zone` - управление зонами и zonegroups
  - `roles` - управление IAM ролями
  - `info` - просмотр информации о конфигурации системы
- Уровни доступа для каждой категории: `read`, `write`, или `*` (полный доступ)
- Возможность назначения множественных capabilities одному пользователю

### 7.2 Системные пользователи
- Возможность создания пользователей с флагом `system`
- Системные пользователи не подлежат квотам
- Системные пользователи могут иметь особые права административного доступа
- Системные пользователи могут использовать административный API без дополнительных capabilities

### 7.3 Игнорирование ошибок политик
- Admin и system пользователи должны игнорировать ошибки парсинга IAM политик
- Это обеспечивает работоспособность административных операций даже при некорректных политиках
- Возможность принудительного выполнения операций с игнорированием policy-based access control

### 7.4 Административный API
- RESTful API для управления пользователями: создание, модификация, удаление, получение информации
- API для управления бакетами: листинг, получение информации, удаление, unlink от пользователя
- API для управления ключами доступа: создание, удаление, модификация
- API для управления capabilities: добавление, удаление
- API для управления квотами: установка, получение статистики использования
- API для получения usage statistics: bandwidth, операции, хранилище

***

**Примечание**: Все функциональные возможности должны соответствовать уровню зрелости и стабильности, достигнутому в референсном решении на момент версии 17.2.7 (Quincy), без включения функциональности, появившейся в более поздних версиях.[1]

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/154680809/17f50a40-284e-4815-bd49-3eb341156955/claude-1.md)
