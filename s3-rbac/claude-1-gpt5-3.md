Ниже — тот же набор требований в «закупочном» формате (R-001…), с критериями приёмки и проверками через конкретные S3/STS вызовы, без привязки к конкретной реализации.[1][2][3][4][5][6][7]

## Аутентификация и субъекты

### R-001. Аутентификация S3 по ключам
**Требование:** Система должна поддерживать аутентификацию S3-запросов по AWS Signature (access key / secret key) для защищённых операций S3 API.[7][1]
**Критерии приёмки:** Запросы, подписанные корректной парой ключей, успешно выполняются; запросы с некорректной подписью отклоняются.[1]
**Проверка (пример):**
- Создать пользователя/ключи доступа.
- Выполнить `aws s3api list-buckets` с корректными ключами — ожидается успех.
- Выполнить тот же вызов с подменой secret key — ожидается отказ в доступе.

### R-002. Анонимный субъект и правила доступа
**Требование:** Система должна обрабатывать неаутентифицированные запросы как запросы анонимного субъекта и применять к ним ACL/policy-правила.[1]
**Критерии приёмки:** Без ключей доступа операции разрешаются только если это разрешено ACL/bucket policy; иначе — отклоняются.[2][1]
**Проверка (пример):**
- Создать бакет без “public” ACL/policy, выполнить `aws s3api list-objects-v2 --bucket <bucket> --no-sign-request` — ожидается отказ.
- Разрешить чтение через ACL или bucket policy и повторить `--no-sign-request` — ожидается успех для разрешённых операций.[2][1]

### R-003. Опциональная интеграция с внешней идентификацией
**Требование (опционально):** При необходимости интеграции с внешним IAM/Keystone-совместимым сервисом система должна поддерживать выпуск/использование AWS‑style ключей для S3 API.[7][1]
**Критерии приёмки:** Пользователь, аутентифицированный во внешней системе, получает действующие S3-ключи и выполняет операции S3 согласно правам.[7][1]
**Проверка (пример):**
- Получить S3-ключи через внешний сервис.
- Выполнить `aws s3api head-bucket --bucket <bucket>` — ожидается результат в соответствии с назначенными правами.

## ACL и bucket policy

### R-004. S3 ACL для бакетов и объектов
**Требование:** Система должна поддерживать S3 ACL для бакетов и объектов с правами READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL.[1][7]
**Критерии приёмки:** Изменение ACL влияет на доступ ровно в пределах указанных прав (например, READ_ACP даёт чтение ACL, но не чтение объекта).[1]
**Проверка (пример):**
- `aws s3api put-bucket-acl ...`, затем `aws s3api get-bucket-acl ...`.
- Аналогично для объекта: `put-object-acl` / `get-object-acl`.
- Проверить доступ вторым пользователем в соответствии с выданными правами.

### R-005. Canned ACL
**Требование:** Система должна поддерживать canned ACL и применение canned ACL при создании/изменении бакета и объекта.[7][1]
**Критерии приёмки:** Установка canned ACL приводит к ожидаемому набору грантов в `GetBucketAcl/GetObjectAcl`.[1]
**Проверка (пример):**
- Создать бакет/объект с `--acl public-read` (или иным canned ACL).
- Вызвать `aws s3api get-bucket-acl` / `get-object-acl` и сверить ожидаемые grants.

### R-006. Управление bucket policy через S3 API
**Требование:** Система должна поддерживать bucket policy и операции PutBucketPolicy / GetBucketPolicy / DeleteBucketPolicy.[2]
**Критерии приёмки:** Политика успешно устанавливается, читается и удаляется через S3 API; после удаления доступ определяется только ACL/прочими правилами.[2][1]
**Проверка (пример):**
- `aws s3api put-bucket-policy --bucket <bucket> --policy file://policy.json`
- `aws s3api get-bucket-policy --bucket <bucket>`
- `aws s3api delete-bucket-policy --bucket <bucket>`

### R-007. Состав bucket policy (минимум)
**Требование:** Bucket policy должна поддерживать минимум следующие элементы: `Version`, `Statement`, `Effect` (Allow/Deny), `Principal`, `Action`, `Resource`, `Condition`.[2][7]
**Критерии приёмки:** Политики с указанными элементами применяются; некорректно сформированные политики отклоняются с ошибкой валидации.[2]
**Проверка (пример):**
- Загрузить валидную политику с Allow/Deny и проверить поведение.
- Попробовать загрузить policy без `Statement` или с некорректным JSON — ожидается ошибка.

### R-008. Поддерживаемые ключи условий (Condition keys)
**Требование:** В `Condition` должны поддерживаться ключи: aws:CurrentTime, aws:EpochTime, aws:PrincipalType, aws:Referer, aws:SecureTransport, aws:SourceIp, aws:UserAgent, aws:username.[7][2]
**Критерии приёмки:** Для каждого ключа условие реально влияет на авторизацию (разрешает/запрещает) в соответствии с policy.[2]
**Проверка (пример):**
- aws:SecureTransport: запретить `s3:GetObject` при HTTP и разрешить при HTTPS; проверить двумя запросами.[2]
- aws:SourceIp: разрешить чтение только из одной подсети; проверить с разрешённого/запрещённого адреса.[2]

### R-009. Отсутствие string interpolation в policy
**Требование:** String interpolation в bucket policy не требуется и не должна считаться обязательной функциональностью; политика, использующая интерполяцию, должна отклоняться либо трактоваться как неподдерживаемая.[2]
**Критерии приёмки:** Политики без интерполяции применяются; попытка применить policy с интерполяцией не приводит к “тихому” расширению прав.[2]
**Проверка (пример):**
- Загрузить policy с интерполяцией (в тестовом виде) и убедиться, что она не даёт доступ и возвращает явную ошибку/неподдерживаемость.

## Роли и STS (временные учётные данные)

### R-010. Сущность роли: trust + permission policy
**Требование:** Система должна поддерживать роль, включающую trust policy (кто может принять роль) и permission policy (какие действия разрешены после принятия роли).[3][7]
**Критерии приёмки:** Пользователь, не указанный в trust policy, не может принять роль; пользователь, указанный в trust policy, получает права только в пределах permission policy.[3]
**Проверка (пример):**
- Создать роль с trust policy, разрешающей AssumeRole только конкретному пользователю.
- Попытаться принять роль другим пользователем — ожидается отказ.
- Принять роль разрешённым пользователем — ожидается успех.

### R-011. STS: AssumeRole
**Требование:** Система должна поддерживать STS-операцию AssumeRole с выдачей временных учётных данных для S3.[4][7]
**Критерии приёмки:** Временные ключи работают до истечения срока; по истечении — отклоняются.[4]
**Проверка (пример):**
- Вызвать STS AssumeRole, получить временные креды.
- Выполнить S3-операцию (например, `head-bucket`) с временными кредами — ожидается успех.
- Дождаться истечения/принудительно установить короткий срок и повторить — ожидается отказ.

### R-012. STS: AssumeRoleWithWebIdentity
**Требование:** Система должна поддерживать STS-операцию AssumeRoleWithWebIdentity для федеративного входа через OIDC/OAuth2‑совместимого провайдера и выдачи временных кредов.[4][7]
**Критерии приёмки:** При валидном web identity токене выдаются временные креды, и они подчиняются permission policy роли.[4]
**Проверка (пример):**
- Получить JWT у OIDC провайдера.
- Выполнить AssumeRoleWithWebIdentity и затем S3-вызов с временными кредами.

### R-013. Параметры STS и ограничения сессии
**Требование:** STS должен поддерживать DurationSeconds (по умолчанию 3600 секунд) и максимальную длительность сессии на уровне роли (max session duration).[3][4][7]
**Критерии приёмки:** При запросе DurationSeconds больше максимума применяется ограничение; по умолчанию устанавливается 3600, если параметр не задан.[3][4]
**Проверка (пример):**
- Установить max session duration роли на малое значение.
- Запросить AssumeRole с DurationSeconds больше максимума и проверить фактический срок действия.

### R-014. Дополнительное сужение прав при выдаче токена
**Требование:** В STS-вызове AssumeRole должна поддерживаться опциональная ограничивающая Policy (для дополнительного сужения прав сессии относительно permission policy роли).[4][7]
**Критерии приёмки:** Сессия не может получить прав больше, чем у роли, и может получить меньше согласно переданной Policy.[4]
**Проверка (пример):**
- У роли разрешить `s3:GetObject` и `s3:PutObject`.
- При AssumeRole передать Policy, оставляющую только `s3:GetObject`.
- Проверить: чтение разрешено, запись запрещена.

### R-015. Не требовать более поздние расширения STS
**Требование:** Поддержка расширений STS уровня ABAC/session tags не должна быть обязательной (их отсутствие не считается несоответствием RBAC).[8]
**Критерии приёмки:** Все проверки R-010…R-014 проходят без необходимости использовать session tags.[8]
**Проверка:** Не использовать session tags в тестах приёмки; убедиться, что функциональность ролей/STS сохраняется.

## Мультитенантность через placement и разделение по пулам

### R-016. Логическая мультитенантность (tenant)
**Требование:** Система должна поддерживать tenant как изолирующую сущность, позволяющую иметь одинаковые имена пользователей/бакетов в разных tenant без конфликтов.[6][7]
**Критерии приёмки:** Создание `bucketA` в tenant1 и `bucketA` в tenant2 возможно и не приводит к пересечению данных/прав.[6]
**Проверка (пример):**
- Создать два tenant, в каждом создать бакет с одинаковым именем (в рамках модели адресации tenant).
- Заполнить разными объектами и убедиться, что листинги/доступ не пересекаются.

### R-017. Явная адресация tenant:bucket
**Требование:** Система должна поддерживать обращение к бакету другого tenant в формате `tenant:bucket` (path-style).[6][7]
**Критерии приёмки:** При корректных правах запросы к `tenant:bucket` выполняются; при отсутствии прав — отклоняются.[6]
**Проверка (пример):**
- Выполнить `aws s3api head-bucket --bucket tenant1:bucketA` соответствующими ключами и проверить результат.

### R-018. Placement-цели фиксируются при создании бакета
**Требование:** Система должна поддерживать placement‑цели; выбранная placement‑цель закрепляется при создании бакета и не может быть изменена для существующего бакета.[5][7]
**Критерии приёмки:** Попытка “переназначить” placement бакета административно или через S3 API отклоняется либо отсутствует как операция.[5]
**Проверка (пример):**
- Создать бакет с placement A.
- Попытаться изменить placement на B (если интерфейс существует) — ожидается отказ/невозможность.

### R-019. Изоляция по пулам (index/data/data-extra)
**Требование:** Для каждой placement‑цели система должна обеспечивать разнесение данных минимум по пулам: index pool (индекс бакета), data pool (данные объектов, в т.ч. по storage class), data extra pool (служебные данные multipart).[5][7]
**Критерии приёмки:** Для разных tenant/placement данные и метаданные размещаются в соответствующих пулах, обеспечивая изоляцию на уровне пулов.[5]
**Проверка (пример):**
- Создать два placement (tenantA и tenantB) с разными пулами.
- Создать бакеты/объекты и проверить (административными средствами поставщика), что задействованы ожидаемые пулы для индекса/данных/multipart.[5]

### R-020. Ограничение доступных placement через теги
**Требование:** Система должна поддерживать ограничение выбора placement‑целей через tags у placement‑целей и placement_tags у пользователя/tenant; создание бакета допускается только при пересечении тегов.[5][7]
**Критерии приёмки:** Пользователь/tenant без требуемого placement_tag не может создать бакет в placement‑цели, помеченной соответствующим tag.[5]
**Проверка (пример):**
- Назначить placement target tag = `tenant-a`.
- Пользователь без `tenant-a` пытается создать бакет в этом placement — ожидается отказ.
- Пользователь с `tenant-a` создаёт — ожидается успех.

### R-021. Выбор placement при CreateBucket
**Требование:** Система должна поддерживать выбор placement‑цели при создании бакета через S3 LocationConstraint в формате `<region_api_name>:<placement-id>`.[7][5]
**Критерии приёмки:** Бакет создаётся в указанной placement‑цели; при указании несуществующей/недоступной placement‑цели запрос отклоняется.[5]
**Проверка (пример):**
- `aws s3api create-bucket --bucket <b> --create-bucket-configuration LocationConstraint=<region>:<placement-id>`
- Проверить, что бакет привязан к нужной placement (административной проверкой).[5]

## Администрирование и границы ответственности

### R-022. Административные интерфейсы управления RBAC
**Требование:** Система должна предоставлять административный API и/или CLI для управления ролями, их trust/permission policies и параметрами placement (цели, теги, сопоставления с пулами).[3][7][5]
**Критерии приёмки:** Полный жизненный цикл ролей (create/get/list/delete, update trust policy, attach/detach permission policy) и управление placement выполняются без ручного редактирования внутренних данных системы.[3][7][5]
**Проверка (пример):**
- Создать роль, обновить trust policy, задать permission policy, удалить policy и роль.
- Создать placement, настроить mapping на пулы, назначить tags, назначить placement_tags пользователю/tenant.

### R-023. Разделение административных и пользовательских полномочий
**Требование:** Система должна поддерживать раздельные административные полномочия на управление RBAC/placement и пользовательские права доступа к данным через S3, чтобы администрирование можно было делегировать независимо от доступа к данным.[7]
**Критерии приёмки:** Пользователь без административных полномочий не может создавать/изменять роли или placement‑цели, даже если имеет доступ к данным бакета.[7]
**Проверка (пример):**
- Пользователем “data-user” попытаться создать роль/placement — отказ.
- Тем же пользователем выполнить разрешённые S3 операции — успех.

Если нужно, этот же документ можно дополнить “матрицей трассируемости” (требование → тест-кейс → ожидаемый результат) и минимальным набором JSON-шаблонов для bucket policy и trust/permission policy (без включения новых возможностей).

[1](https://docs.ceph.com/en/latest/radosgw/s3/authentication/)
[2](https://docs.ceph.com/en/quincy/radosgw/bucketpolicy/)
[3](https://docs.ceph.com/en/quincy/radosgw/role/)
[4](https://docs.ceph.com/en/quincy/radosgw/STS/)
[5](https://docs.ceph.com/en/latest/radosgw/placement/)
[6](https://docs.ceph.com/en/squid/radosgw/multitenancy/)
[7](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/154680809/30227eab-a7e2-4f17-b992-0e71358844ee/claude-1.md)
[8](https://docs.ceph.com/en/reef/radosgw/session-tags/)
[9](https://ceph.io/en/news/blog/2024/v19-2-0-squid-released/)