Для реализации вашей задачи в **Grafana 10** и **Prometheus 2.31**, мы должны объединить несколько метрик, чтобы определить:

- Какие сервисы должны быть запущены (активны в `systemd`).
- На каком хосте они работают.
- Какие из них не отдают метрику `uptime` (то есть не доступны или сломаны).

---

## 🧩 Что у нас есть

### Метрики:
- `node_systemd_unit_state{name="<service>.service", state="active"}` — говорит о том, что сервис активен в systemd.
- `instance` — это метка, которая указывает на сервер (хост), с которого собирается метрика.
- `service` — метка в метрике `uptime`, содержит имя сервиса.
- `uptime{service="<name>"}` — показывает, что сервис доступен и работает.

---

## ✅ Цель

Показать таблицу следующего вида:

| Instance        | Service Name     |
|------------------|------------------|
| server-01:9090   | my-service       |
| server-02:9100   | another-service  |

То есть — список **сервисов, которые должны быть запущены (в systemd)**, но **не отдают метрику uptime**.

---

## 🔧 PromQL запрос

```promql
# Получаем все активные systemd юниты с именем service.service
node_systemd_unit_state{state="active", name=~".*\\.service"}
  # Оставляем только те, где нет uptime метрики для соответствующего имени сервиса
unless by (instance, name)
(
  # Берём любую метрику с меткой service, чтобы проверить, доступен ли он
  count() by (instance, service)
  # Можно использовать uptime или up (от экспортера)
  (uptime or up{job!~"prometheus|node"}) > 0
)
```

> Здесь:
> - Мы фильтруем только активные systemd-юниты.
> - Используем `unless by (instance, name)` чтобы исключить сервисы, по которым Prometheus получил какие-либо метрики (`uptime` или `up`).
> - Это позволяет понять, что сервис **должен работать**, но **не отвечает**.

---

## 📊 Настройка панели Table в Grafana

1. Создайте новую панель типа **Table**.
2. В поле запроса Prometheus вставьте вышеуказанный PromQL.
3. Перейдите на вкладку **Transform**.
4. Добавьте преобразование:
   - **Labels to fields**
5. Переименуйте столбцы:
   - `name` → `Service Name`
   - `instance` → `Instance`
6. Удалите лишние столбцы (например, `device`, `fstype`, `mountpoint` и т.п., если они попали случайно).
7. При желании добавьте цветовые стили или фильтры.

---

## 🧪 Альтернативный вариант с явным соответствием имён

Если вы хотите быть уверены, что `name` из `node_systemd_unit_state` точно совпадает с `service` из `uptime`, можно использовать более точное сравнение:

```promql
# Получаем список systemd-сервисов
node_systemd_unit_state{state="active", name=~".*\\.service"}
# Исключаем те, у которых есть uptime метрика с такой же меткой service
unless on(name)
group_left()
# Берём uptime или up
(uptime or up{job!~"prometheus|node"}) > 0
```

В этом случае метка `name` из systemd будет сравниваться с меткой `service` из метрики.

---

## 📝 Примечания

- Если метрика `uptime` собирается через `blackbox_exporter`, то вместо неё можно использовать `up{job="..."}`.
- Убедитесь, что scrape-цели для ваших сервисов правильно настроены.
- Если некоторые сервисы могут иметь `uptime == 0`, но при этом работать корректно, лучше использовать `up` метрику.

---

## 💡 Рекомендация

Если вы используете переменную `$srv` (например, список сервисов), вы можете добавить фильтр:

```promql
name=~"$srv\\.service"
```

Это ограничит выборку только нужными сервисами.

---

Хочешь, чтобы я помог адаптировать этот запрос под конкретные названия сервисов или jobs?
