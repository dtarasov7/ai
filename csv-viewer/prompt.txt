Сделай, пожалуйста, полноценную консольную TUI‑утилиту на Python для просмотра csv файлов в виде таблицы (терминальный интерфейс на базе curses).

## Назначение

Нужно приложение для разработчика/devops, которое позволяет удобно просматривать большие csv без загрузки всего в память,
с поиском и фильтрацией полей, как в виде таблицы так и в виде карточки одной записи.

## Технические требования

1. **Язык и зависимости**
   - Python 3.8+.
   - Только стандартная библиотека (можно использовать `curses`, `json`, `pathlib`, `re`, `signal`, `typing`, `os`, `sys`).
   - Один файл: `csv_tui_viewer_secure.py`.

2. **Форматы входных данных**
   - csv файл
   - разделитель полей задается в виде аргумента  при запуске программы

3. **Архитектура**
   - используется кеширование и ленивое чтение

4. **Поведение TUI**

   Экран:
   - Верхняя строка: имя файла, текущая строка/количество строк (начитаных к данному моменту), индикатор фильтра.
   - Основная область в табличном режиме: таблица с шапкой имен полей ( таблица скролируется горизонтально и вертикально); 
     Выделение перемешается по полям горизонтально или по записям вертикально;
     ширина столбцов вчисляется автоматически (но не шире половины ширины экран) при возможности вручную задать ширину каждого столбца
   - Основная область в режиме одной записи: имена полей и значения полей. Длинные поля обрезаются под ширину экран;
   - Нижние строки: статус/сообщения и подсказки по управлению.

   - Переход между записями (при переходне не доллжно бытьь выхода за последнюю имеющуюся запись):
     - `g` — перейти к записи по номеру.
     - `Home` — первая запись.
     - `End` — последяя запись.
     - `PgDn` — следующая запись в карточном режиме или с сохранением относительного пути к полю (если возможно) или следущая страница записей в табличном режиме.
     - `PgUp` — предыдущая запись в карточном режиме или с сохранением относительного пути к полю (если возможно) или следущая страница записей в табличном режиме.
   - Поиск:
     - `s` — поиск по текущему полю:
       - Запрос строки (подсказка “regex”).
       - Поиск по всем записям только по этому полю.
       - Результаты — список `CsvNode`, навигация по ним `n` / `p`.
     - `F` — глобальный поиск:
       - Поиск по всем полям .
       - Возврат списка совпадений и множества имен полей, в которых были найдено.
       - Автоматическое включение фильтра по этим полям.
       - Навигация по результатам `n` / `p`.
   - Фильтрация:
     - `f` — диалог выбора полей:
       - Список полей.
       - Переключение пробелом, Enter — применить, Esc — отмена , '+' - выделить все, '-' - снять выделение со всех (отключить фильтрацию полей).
   - Выход:
     - `q` / `Esc` — выход.

5. **Производительность и ленивость**

   - Подгрузка:
     - При первом показе — предзагрузить только `max(list_height + 10, 20)` объектов.
     - При прокрутке вниз, если курсор приближается к концу списка видимых записей — подгружать следующую пачку (например, по 5 объектов).
   - Кэш:
     - Не хранить всех объектов в памяти.
     - LRU‑кэш на ~200 объектов: при переполнении выкидывать самые старые.

6. **Безопасность**

   Реализовать защиту от следующих рисков (без использования внешних библиотек):

   1) **Сsv Bomb / DoS по содержимому, а не по размеру файла**:

   2) **ReDoS (Regular Expression DoS)**:
      - Пользователь вводит паттерн (строка) для `s` и `F`.
      - Нужно:
        - Скомпилировать regex с ограничением времени (например, через `signal.SIGALRM` на Unix).
        - Ввести функции:
          - `safe_regex_compile(pattern_str, timeout=2)` — компиляция с таймаутом, при истечении — `TimeoutError` и переход на простой поиск подстроки.
          - `safe_regex_search(pattern, text, timeout=2)` — поиск с таймаутом и обрезкой слишком длинных строк (например, до 10 000 символов).
        - Если regex слишком сложный (таймаут или ошибка компиляции) — использовать поиск как `pattern_str.lower() in text.lower()`.

   4) **Path / device safety**:
      - Файл открывается с путём из аргумента командной строки.
      - Ввести `validate_file_path(filepath: str) -> Path`, которая:
        - Нормализует путь через `Path.resolve()`.
        - Проверяет, что файл существует и это обычный файл (`is_file()`).
        - Запрещает пути, начинающиеся с `/dev/`, `/proc/`, `/sys/` (чтение псевдо‑устройств типа `/dev/zero` и т.п.).
      - При нарушении — выбросить `SecurityError` и вывести пользователю понятное сообщение.

7. **Пользовательский опыт**

   - При старте:
     - Понятное сообщение об ошибках (файл не найден, невалидный yaml, опасная структура и т.п.).
   - Диалоговые окна (`input_string`, выбор полей, просмотр значения) должны корректно обрабатывать Esc/`q`.

8. **Качество кода**

   - Обязательно:
     - Читаемые имена переменных и функций.
     - Краткие docstring’и у основных классов и функций.
     - Однострочные комментарии на русском языке только в местах, где логика неочевидна (например, восстановление пути при PgUp/PgDn, защита от DoS, работа кэша).
   - Код должен быть готов к прямому запуску:
     - `python csv_tui_viewer_secure.py path/to/file.csv`.

***

Сформируй полный исходный код `csv_tui_viewer_secure.py`, строго удовлетворя требованиям выше.

