Ниже пример, который реально укладывается в Ceph **v17 (Quincy)**: бакеты создаются через S3 API, а “права по группам” делаются через **две IAM роли** в RGW (role-group1 и role-group2) + trust policy, которая проверяет claim `groups` из JWT Keycloak при `AssumeRoleWithWebIdentity`.[1][2]

> Важное ограничение: **бакеты** через `radosgw-admin` обычно не “создаются” как сущности — их создают через S3 API (awscli/s3cmd/boto3), а `radosgw-admin` используется для пользователей/ролей/политик/диагностики.[3][4]

## Предусловия (что нужно подставить)

- S3/STS endpoint RGW: `https://ceph` (как у вас).  
- Keycloak realm: `test`, issuer: `https://keycloak/realms/test` (пример).  
- OIDC client (в Keycloak): `ceph-s3` (пример), и он попадает в токен как `aud` (или аналогичный claim).  
- В access token есть claim `groups`, содержащий `group1`/`group2` (как строки или пути).  
- На стороне RGW включён STS (`rgw_s3_auth_use_sts = true`) и задан `rgw_sts_key`.[2]

## Команды/шаги в Ceph v17

### 1) Создать “iam admin” пользователя (для IAM/OIDC/roles)

```bash
radosgw-admin user create \
  --uid iam-admin --display-name "iam admin" \
  --access-key IAMADMINACCESS --secret-key IAMADMINSECRET
```

Дать capability на управление ролями и OIDC provider:[3][2]

```bash
radosgw-admin caps add --uid iam-admin --caps "roles=*"
radosgw-admin caps add --uid iam-admin --caps "oidc-provider=*"
```

### 2) Создать роли и политики (role-group1 и role-group2)

В Ceph есть `radosgw-admin role create` и `radosgw-admin role policy put` (inline policy), которыми и создаются роли + привязываются permission policies.[1]

#### Trust policy для group1 (разрешить assume только если groups содержит group1)

Файл `trust-group1.json`:

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {
      "Federated": ["arn:aws:iam:::oidc-provider/https://keycloak/realms/test"]
    },
    "Action": ["sts:AssumeRoleWithWebIdentity"],
    "Condition": {
      "StringEquals": {
        "https://keycloak/realms/test:aud": "ceph-s3",
        "https://keycloak/realms/test:groups": "group1"
      }
    }
  }]
}
```

Создать роль:[1]

```bash
radosgw-admin role create \
  --role-name role-group1 \
  --path / \
  --assume-role-policy-doc "$(cat trust-group1.json)"
```

#### Trust policy для group2

Файл `trust-group2.json` (аналогично, только group2):

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {
      "Federated": ["arn:aws:iam:::oidc-provider/https://keycloak/realms/test"]
    },
    "Action": ["sts:AssumeRoleWithWebIdentity"],
    "Condition": {
      "StringEquals": {
        "https://keycloak/realms/test:aud": "ceph-s3",
        "https://keycloak/realms/test:groups": "group2"
      }
    }
  }]
}
```

```bash
radosgw-admin role create \
  --role-name role-group2 \
  --path / \
  --assume-role-policy-doc "$(cat trust-group2.json)"
```

#### Permission policy: group1 → полный доступ к b1, запрет b2

Файл `perm-group1.json`:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAllOnB1",
      "Effect": "Allow",
      "Action": ["s3:*"],
      "Resource": ["arn:aws:s3:::b1", "arn:aws:s3:::b1/*"]
    },
    {
      "Sid": "DenyAllOnB2",
      "Effect": "Deny",
      "Action": ["s3:*"],
      "Resource": ["arn:aws:s3:::b2", "arn:aws:s3:::b2/*"]
    }
  ]
}
```

Прикрепить как inline policy к роли:[1]

```bash
radosgw-admin role policy put \
  --role-name role-group1 \
  --policy-name perm-group1 \
  --policy-doc "$(cat perm-group1.json)"
```

#### Permission policy: group2 → полный доступ к b2, запрет b1

Файл `perm-group2.json`:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAllOnB2",
      "Effect": "Allow",
      "Action": ["s3:*"],
      "Resource": ["arn:aws:s3:::b2", "arn:aws:s3:::b2/*"]
    },
    {
      "Sid": "DenyAllOnB1",
      "Effect": "Deny",
      "Action": ["s3:*"],
      "Resource": ["arn:aws:s3:::b1", "arn:aws:s3:::b1/*"]
    }
  ]
}
```

```bash
radosgw-admin role policy put \
  --role-name role-group2 \
  --policy-name perm-group2 \
  --policy-doc "$(cat perm-group2.json)"
```

### 3) Создать бакеты b1 и b2

Создавать бакеты проще всего через S3 API (например, awscli) с любыми админскими S3 кредами, у которых есть право `CreateBucket`.[4]

Пример через `aws` (используя ключи iam-admin — **только для bootstrap**):

```bash
export AWS_ACCESS_KEY_ID=IAMADMINACCESS
export AWS_SECRET_ACCESS_KEY=IAMADMINSECRET

aws --endpoint-url https://ceph s3 mb s3://b1
aws --endpoint-url https://ceph s3 mb s3://b2
```

## Python3 тест (boto3): user1 и user2

Ниже код делает:
1) Берёт JWT для user1 и user2 (тут предполагается, что токены уже есть как строки — способ получения зависит от вашего Keycloak flow).  
2) Вызывает `AssumeRoleWithWebIdentity` для нужной роли.  
3) Делает тестовые операции: `ListObjectsV2`, `PutObject` в b1 и b2, проверяя что разрешения соблюдаются.  
`AssumeRoleWithWebIdentity` — стандартный STS вызов, который использует и Ceph RGW STS.[5][2]

```python
#!/usr/bin/env python3
import boto3
from botocore.exceptions import ClientError

RGW_ENDPOINT = "https://ceph"

ROLE_ARN_GROUP1 = "arn:aws:iam:::role/role-group1"
ROLE_ARN_GROUP2 = "arn:aws:iam:::role/role-group2"

# ВСТАВЬТЕ СЮДА реальные JWT access tokens, полученные от Keycloak
USER1_JWT = "<JWT_FOR_user1>"
USER2_JWT = "<JWT_FOR_user2>"

def assume(role_arn: str, jwt_token: str, session_name: str):
    sts = boto3.client("sts", endpoint_url=RGW_ENDPOINT)
    resp = sts.assume_role_with_web_identity(
        RoleArn=role_arn,
        RoleSessionName=session_name,
        WebIdentityToken=jwt_token,
        DurationSeconds=3600,
    )
    c = resp["Credentials"]
    return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]

def s3_client(access_key, secret_key, session_token):
    return boto3.client(
        "s3",
        endpoint_url=RGW_ENDPOINT,
        aws_access_key_id=access_key,
        aws_secret_access_key=secret_key,
        aws_session_token=session_token,
    )

def try_op(desc, fn):
    try:
        fn()
        print(f"OK  : {desc}")
        return True
    except ClientError as e:
        code = e.response.get("Error", {}).get("Code")
        msg = e.response.get("Error", {}).get("Message")
        print(f"FAIL: {desc} -> {code}: {msg}")
        return False

def test_user(user_label, role_arn, jwt):
    ak, sk, st = assume(role_arn, jwt, session_name=user_label)
    s3 = s3_client(ak, sk, st)

    # Проверяем b1
    try_op(f"{user_label} list b1", lambda: s3.list_objects_v2(Bucket="b1"))
    try_op(f"{user_label} put b1/test.txt", lambda: s3.put_object(Bucket="b1", Key="test.txt", Body=b"data"))

    # Проверяем b2
    try_op(f"{user_label} list b2", lambda: s3.list_objects_v2(Bucket="b2"))
    try_op(f"{user_label} put b2/test.txt", lambda: s3.put_object(Bucket="b2", Key="test.txt", Body=b"data"))

if __name__ == "__main__":
    print("Testing user1 (group1 -> allow b1, deny b2)")
    test_user("user1", ROLE_ARN_GROUP1, USER1_JWT)

    print("\nTesting user2 (group2 -> allow b2, deny b1)")
    test_user("user2", ROLE_ARN_GROUP2, USER2_JWT)
```

### Ожидаемый результат теста
- Для `user1`: операции на `b1` должны быть `OK`, на `b2` — `FAIL` (обычно `AccessDenied`).  
- Для `user2`: наоборот.

***

Чтобы пример был “под ключ” (включая получение JWT по паролю), нужно уточнить: у вас Keycloak разрешает **Direct Access Grants** (password grant) для client `ceph-s3`, или токен получаете через browser/OIDC code flow? (Тогда можно дописать блок получения JWT без ручной вставки.)

[1](https://docs.ceph.com/en/quincy/radosgw/role/)
[2](https://docs.ceph.com/en/latest/radosgw/STS/)
[3](https://docs.ceph.com/en/latest/man/8/radosgw-admin/)
[4](https://cloudspinx.com/create-ceph-bucket-user-with-quotas-using-radosgw-admin/)
[5](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sts/client/assume_role_with_web_identity.html)
[6](https://docs.ceph.com/en/latest/radosgw/admin/)
[7](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/4/html/object_gateway_configuration_and_administration_guide/rgw-administration-rgw)
[8](https://manpages.debian.org/experimental/ceph-common/radosgw-admin.8.en.html)
[9](https://docs.ceph.com/en/nautilus/radosgw/role/)
[10](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/5/html/object_gateway_guide/administration)
[11](https://docs.ceph.com/en/latest/radosgw/role/)
[12](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html)
[13](https://stackoverflow.com/questions/79653238/adding-ceph-object-store-bucket-user-via-cli)
[14](https://blog.csdn.net/xu710263124/article/details/141260193)
[15](https://www.ibm.com/docs/en/storage-ceph/8.0.0?topic=service-creating-iam-roles-policies)
[16](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/4/html/developer_guide/examples-using-the-secure-token-service-apis_dev)
[17](https://github.com/ceph/ceph/blob/main/doc/man/8/radosgw-admin.rst)
[18](https://ceph.io/en/news/blog/2025/enhancing-ceph-multitenancy-with-iam-accounts/)
[19](https://www.ibm.com/docs/en/storage-ceph/7.1.0?topic=developer-examples-using-secure-token-service-apis)
[20](https://github.com/pcuzner/ceph-radosgw-admin)
