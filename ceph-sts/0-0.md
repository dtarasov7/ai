



Интеграция Ceph RadosGW с внешними IdP через STS (Secure Token Service) и OIDC позволяет реализовать полноценное управление доступом на основе атрибутов пользователя, включая LDAP-группы. Эта схема значительно мощнее базовой LDAP-аутентификации.[1][2]

## Архитектура решения

Связка работает по следующей схеме:[3][4]

1. Пользователь аутентифицируется в SSO-провайдере (Keycloak/RHSSO), который федерирован с корпоративным LDAP/AD
2. SSO выдаёт JWT-токен (Web Identity Token) с claims, включающими атрибуты пользователя из LDAP (группы, отделы, проекты)
3. Приложение обращается к RadosGW STS endpoint с этим токеном, запрашивая AssumeRoleWithWebIdentity
4. RadosGW валидирует токен через SSO и выдаёт временные S3-креденшелы (access/secret key) на основе IAM-роли
5. Пользователь получает доступ к S3-ресурсам согласно политикам, прикреплённым к роли

## Настройка RadosGW

В конфигурации `/etc/ceph/ceph.conf` необходимо включить STS:[5][1]

```ini
[client.radosgw.gateway]
rgw sts key = <16 hex chars, generated by: openssl rand -hex 16>
rgw s3 auth use sts = true
```

Создайте служебного пользователя с правами управления OIDC-провайдерами и ролями:[6][2]

```bash
radosgw-admin user create --uid TESTUID1 --display-name "iam_user" \
  --access_key TESTUID1 --secret test123
radosgw-admin caps add --uid="TESTUID1" --caps="oidc-provider=*"
radosgw-admin caps add --uid="TESTUID1" --caps="roles=*"
```

## Настройка Keycloak/RHSSO

В Keycloak создайте realm и client для вашего приложения. Настройте федерацию с LDAP и включите в токены необходимые атрибуты пользователя (группы, custom claims) через mappers.[7][5]

## Создание IAM-провайдера и ролей

Используя boto3 или radosgw-admin API, зарегистрируйте OIDC-провайдер в RadosGW:[2]

```python
iam_client.create_open_id_connect_provider(
    Url='https://keycloak.example.com/auth/realms/myrealm',
    ClientIDList=['my-s3-app'],
    ThumbprintList=['<certificate thumbprint>']
)
```

Создайте IAM-роль с trust policy, который проверяет claims из JWT-токена. Например, разрешить доступ только пользователям из определённой LDAP-группы:[2]

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"Federated": ["arn:aws:iam:::oidc-provider/keycloak.example.com/auth/realms/myrealm"]},
    "Action": ["sts:AssumeRoleWithWebIdentity"],
    "Condition": {
      "StringEquals": {
        "keycloak.example.com/auth/realms/myrealm:groups": "ceph-users"
      }
    }
  }]
}
```

## Attribute-Based Access Control (ABAC)

RadosGW поддерживает ABAC через Session Tags и resource tagging. Вы можете прокидывать атрибуты из LDAP (проект, отдел, уровень доступа) через JWT claims в Session Tags и использовать их в IAM-политиках:[8][7]

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "s3:*",
    "Resource": "arn:aws:s3:::*",
    "Condition": {
      "StringEquals": {
        "aws:ResourceTag/project": "${aws:PrincipalTag/project}"
      }
    }
  }]
}
```

Эта политика разрешает доступ к бакетам только если тег `project` на ресурсе совпадает с атрибутом пользователя `project` из LDAP. Для реализации ABAC необходимо настроить маппинг LDAP-атрибутов в claims Keycloak и передачу их как Session Tags при AssumeRoleWithWebIdentity.[7]

[1](https://docs.ceph.com/en/latest/radosgw/keycloak/)
[2](https://ceph.io/en/news/blog/2024/v17-2-8-quincy-released/)
[3](https://www.ibm.com/docs/en/storage-ceph/8.0.0?topic=gateway-secure-token-service)
[4](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/6/html/developer_guide/ceph-object-gateway-and-the-s3-api)
[5](https://docs.ceph.com/en/reef/radosgw/ldap-auth/)
[6](https://wiki.osnexus.com/index.php?title=KeyCloak_Integration)
[7](https://community.ibm.com/community/user/storage/blogs/daniel-alexander-parkes/2024/03/09/ceph-object-iam-sts-abac)
[8](https://docs.ceph.com/en/reef/radosgw/session-tags/)
[9](https://docs.ceph.com/en/latest/radosgw/STS/)
[10](https://www.spinics.net/lists/ceph-users/msg71339.html)
[11](https://www.spinics.net/lists/ceph-users/msg69879.html)
[12](https://github.com/OSNEXUS/KeyCloak-w-Ceph-RADOSGW)


Приложение **использует оба API последовательно**: сначала STS API для получения временных креденшелов, затем стандартный S3 API для работы с данными.[1]

## Двухэтапный процесс

### Этап 1: Получение временных креденшелов через STS

Приложение делает вызов к **STS endpoint** (который находится в том же namespace, что и S3 endpoint RadosGW) с методом `AssumeRoleWithWebIdentity`. В этом запросе передаются:[8][1]

- JWT-токен от Keycloak (WebIdentityToken)
- ARN роли, которую хочет принять пользователь
- Длительность сессии (DurationSeconds)

```python
sts_client = boto3.client('sts',
    endpoint_url='https://radosgw.example.com',  # тот же endpoint
    region_name=''
)

response = sts_client.assume_role_with_web_identity(
    RoleArn='arn:aws:iam:::role/my-s3-role',
    RoleSessionName='my-session',
    DurationSeconds=3600,
    WebIdentityToken='<JWT from Keycloak>'
)
```

RadosGW валидирует JWT-токен, проверяет trust policy роли и возвращает временные S3-креденшелы:[1]

- `AccessKeyId` (временный)
- `SecretAccessKey` (временный)  
- `SessionToken` (обязательный параметр для STS-сессий)

### Этап 2: Работа с S3 API

Получив временные креденшелы, приложение создаёт **S3-клиент** с этими креденшелами и работает через **стандартный S3 API**:[1]

```python
s3_client = boto3.client('s3',
    aws_access_key_id=response['Credentials']['AccessKeyId'],
    aws_secret_access_key=response['Credentials']['SecretAccessKey'],
    aws_session_token=response['Credentials']['SessionToken'],
    endpoint_url='https://radosgw.example.com'
)

# Обычные S3-операции
s3_client.create_bucket(Bucket='my-bucket')
s3_client.put_object(Bucket='my-bucket', Key='file.txt', Body=b'data')
```

Все последующие S3-вызовы аутентифицируются **локально внутри RadosGW** с использованием session token, без обращения к внешнему IdP. Это снижает latency и нагрузку на Keycloak по сравнению с внешней аутентификацией каждого S3-запроса.[4]

## Важные детали

STS и S3 API находятся в одном namespace RadosGW и доступны через один endpoint, но это разные API-методы. STS используется только для обмена JWT на временные S3-креденшелы, а вся дальнейшая работа с объектами идёт через классический S3 API.[9][8][1]

[1](https://docs.ceph.com/en/latest/radosgw/STS/)
[2](http://vitastor.io/blog/2024-05-09-s3-comparison.html)
[3](http://onreader.mdl.ru/LearningCeph/content/Ch06.html)
[4](https://www.youtube.com/watch?v=SvCA0fd7dZc)
[5](https://ivirt-it.ru/ceph-object-gateway-radosgw-performance-monitoring-zabbix/)
[6](https://docs.ceph.com/en/latest/man/8/radosgw/)
[7](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/4/html-single/object_gateway_configuration_and_administration_guide/index)
[8](https://www.ibm.com/docs/en/storage-ceph/7.1.0?topic=service-configuring-secure-token)
[9](https://documentation.commvault.com/v11/software/setup_in_ceph_object_storage_s3_compatible.html)
[10](https://github.com/ceph/ceph/blob/master/doc/radosgw/STSLite.rst)



Да, **большая часть функциональности работает в Ceph v17 (Quincy)**, но есть важные нюансы по версиям и возможностям.[1][2]

## Что точно работает в Quincy v17

- **STS API и AssumeRoleWithWebIdentity** — базовая поддержка STS появилась задолго до v17 и стабильно работает в Quincy[2][3]
- **OIDC интеграция с Keycloak/RHSSO** — документирована для Quincy, включая создание OpenID Connect Provider и использование JWT-токенов[3][4][5]
- **IAM роли с trust policies** — полная поддержка создания ролей с condition-based trust policies, включая проверку JWT claims[3]
- **Временные S3 креденшелы** — механизм выдачи временных access/secret keys через STS работает[3]

## ABAC и Session Tags — ограничения в v17

**Session Tags для ABAC** — это более новая функциональность. В документации IBM Storage Ceph (базируется на upstream Ceph) эта возможность описана как доступная, но в официальной документации Ceph session tags впервые явно упоминаются в контексте более поздних релизов.[6][7][8]

Для v17 вам доступна упрощённая версия ABAC через:
- Проверку статических claims JWT в trust policy роли (например, фильтрация по группе в `Condition`)
- Использование resource tags и principal tags в IAM политиках без динамических session tags

Полноценный ABAC с `aws:PrincipalTag` и `aws:RequestTag` через session tags может требовать v18 (Reef) или новее. Для точности рекомендую проверить changelog конкретной минорной версии v17 (например, v17.2.6, v17.2.7, v17.2.8), так как некоторые функции могли быть backport'ированы.[9][10][8]

## Рекомендации для v17

Для production на Quincy v17.2.8 (последний релиз серии)  безопасно использовать:[9]
- STS + OIDC + Keycloak для федеративной аутентификации
- IAM роли с condition-based trust policies на основе JWT claims
- Фильтрацию доступа через проверку LDAP-групп в JWT token claims

Для advanced ABAC с динамическими session tags рассмотрите upgrade на Reef (v18) или Squid (v19).

[1](https://docs.ceph.com/en/latest/releases/quincy)
[2](https://ceph.io/en/news/blog/2022/v17-2-0-quincy-released/)
[3](https://docs.ceph.com/en/quincy/radosgw/STS/)
[4](https://docs.ceph.com/en/octopus/radosgw/keycloak/)
[5](https://docs.ceph.com/en/latest/radosgw/keycloak/)
[6](https://community.ibm.com/community/user/storage/blogs/daniel-alexander-parkes/2024/03/09/ceph-object-iam-sts-abac)
[7](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html)
[8](https://docs.ceph.com/en/reef/radosgw/session-tags/)
[9](https://ceph.io/en/news/blog/2024/v17-2-8-quincy-released/)
[10](https://ceph.io/en/news/blog/2023/v17-2-6-quincy-released/)
[11](https://support.kion.io/hc/en-us/articles/4412617879309-Attribute-Based-Access-Control-via-Session-Tags)


Ниже — рабочая схема “AD группы → токен Keycloak → AssumeRoleWithWebIdentity → временные S3 creds → доступ по IAM policy (Action/Resource)” для Ceph RGW (v17) и Keycloak/RHSSO.[1][2]

## Целевая модель доступа

Идея такая: **каждой AD-группе соответствует IAM Role в RGW**, у роли есть (1) trust policy, которая разрешает “assume” только пользователям, у которых в JWT есть нужная группа, и (2) permission policy, которая описывает ваши `Action`/`Resource` на S3.[1]

Приложение/CLI сначала получает JWT в Keycloak, затем вызывает `AssumeRoleWithWebIdentity` на RGW STS, получает временные ключи и уже ими выполняет обычные S3-запросы.[2][1]

## Настройки Ceph RGW (Quincy/v17)

### 1) Включить STS в RGW

В `ceph.conf` для соответствующего `client.radosgw.<name>` включите STS и задайте единый ключ для всех rgw в зоне (и в идеале во всём realm в multisite).[2][1]

```ini
[client.radosgw.gateway]
rgw sts key = <16 hex chars>
rgw s3 auth use sts = true
```

Параметры `rgw_sts_key` (16 hex) и `rgw_s3_auth_use_sts=true` — обязательная часть STS-интеграции.[1]

### 2) Завести admin-пользователя для IAM/OIDC/roles

Нужен пользователь RGW (access/secret), которым будете создавать OIDC provider и роли/политики. В примере ниже — через `radosgw-admin` и выдачу capability `roles=*` и `oidc-provider=*`.[2][1]

```bash
radosgw-admin user create --uid iam-admin --display-name "iam admin" \
  --access_key IAMADMINACCESS --secret IAMADMINSECRET

radosgw-admin caps add --uid="iam-admin" --caps="roles=*"
radosgw-admin caps add --uid="iam-admin" --caps="oidc-provider=*"
```

### 3) Создать OIDC Provider в RGW

Перед `AssumeRoleWithWebIdentity` в RGW должен быть создан объект “OpenID Connect Provider”. Ceph прямо говорит, что перед вызовом `AssumeRoleWithWebIdentity` нужно создать OIDC Provider entity в RGW.[1]

Создание делается через IAM API (обычно boto3 `iam.create_open_id_connect_provider`), где указываются URL realm’а Keycloak, список ClientID (audience) и thumbprint сертификата IdP.[1]

## Настройки Keycloak/RHSSO (с AD)

### 1) Подключить AD как User Federation

В Keycloak настраивается LDAP Federation к AD (User Federation → LDAP) так, чтобы Keycloak мог подтягивать пользователей и их группы из AD, и чтобы группы были доступны для “маппинга” в токены. (Это базовая функциональность Keycloak; в Ceph-доках подразумевается, что именно Keycloak является IdP.)[2][1]

### 2) Создать OIDC client для приложения

Создайте Client (например `s3-client`) в нужном realm’е; именно его `client_id` должен попадать в claim `aud`/`app_id` (см. ниже про trust policy).[1]

### 3) Пробросить AD-группы в JWT (важно)

Выпустите access token так, чтобы он содержал claim с группами (часто `groups`) или иной claim, который однозначно представляет членство в AD-группах. Ceph RGW умеет использовать **любой claim JWT** в `Condition` trust policy роли.[1]

(В Ceph-документации показаны примеры условий по `aud`/`sub`/`azp` и отмечено, что “All claims of the JWT are supported in the condition”.)[1]

## Привязка “AD группа → права” через роли RGW

Ниже — практический паттерн под вашу модель “action/resource”.

### 1) Trust policy роли: кто может assume роль

Создаёте роль `role-readonly-teamA` и в trust policy проверяете:
- что токен пришёл от вашего OIDC provider (Keycloak realm URL)
- что приложение (aud/app_id) правильное
- что пользователь состоит в нужной AD-группе (через claim `groups`, если вы его так пробросили)[1]

Ceph приводит пример trust policy с проверкой `app_id` (который должен совпасть с `aud` claim токена).[1]

Схематично (псевдо-JSON, адаптируете под ваши реальные claim names/формат):

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {
      "Federated": ["arn:aws:iam:::oidc-provider/<KEYCLOAK_REALM_URL>"]
    },
    "Action": ["sts:AssumeRoleWithWebIdentity"],
    "Condition": {
      "StringEquals": {
        "<KEYCLOAK_REALM_URL>:app_id": "s3-client",
        "<KEYCLOAK_REALM_URL>:groups": "CN=TeamA-S3-Read,OU=Groups,DC=example,DC=com"
      }
    }
  }]
}
```

Ключевой момент: RGW проверяет condition по claims JWT при `AssumeRoleWithWebIdentity`.[1]

### 2) Permission policy роли: что можно делать (Action/Resource)

Дальше вы прикрепляете к роли permission policy, которая реализует вашу ролевую модель (набор `Action` + `Resource` ARN’ы бакетов/префиксов). Ceph описывает, что временные креденшелы будут иметь права, разрешённые политиками, привязанными к Role, и что этими креденшелами выполняются последующие S3 вызовы.[1]

Пример (упрощённо):

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": ["s3:GetObject", "s3:ListBucket"],
    "Resource": [
      "arn:aws:s3:::team-a-bucket",
      "arn:aws:s3:::team-a-bucket/*"
    ]
  }]
}
```

### 3) Как пользователь получает права на практике

1. Пользователь логинится в Keycloak (через AD) и получает JWT.[2]
2. Приложение вызывает `AssumeRoleWithWebIdentity(RoleArn=..., WebIdentityToken=JWT)` на RGW и получает временные S3 ключи.[2][1]
3. Пользователь делает S3 операции этими ключами, и RGW проверяет их против permission policy роли.[1]

Ceph отдельно подчёркивает, что STS и S3 API “co-exist in the same namespace” и доступны через один endpoint.[1]

***

Как у вас сейчас выглядят `Action/Resource` (есть ли условные ограничения типа “только prefix”, “только по тегам”, “deny overrides”), и в каком формате вы готовы/хотите хранить соответствие “AD group → Role”?

[1](https://docs.ceph.com/en/latest/releases/quincy)
[2](https://ceph.io/en/news/blog/2024/v17-2-8-quincy-released/)


Да — в Ceph RGW остаются записи, по которым можно понять **кто** выполнил (или пытался выполнить) операцию, но “кто” обычно фиксируется не как человек из AD, а как идентификатор, который RGW видит на уровне S3/STS (access key / role / session).[1]

## Что видно “из коробки” (S3/STS)

При использовании STS/ролей аудит-трейл улучшается: вместо “безличных” статических ключей в логах RGW появляются поля, по которым можно атрибутировать запрос — как минимум, какая роль была assumed (`role_name`) и какое имя сессии было задано (`role_session_name`).[1]

Это означает, что если при `AssumeRoleWithWebIdentity` вы задаёте осмысленный `RoleSessionName` (например, включаете туда username/UPN/subject и идентификатор приложения), то в логах RGW можно будет однозначно сопоставить S3-операции с конкретной сессией.[1]

## Логи попыток (deny/unauthorized)

Неуспешные попытки (ошибки авторизации/аутентификации) тоже могут быть отражены в логировании RGW, но полезность зависит от включённых режимов логов (access/ops/audit/bucket logging) и того, что именно включено в формат и уровень.[2][3]

На практике для расследований обычно включают:
- ops log (логирование операций RGW) и выводят его в файл/STDOUT контейнера.[3]
- bucket logging на важных бакетах — чтобы иметь журнал обращений на уровне бакета/объектов (это отдельный механизм “лог в бакет”).[4][2]

## Важно про “именно пользователь из AD”

RGW сам по себе не “пишет в лог AD-username” автоматически во всех местах, потому что после обмена JWT→STS creds дальнейшие S3 запросы идут с временными ключами, а не с JWT.[5][1]

Поэтому, чтобы в логах стабильно фигурировал человек, обычно делают так:
- В Keycloak обеспечивают, чтобы в JWT был устойчивый идентификатор пользователя (например `sub`, `preferred_username`, UPN), и
- При вызове `AssumeRoleWithWebIdentity` приложение формирует `RoleSessionName`, включающий этот идентификатор (или его хеш/короткую форму), чтобы он попадал в лог как `role_session_name`.[1]

Если напишите, какой формат логов RGW используете сейчас (cephadm/containers или systemd, и включён ли ops log / bucket logging), можно предложить конкретный “минимальный набор” настроек под аудит (включая какие поля лучше протаскивать в session name).

[1](https://ceph.io/en/news/blog/2025/rgw-modernizing-sts/)
[2](https://docs.ceph.com/en/latest/radosgw/bucket_logging/)
[3](https://docs.clyso.com/docs/kb/object/)
[4](https://ceph.io/en/news/blog/2025/enhancing-object-storage-logging/)
[5](https://documentation.commvault.com/v11/software/setup_in_ceph_object_storage_s3_compatible.html)
[6](https://docs.ceph.com/en/latest/radosgw/admin/)
[7](https://ceph-users.ceph.narkive.com/7iSpxC4R/civetweb-log-format)
[8](https://docs.redhat.com/it/documentation/red_hat_ceph_storage/6/html-single/data_security_and_hardening_guide/index)
[9](https://shanaceph.readthedocs.io/en/latest/mgr/dashboard/)
[10](https://www.ibm.com/docs/en/storage-ceph/7?topic=reference-logging-settings)
[11](https://docs.ceph.com/en/latest/radosgw/adminops/)
[12](https://www.ibm.com/docs/en/storage-ceph/8.0.0?topic=reference-logging-settings)
[13](https://docs.ceph.com/en/octopus/radosgw/adminops/)
[14](https://docs.ceph.com/en/latest/radosgw/account/)
[15](https://ceph-zdover23-search-test.readthedocs.io/en/latest/radosgw/admin)
[16](https://openmetal.io/resources/blog/setting-up-and-managing-ceph-rados-gateway-rgw-in-openstack/)
[17](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/6/html/object_gateway_guide/administration)
[18](https://www.ibm.com/docs/en/storage-ceph/7.1.0?topic=management-add-remove-access-keys)
[19](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/)
[20](https://manpages.ubuntu.com/manpages/focal/en/man8/radosgw-admin.8.html)
[21](https://www.mail-archive.com/search?l=ceph-users%40lists.ceph.com&q=subject%3A%22%5C%5Bceph%5C-users%5C%5D+Radosgw%22&o=newest&f=1)


Да, правильно: схема STS+OIDC (Keycloak → JWT → `AssumeRoleWithWebIdentity` в RGW → временные S3-креды → S3 API) будет работать и для **локальных пользователей и локальных групп Keycloak**, не только для федерации с AD.[1][2]

## Почему это работает

RGW при `AssumeRoleWithWebIdentity` опирается на **claims внутри JWT**, а не на то, откуда Keycloak взял пользователей (AD по LDAP или локальная база Keycloak).  В документации Ceph для STS прямо сказано, что “all claims of the JWT are supported in the condition of the role’s trust policy”, то есть условия trust policy могут проверять любые claims токена (включая группы, роли, azp/aud/sub и т.п.).[2][3]

## Что нужно обеспечить в Keycloak

Чтобы завязать доступ на “группы”, надо, чтобы членство в группах реально попадало в JWT (например claim `groups`).  Это одинаково делается и для локальных групп Keycloak, и для групп, синхронизированных из AD: важно не происхождение групп, а то, что они сериализуются в токен.[4][2]

## Практический нюанс

Убедитесь, что trust policy роли в RGW проверяет **тот claim и тот формат**, который выдаёт Keycloak (например, `groups` может быть массивом путей `/teamA/s3-read`, а не “CN=...”).  С точки зрения Ceph это нормально, потому что условие в trust policy сравнивает значения claims в токене, и вы можете выбрать подходящий claim/формат.[4][2]

Если скажете, какой именно claim с группами вы хотите использовать (`groups`, realm roles, client roles) и какой формат удобнее (строки, пути, GUID), можно набросать пример trust policy под ваш конкретный token payload.

[1](https://docs.ceph.com/en/latest/radosgw/keycloak/)
[2](https://docs.ceph.com/en/latest/radosgw/STS/)
[3](https://docs.ceph.com/en/pacific/radosgw/STS/)
[4](https://www.keycloak.org/docs/latest/server_admin/index.html)
[5](https://hoop.dev/blog/how-to-configure-ceph-keycloak-for-secure-repeatable-access/)
[6](https://wiki.ymlnet.com/ceph/radosgw/keycloak/)
[7](https://github.com/OSNEXUS/KeyCloak-w-Ceph-RADOSGW)
[8](https://forum.keycloak.org/t/automatically-assign-groups-roles-to-user-before-the-user-gets-created/27478)
[9](https://docs.redhat.com/en/documentation/red_hat_build_of_keycloak/22.0/html/server_administration_guide/assigning_permissions_using_roles_and_groups)
[10](https://en.fme.de/blog/fortifying-federated-access-to-aws-via-oidc/)
[11](https://docs.ceph.com/en/octopus/radosgw/keycloak/)
[12](https://docs.getunleash.io/single-sign-on/how-to-setup-sso-keycloak-group-sync)
[13](https://docs.ceph.com/en/latest/_sources/radosgw/STS.rst.txt)
[14](https://developer.radiantlogic.com/ia/version-1.6/configuration/authentication-configuration/)
[15](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html)
[16](https://www.redbooks.ibm.com/redpapers/pdfs/redp5715.pdf)
[17](https://community.ibm.com/community/user/security/blogs/deepak-thorat/2024/03/20/ceph-ISV-integration-using-Open-ID-Connect)
[18](https://stackoverflow.com/questions/62202266/include-groups-along-with-roles-in-keycloak-token)
[19](https://docs.redhat.com/en/documentation/red_hat_ceph_storage/4/html/developer_guide/examples-using-the-secure-token-service-apis_dev)
[20](https://wiki.osnexus.com/index.php?title=KeyCloak_Integration)
