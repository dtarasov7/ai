Ниже — пример “полного” Python-скрипта: он получает токены у Keycloak по password grant, автоматически **обновляет access token по refresh_token**, и при необходимости заново логинится; далее использует текущий access token как `WebIdentityToken` для `AssumeRoleWithWebIdentity` в Ceph RGW STS, а затем делает S3-запросы временными ключами. Обновление делается стандартным `grant_type=refresh_token` на том же token endpoint Keycloak.[1][2]

## Python3: Keycloak ROPC + refresh + Ceph AssumeRoleWithWebIdentity

```python
#!/usr/bin/env python3
import time
import requests
import boto3
from botocore.exceptions import ClientError

# ---------- Config ----------
KEYCLOAK_BASE = "https://keycloak"
REALM = "test"
CLIENT_ID = "ceph-s3"
CLIENT_SECRET = ""  # если client confidential -> впишите secret, иначе оставьте пустым
USERNAME = "user1"
PASSWORD = "Passw0rd!"

RGW_ENDPOINT = "https://ceph"
ROLE_ARN = "arn:aws:iam:::role/role-group1"
ROLE_SESSION_NAME = "user1"

# ---------- Keycloak token manager ----------
class KeycloakTokenManager:
    def __init__(self):
        self.access_token = None
        self.refresh_token = None
        self.access_exp = 0  # epoch seconds, with safety margin

    @property
    def token_url(self):
        return f"{KEYCLOAK_BASE}/realms/{REALM}/protocol/openid-connect/token"

    def _post(self, data):
        if CLIENT_SECRET:
            data["client_secret"] = CLIENT_SECRET
        r = requests.post(
            self.token_url,
            headers={"content-type": "application/x-www-form-urlencoded"},
            data=data,
            timeout=15,
        )
        r.raise_for_status()
        return r.json()

    def login_password(self):
        j = self._post({
            "grant_type": "password",
            "client_id": CLIENT_ID,
            "username": USERNAME,
            "password": PASSWORD,
        })
        self.access_token = j["access_token"]
        self.refresh_token = j.get("refresh_token")
        # expires_in = seconds; берём с запасом 15 секунд
        self.access_exp = int(time.time()) + int(j.get("expires_in", 60)) - 15

    def refresh(self):
        if not self.refresh_token:
            # refresh_token не выдан — значит просто перелогиниться
            self.login_password()
            return
        j = self._post({
            "grant_type": "refresh_token",
            "client_id": CLIENT_ID,
            "refresh_token": self.refresh_token,
        })
        self.access_token = j["access_token"]
        # Keycloak может выдать новый refresh_token (часто так и делает) — сохраняем. [web:189]
        self.refresh_token = j.get("refresh_token", self.refresh_token)
        self.access_exp = int(time.time()) + int(j.get("expires_in", 60)) - 15

    def get_access_token(self):
        now = time.time()
        if not self.access_token:
            self.login_password()
        elif now >= self.access_exp:
            # access token истёк/почти истёк -> пробуем refresh_token grant [web:189]
            try:
                self.refresh()
            except requests.HTTPError:
                # refresh token мог истечь -> заново login_password (обычный подход)
                self.login_password()
        return self.access_token

# ---------- Ceph STS + S3 ----------
def assume_role_with_web_identity(jwt_token: str):
    sts = boto3.client("sts", endpoint_url=RGW_ENDPOINT, region_name="")
    resp = sts.assume_role_with_web_identity(
        RoleArn=ROLE_ARN,
        RoleSessionName=ROLE_SESSION_NAME,
        DurationSeconds=3600,
        WebIdentityToken=jwt_token,
    )
    return resp["Credentials"]

def s3_client_from_creds(c):
    return boto3.client(
        "s3",
        endpoint_url=RGW_ENDPOINT,
        region_name="",
        aws_access_key_id=c["AccessKeyId"],
        aws_secret_access_key=c["SecretAccessKey"],
        aws_session_token=c["SessionToken"],
    )

def ok_or_denied(desc, fn):
    try:
        fn()
        print(f"OK  : {desc}")
    except ClientError as e:
        err = e.response.get("Error", {})
        print(f"FAIL: {desc} -> {err.get('Code')}: {err.get('Message')}")

def main():
    km = KeycloakTokenManager()

    # 1) получить (или обновить) JWT
    jwt = km.get_access_token()

    # 2) обменять JWT на временные S3 креды в Ceph RGW STS [web:12]
    creds = assume_role_with_web_identity(jwt)

    # 3) проверить доступ в S3 временными кредами
    s3 = s3_client_from_creds(creds)

    ok_or_denied("list b1", lambda: s3.list_objects_v2(Bucket="b1"))
    ok_or_denied("put b1/x.txt", lambda: s3.put_object(Bucket="b1", Key="x.txt", Body=b"data"))

    ok_or_denied("list b2", lambda: s3.list_objects_v2(Bucket="b2"))
    ok_or_denied("put b2/x.txt", lambda: s3.put_object(Bucket="b2", Key="x.txt", Body=b"data"))

if __name__ == "__main__":
    main()
```

### Что в итоге обновляется и зачем
- JWT (access token) обновляется через `grant_type=refresh_token`, чтобы не заставлять пользователя вводить пароль заново; это стандартный способ обновления токена в Keycloak.[1]
- Вызов `AssumeRoleWithWebIdentity` можно делать каждый раз “перед работой” или только когда истекают временные S3 креды (у STS тоже есть срок действия). Ceph RGW STS поддерживает выдачу временных credentials после web identity.[2]

Если нужно, можно сделать цикл: периодически обновлять JWT и пере-assume роль, чтобы непрерывно работать с S3 часами/сутками.

[1](https://stackoverflow.com/questions/51386337/refresh-access-token-via-refresh-token-in-keycloak)
[2](https://docs.ceph.com/en/latest/radosgw/STS/)
[3](https://www.keycloak.org/securing-apps/token-exchange)
[4](https://stackoverflow.com/questions/58621091/keycloak-client-credentials-grant-type-with-refresh-token)
[5](https://quangphan.hashnode.dev/introduction-to-keycloaks-oauth-20-functionalities)
[6](https://www.keycloak.org/securing-apps/oidc-layers)
[7](https://www.youtube.com/watch?v=MeXzVS4QZ4Q)
[8](https://devcodef1.com/news/1124676/keycloak-apis-for-refresh-tokens-and-authorization-codes)
[9](https://developer.konghq.com/plugins/openid-connect/examples/refresh-token/)
[10](https://www.reddit.com/r/KeyCloak/comments/19ejkio/keycloak_question_regarding_refreshing_expired/)
[11](https://github.com/oauth2-proxy/oauth2-proxy/issues/1409)
[12](https://docs.h2o.ai/mlops/v0.65.1/py-client/py-client-examples/keycloak-authentication-methods)
[13](https://dev.to/mohammedalics/seamless-migration-to-keycloak-refresh-token-4m4f)
[14](https://stackoverflow.com/questions/66130404/keycloak-refresh-external-idp-token)
[15](https://github.com/keycloak/keycloak/issues/8785)
[16](https://huongdanjava.com/get-access-token-using-refresh-token-with-keycloak.html)
[17](https://github.com/keycloak/keycloak/issues/10013)
[18](https://developers.redhat.com/blog/authentication-and-authorization-using-the-keycloak-rest-api)
[19](https://github.com/keycloak/keycloak/discussions/8526)
[20](https://forum.dataspace.copernicus.eu/t/how-do-we-use-the-refresh-token-value-in-the-response-to-a-keycloak-token-request/331)
[21](https://blog.devgenius.io/oauth-2-0-resource-owner-password-credentials-implementation-d616a33aecb0)
