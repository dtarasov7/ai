Ниже — “полный” bash-скрипт, который (1) логинится в Keycloak Admin API через `kcadm.sh`, (2) создаёт realm `test`, client `ceph-s3` с включённым **Direct Access Grants**, группы `group1/group2`, пользователей `user1/user2`, добавляет их в группы, (3) добавляет mapper “Group Membership” → claim `groups` в **access token** (формат `["/group1"]`), и (4) получает access token для `user1` по password grant. Команды `kcadm.sh` для создания realm/users/groups описаны в документации Admin CLI Keycloak.[1][2]

> Требования: `kcadm.sh`, `curl`, `jq` в PATH.

```bash
#!/usr/bin/env bash
set -euo pipefail

# ---- Settings (подставьте под себя) ----
KC_URL="${KC_URL:-https://keycloak}"
KC_BIN="${KC_BIN:-kcadm.sh}"

ADMIN_REALM="${ADMIN_REALM:-master}"
ADMIN_USER="${ADMIN_USER:-admin}"
ADMIN_PASS="${ADMIN_PASS:-admin}"

REALM="test"
CLIENT_ID="ceph-s3"

U1="user1"
U2="user2"
PASS1="Passw0rd!"
PASS2="Passw0rd!"

G1="group1"
G2="group2"

# ---- Helpers ----
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing binary: $1" >&2; exit 1; }; }
need "$KC_BIN"; need curl; need jq

kc_login() {
  "$KC_BIN" config credentials \
    --server "$KC_URL" \
    --realm "$ADMIN_REALM" \
    --user "$ADMIN_USER" \
    --password "$ADMIN_PASS"
}

realm_exists() {
  "$KC_BIN" get "realms/$REALM" >/dev/null 2>&1
}

create_realm() {
  "$KC_BIN" create realms -s realm="$REALM" -s enabled=true
}

create_group() {
  local name="$1"
  "$KC_BIN" create groups -r "$REALM" -s name="$name"
}

create_user() {
  local username="$1"
  "$KC_BIN" create users -r "$REALM" -s username="$username" -s enabled=true
}

set_password() {
  local username="$1" password="$2"
  "$KC_BIN" set-password -r "$REALM" --username "$username" --new-password "$password" --temporary=false
}

get_user_id() {
  local username="$1"
  "$KC_BIN" get users -r "$REALM" -q username="$username" --fields id --format csv | tail -n1
}

get_group_id() {
  local groupname="$1"
  # Берём первый точный match по name из CSV
  "$KC_BIN" get groups -r "$REALM" -q search="$groupname" --fields id,name --format csv \
    | awk -F, -v g="$groupname" '$2==g{print $1}' | head -n1
}

add_user_to_group() {
  local user_id="$1" group_id="$2"
  # Этот паттерн (update users/<uid>/groups/<gid>) используется для добавления пользователя в группу. [web:90]
  "$KC_BIN" update "users/$user_id/groups/$group_id" -r "$REALM" -s realm="$REALM"
}

create_client_confidential_password_grant() {
  "$KC_BIN" create clients -r "$REALM" \
    -s clientId="$CLIENT_ID" \
    -s protocol="openid-connect" \
    -s enabled=true \
    -s publicClient=false \
    -s directAccessGrantsEnabled=true \
    -s standardFlowEnabled=false \
    -s serviceAccountsEnabled=false \
    -s 'redirectUris=["*"]'
}

get_client_uuid() {
  "$KC_BIN" get clients -r "$REALM" -q clientId="$CLIENT_ID" --fields id --format csv | tail -n1
}

get_client_secret() {
  local cid_uuid="$1"
  "$KC_BIN" get "clients/$cid_uuid/client-secret" -r "$REALM" --fields value --format csv | tail -n1
}

add_groups_mapper_to_client() {
  local cid_uuid="$1"
  # Создание protocol mapper (GroupMembershipMapper) через clients/<id>/protocol-mappers/models. [web:90][web:155]
  "$KC_BIN" create "clients/$cid_uuid/protocol-mappers/models" -r "$REALM" \
    -s name="groups" \
    -s protocol="openid-connect" \
    -s protocolMapper="oidc-group-membership-mapper" \
    -s 'config."claim.name"="groups"' \
    -s 'config."full.path"="true"' \
    -s 'config."access.token.claim"="true"' \
    -s 'config."id.token.claim"="false"' \
    -s 'config."userinfo.token.claim"="false"'
}

get_token_password_grant() {
  local username="$1" password="$2" client_secret="$3"
  curl -s "$KC_URL/realms/$REALM/protocol/openid-connect/token" \
    -H 'content-type: application/x-www-form-urlencoded' \
    --data-urlencode "grant_type=password" \
    --data-urlencode "client_id=$CLIENT_ID" \
    --data-urlencode "client_secret=$client_secret" \
    --data-urlencode "username=$username" \
    --data-urlencode "password=$password"
}

# ---- Main ----
kc_login

if realm_exists; then
  echo "Realm $REALM already exists; continuing."
else
  echo "Creating realm $REALM"
  create_realm
fi

echo "Creating groups $G1, $G2 (may fail if already exist)"
create_group "$G1" || true
create_group "$G2" || true

echo "Creating users $U1, $U2 (may fail if already exist)"
create_user "$U1" || true
create_user "$U2" || true

echo "Setting passwords"
set_password "$U1" "$PASS1"
set_password "$U2" "$PASS2"

echo "Creating client $CLIENT_ID (may fail if already exists)"
create_client_confidential_password_grant || true

CID_UUID="$(get_client_uuid)"
echo "Client UUID: $CID_UUID"

# Добавляем mapper groups (может уже существовать — тогда упадёт; для простоты игнорируем)
echo "Adding groups mapper to client (ignore error if exists)"
add_groups_mapper_to_client "$CID_UUID" || true

# Получаем IDs и добавляем пользователей в группы
U1_ID="$(get_user_id "$U1")"
U2_ID="$(get_user_id "$U2")"
G1_ID="$(get_group_id "$G1")"
G2_ID="$(get_group_id "$G2")"

echo "user1 id=$U1_ID, group1 id=$G1_ID"
echo "user2 id=$U2_ID, group2 id=$G2_ID"

add_user_to_group "$U1_ID" "$G1_ID"
add_user_to_group "$U2_ID" "$G2_ID"

# Client secret нужен, т.к. publicClient=false (confidential). [web:151]
CLIENT_SECRET="$(get_client_secret "$CID_UUID")"
echo "Client secret (keep safe): $CLIENT_SECRET"

echo "Getting token for $U1 via password grant"
TOKEN_JSON="$(get_token_password_grant "$U1" "$PASS1" "$CLIENT_SECRET")"

echo "$TOKEN_JSON" | jq -r '.access_token' > /tmp/user1.access_token.jwt
echo "Saved user1 access token to /tmp/user1.access_token.jwt"

echo "Decoded JWT payload (groups should include /group1):"
python3 - <<'PY'
import json, base64, sys
jwt = open("/tmp/user1.access_token.jwt","r").read().strip()
payload = jwt.split(".")[1] + "==="
payload = base64.urlsafe_b64decode(payload).decode()
print(json.dumps(json.loads(payload), indent=2))
PY
```

### Что будет “правильным результатом”
- В payload access token у `user1` должен быть claim `groups` со значением `["/group1"]` (из-за `full.path=true`).[3]
- После этого такой JWT можно отдавать в Ceph RGW STS `AssumeRoleWithWebIdentity`, а trust policy роли сравнивает claim `groups` с `"/group1"`/`"/group2"`.[4]

Если нужно — можно расширить скрипт: сразу получить токен и для `user2`, и вывести только `groups` claim (без полного payload).

[1](https://wjw465150.gitbooks.io/keycloak-documentation/content/server_admin/topics/admin-cli.html)
[2](https://www.keycloak.org/docs-api/latest/rest-api/index.html)
[3](https://www.keycloak.org/docs-api/latest/javadocs/org/keycloak/protocol/oidc/mappers/GroupMembershipMapper.html)
[4](https://docs.ceph.com/en/latest/radosgw/STS/)
[5](https://www.keycloak.org/docs/latest/server_admin/index.html)
[6](https://github.com/google/fhir-access-proxy/blob/main/docker/keycloak/keycloak_setup.sh)
[7](https://stackoverflow.com/questions/47158634/add-protocol-mapper-to-keycloak-using-kcadm-sh)
[8](https://stackoverflow.com/questions/57265755/how-to-get-client-secret-from-keycloak-using-curl)
[9](https://www.adaltas.com/en/2023/07/04/cdp-user-management-keycloak/)
[10](https://dev.to/nsrinivasan/keycloak-client-credentials-keeping-access-safe-4eo4)
[11](https://docs.redhat.com/en/documentation/red_hat_build_of_keycloak/26.2/html/server_administration_guide/admin_cli)
[12](https://github.com/wpic/sample-keycloak-getting-token)
[13](https://www.itix.fr/blog/secure-quarkus-api-with-keycloak/)
[14](https://gist.github.com/luciddreamz/83a888eedd9274b4045a3ab8af064faa)
[15](https://cray-hpe.github.io/docs-csm/en-13/operations/security_and_authentication/keycloak_user_management_with_kcadm/)
[16](https://kc-api.github.io/quick-reference/)
[17](https://docs.redhat.com/en/documentation/red_hat_single_sign-on_continuous_delivery/2/html/server_administration_guide/the_admin_cli)
[18](https://stackoverflow.com/questions/50256433/obtaining-an-access-token-via-curl)
[19](https://www.keycloak.org/securing-apps/oidc-layers)
[20](https://github.com/keycloak/keycloak/discussions/20919)
[21](https://wooono.tistory.com/725)
[22](https://www.reddit.com/r/KeyCloak/comments/1co3qes/question_about_keycloak_token_endpoint/)
