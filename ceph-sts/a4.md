Для “под ключ” теста удобнее всего включить в Keycloak **Direct Access Grants** (password grant) на клиенте `ceph-s3`, добавить mapper “groups → access token”, а в Python-скрипте: (1) получить JWT по логину/паролю из Keycloak token endpoint, (2) вызвать `AssumeRoleWithWebIdentity` на Ceph RGW STS, (3) выполнить S3-операции и увидеть `AccessDenied` там, где нужно.[1][2]

Ниже — конкретная настройка Keycloak + пример Python, без ручной вставки JWT.

## Настройки Keycloak (v25) для password grant

### 1) Клиент `ceph-s3`: включить Direct Access Grants

Если клиент уже создан — просто обновите его, включив `directAccessGrantsEnabled=true` (это обязательное условие для `grant_type=password`, иначе будет “Client not allowed for direct access grants”).[3][1]

```bash
export KC_URL="https://keycloak"
export KC_BIN="/opt/keycloak/bin/kcadm.sh"

CID=$($KC_BIN get clients -r test -q clientId=ceph-s3 --fields id --format csv | tail -n1)

$KC_BIN update "clients/$CID" -r test \
  -s directAccessGrantsEnabled=true \
  -s standardFlowEnabled=false
```

`standardFlowEnabled=false` здесь только чтобы не путаться; для password grant он не нужен.[1]

### 2) Добавить groups claim в **access token** (формат `["/group1"]`)

Создаём “Group Membership” protocol mapper на клиенте `ceph-s3`, claim name `groups`, full path = true, и включаем только access token claim.[4][5]

```bash
$KC_BIN create "clients/$CID/protocol-mappers/models" -r test \
  -s name="groups" \
  -s protocol="openid-connect" \
  -s protocolMapper="oidc-group-membership-mapper" \
  -s 'config."claim.name"="groups"' \
  -s 'config."full.path"="true"' \
  -s 'config."access.token.claim"="true"' \
  -s 'config."id.token.claim"="false"' \
  -s 'config."userinfo.token.claim"="false"'
```

### 3) Проверка: получить JWT по паролю

Token endpoint у realm выглядит так: `/realms/<realm>/protocol/openid-connect/token`.[6]

```bash
curl -s "$KC_URL/realms/test/protocol/openid-connect/token" \
  -H 'content-type: application/x-www-form-urlencoded' \
  -d 'grant_type=password' \
  -d 'client_id=ceph-s3' \
  -d 'username=user1' \
  -d 'password=Passw0rd!' | jq -r .access_token
```

В decoded payload ожидайте `"groups": ["/group1"]` для `user1` и `["/group2"]` для `user2`.[4]

## Python “под ключ”: Keycloak → STS → S3

Зависимости:
```bash
pip install boto3 requests
```

Скрипт:
- получает access token из Keycloak по паролю (ROPC)
- вызывает `AssumeRoleWithWebIdentity` на `https://ceph` (STS в RGW)[2][7]
- создаёт S3 client на временных кредах и проверяет операции на `b1/b2`

```python
#!/usr/bin/env python3
import requests
import boto3
from botocore.exceptions import ClientError

KEYCLOAK = "https://keycloak"
REALM = "test"
CLIENT_ID = "ceph-s3"

RGW_ENDPOINT = "https://ceph"

ROLE_ARN_GROUP1 = "arn:aws:iam:::role/role-group1"
ROLE_ARN_GROUP2 = "arn:aws:iam:::role/role-group2"

def get_access_token(username: str, password: str) -> str:
    url = f"{KEYCLOAK}/realms/{REALM}/protocol/openid-connect/token"
    r = requests.post(
        url,
        headers={"content-type": "application/x-www-form-urlencoded"},
        data={
            "grant_type": "password",
            "client_id": CLIENT_ID,
            "username": username,
            "password": password,
        },
        timeout=15,
    )
    r.raise_for_status()
    return r.json()["access_token"]

def assume(role_arn: str, jwt_token: str, session_name: str):
    sts = boto3.client("sts", endpoint_url=RGW_ENDPOINT)
    resp = sts.assume_role_with_web_identity(
        RoleArn=role_arn,
        RoleSessionName=session_name,
        WebIdentityToken=jwt_token,
        DurationSeconds=3600,
    )
    c = resp["Credentials"]
    return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]

def s3_client(access_key, secret_key, session_token):
    return boto3.client(
        "s3",
        endpoint_url=RGW_ENDPOINT,
        aws_access_key_id=access_key,
        aws_secret_access_key=secret_key,
        aws_session_token=session_token,
    )

def try_op(desc, fn):
    try:
        fn()
        print(f"OK  : {desc}")
        return True
    except ClientError as e:
        err = e.response.get("Error", {})
        print(f"FAIL: {desc} -> {err.get('Code')}: {err.get('Message')}")
        return False

def test_user(username, password, role_arn):
    jwt = get_access_token(username, password)
    ak, sk, st = assume(role_arn, jwt, session_name=username)
    s3 = s3_client(ak, sk, st)

    try_op(f"{username} list b1", lambda: s3.list_objects_v2(Bucket="b1"))
    try_op(f"{username} put b1/x.txt", lambda: s3.put_object(Bucket="b1", Key="x.txt", Body=b"data"))

    try_op(f"{username} list b2", lambda: s3.list_objects_v2(Bucket="b2"))
    try_op(f"{username} put b2/x.txt", lambda: s3.put_object(Bucket="b2", Key="x.txt", Body=b"data"))

if __name__ == "__main__":
    # user1 ∈ group1 => assume role-group1 => allow b1, deny b2
    test_user("user1", "Passw0rd!", ROLE_ARN_GROUP1)

    # user2 ∈ group2 => assume role-group2 => allow b2, deny b1
    test_user("user2", "Passw0rd!", ROLE_ARN_GROUP2)
```

## Что ещё нужно на стороне Ceph (напоминание)

На Ceph RGW v17 trust policy ролей должна сравнивать `groups` с `"/group1"` и `"/group2"` (так как `full.path=true`) и роль должна разрешать именно `sts:AssumeRoleWithWebIdentity`.[2][4]

Если дадите issuer URL вашего Keycloak (точный) и скажете, какой claim Keycloak ставит в `aud` (иногда это `aud`, иногда удобнее использовать `azp`), можно подогнать trust policy ролей под ваш фактический токен, чтобы `AssumeRoleWithWebIdentity` прошёл с первого раза.

[1](https://github.com/marcospereirampj/python-keycloak/issues/240)
[2](https://docs.ceph.com/en/latest/radosgw/STS/)
[3](https://github.com/keycloak/keycloak/discussions/22472)
[4](https://www.keycloak.org/docs-api/latest/javadocs/org/keycloak/protocol/oidc/mappers/GroupMembershipMapper.html)
[5](https://groups.google.com/g/keycloak-user/c/J7gIs2vw3S0)
[6](https://stackoverflow.com/questions/77883850/keycloak-direct-grant-by-password-or-otp)
[7](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sts/client/assume_role_with_web_identity.html)
[8](https://stackoverflow.com/questions/51181444/keycloak-grant-type-password-in-custom-identity-provider)
[9](https://www.youtube.com/watch?v=D7NN_GIv10A)
[10](https://developer.konghq.com/how-to/configure-oidc-with-password-grant/)
[11](https://www.youtube.com/watch?v=daoKlUZFWiM)
[12](https://github.com/keycloak/keycloak/issues/37237)
[13](https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java)
[14](https://stackoverflow.com/questions/58598652/keycloak-admin-cli-setting-client-attributes)
[15](https://www.keycloak.org/docs/latest/authorization_services/index.html)
[16](https://stackoverflow.com/questions/58612310/get-authorization-code-from-keycloak-token-endpoint)
[17](https://stackoverflow.com/questions/78114433/using-the-java-keycloak-admin-client-how-do-i-turn-on-client-authentication-and)
[18](https://www.keycloak.org/docs/latest/server_admin/index.html)
[19](https://www.keycloak.org/docs-api/22.0.5/javadocs/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.html)
[20](https://wjw465150.gitbooks.io/keycloak-documentation/content/server_admin/topics/admin-cli.html)
[21](https://github.com/keycloak/keycloak/issues/26116)
[22](https://www.keycloak.org/docs-api/latest/javadocs/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.html)
[23](https://github.com/keycloak/keycloak/discussions/20785)
[24](https://zzamzam.dev/posts/2022-03-17-keycloak-client-settings/)
