Конечно, давайте разберем оба ваших вопроса. Это классическая и очень полезная задача для связки Prometheus + Grafana.

### Часть 1: Таблица изменений версий (с предыдущей версией)

Создать такую таблицу — это нетривиальная задача, которая требует сложного PromQL-запроса. Нам нужно "поймать" момент изменения и в этот же момент "заглянуть в прошлое", чтобы узнать, какая версия была до этого.

**1. Создайте новую панель в Grafana**

*   На вашем дашборде нажмите "Add panel" -> "Add new panel".
*   В качестве визуализации выберите **Table**.

**2. Введите PromQL-запрос**

В редакторе запросов (Query) вставьте следующий код. Этот запрос состоит из двух частей, соединенных оператором `and`.

```promql
# Запрос для обнаружения изменений версий и отображения предыдущей версии
(
  # Часть A: Находит моменты времени, когда серия метрик изменилась.
  # Сравнение '!=' сработает, так как при смене метки 'version' изменится хэш всей серии.
  # Мы сравниваем текущее значение с тем, что было 1 минуту назад, для той же комбинации хоста и приложения.
  app != on(hostname, appname) app offset 1m
)
and on(hostname, appname) group_left(previous_version)
(
  # Часть B: Берет метрику из прошлого (1 минута назад) и создает новую метку 'previous_version',
  # копируя в нее значение из старой метки 'version'.
  label_replace(app offset 1m, "previous_version", "$1", "version", "(.*)")
)
```

**Важное замечание:** Значение `offset` (в примере `1m`) должно быть больше или равно вашему интервалу сбора метрик (`scrape_interval`) в Prometheus. Если Prometheus опрашивает цели каждые 30 секунд, `1m` будет достаточно. Если каждые 5 минут, используйте `6m`.

**3. Настройте преобразования (Transform)**

Сам по себе запрос вернет сырые данные. Чтобы сделать таблицу читаемой, используем преобразования.

*   Перейдите на вкладку **Transform** под полем с запросом.
*   **Преобразование 1: "Organize fields"**
    *   Используйте это преобразование, чтобы переименовать, переупорядочить и скрыть ненужные столбцы.
    *   **Скройте** системные поля, такие как `__name__` и `Value`, они нам не нужны.
    *   **Переименуйте** поля для наглядности:
        *   `Time` -> `Время изменения`
        *   `hostname` -> `Хост`
        *   `appname` -> `Приложение`
        *   `version` -> `Новая версия`
        *   `previous_version` -> `Предыдущая версия`
    *   **Перетащите** поля, чтобы установить желаемый порядок.

**Результат:**
Вы получите таблицу, которая заполняется только в моменты, когда версия ПО меняется, и показывает всю необходимую информацию.

| Время изменения | Хост | Приложение | Новая версия | Предыдущая версия |
| :--- | :--- | :--- | :--- | :--- |
| 2025-10-10 05:15:00 | web-server-01 | nginx | 1.21.6 | 1.21.5 |
| 2025-10-09 18:30:00 | api-server-05 | backend-service | 2.4.1 | 2.4.0 |

---

### Часть 2: Визуальная история версий во времени

Для этой задачи идеально подходит специальная панель Grafana, предназначенная для отображения состояний, а не чисел.

#### Способ 1: Панель "State Timeline" (Рекомендуемый)

Эта панель показывает изменения строковых значений в виде цветных полос на временной шкале.

**1. Создайте новую панель**

*   Нажмите "Add panel" -> "Add new panel".
*   Выберите тип визуализации **State Timeline**.

**2. Введите PromQL-запрос**

Запрос здесь очень простой. Вам просто нужна сама метрика.

```promql
# Просто запрашиваем метрику. Можно добавить фильтры.
app{appname="nginx"}
```

Этот запрос вернет все временные ряды для приложения `nginx` на всех хостах.

**3. Настройте опции панели**

*   В настройках панели справа (Panel options) найдите секцию **"State timeline"**.
*   В поле **"Legend"** (Легенда) введите `{{hostname}}`. Это покажет, какая линия какому хосту принадлежит.
*   В поле **"Value"** (Значение) выберите опцию **"From field"** и укажите `version`. Это заставит Grafana отображать текст из метки `version` прямо на графике.

**Результат:**
Вы получите график, где для каждого хоста будет своя "дорожка". На ней будут цветные блоки, каждый из которых соответствует определенной версии ПО и длится ровно столько, сколько эта версия была активна. Это очень наглядно показывает историю развертываний.

#### Способ 2: Аннотации на существующих графиках

Это очень мощный метод, который позволяет видеть моменты смены версий прямо поверх других графиков (например, CPU, память, RPS).

**1. Перейдите в настройки дашборда**

*   Нажмите на иконку шестеренки в правом верхнем углу дашборда.
*   Перейдите в раздел **"Annotations"**.

**2. Создайте новую аннотацию**

*   Нажмите "New annotation".
*   **Name:** Дайте ей имя, например, "Развертывания".
*   **Data source:** Выберите ваш Prometheus.
*   **Query:** Вставьте тот же запрос, который мы использовали для обнаружения изменений в Части 1:
    ```promql
    app != on(hostname, appname) app offset 1m
    ```
*   **Text:** В полях "Text" и "Tags" вы можете использовать шаблоны для отображения полезной информации. Например, в поле **Text** введите:
    `{{appname}} на {{hostname}} обновлен до v{{version}}`

**Результат:**
Теперь на всех графиках вашего дашборда появятся вертикальные линии в моменты смены версий. При наведении на линию вы увидите текст, который вы задали, например: "nginx на web-server-01 обновлен до v1.21.6". Это позволяет мгновенно сопоставлять всплески нагрузки или ошибки с выкаткой новой версии ПО.
