Вот готовый промт, который можно дать модели, чтобы она написала эту программу сразу, “с нуля”:

***

Сделай, пожалуйста, полноценную консольную TUI‑утилиту на Python для просмотра больших JSON/JSONL файлов в виде интерактивного дерева (терминальный интерфейс на базе curses).

## Назначение

Нужно приложение для разработчика/аналитика логов, которое позволяет удобно просматривать очень большие JSON/JSONL файлы (сотни тысяч и миллионы объектов) без загрузки всего в память, с поиском и фильтрацией полей.

## Технические требования

1. **Язык и зависимости**
   - Python 3.10+.
   - Только стандартная библиотека (можно использовать `curses`, `json`, `pathlib`, `re`, `signal`, `typing`, `os`, `sys`).
   - Один файл: `json_tui_viewer_secure.py`.

2. **Форматы входных данных**
   - Обычный JSON: один большой объект или массив объектов.
   - JSONL: по одному JSON‑объекту на строку.
   - Программа должна:
     - Пытаться сначала разобрать файл как обычный JSON.
     - При неудаче — интерпретировать как JSONL (каждая непустая строка — отдельный объект).

3. **Архитектура**
   - Класс `JsonNode` — узел дерева:
     - Поля: `key`, `value`, `parent`, `depth`, `index`, `expanded`, `children`.
     - Ленивое построение `children` (только при необходимости).
     - Методы: `is_leaf()`, `build_children()`, `toggle()`, `get_root_object()`, `get_relative_path_with_state()`, `expand_all(node_counter)`, `collapse_all()`, `collect_leaf_fields()`.
   - Класс `LazyJsonFile` — ленивый доступ к объектам:
     - Индексация позиций объектов в файле (смещения для JSONL).
     - LRU‑кэш последних N объектов (например, 200).
     - Методы: `__len__()`, `__getitem__(index)`, `search_by_field(field_name, pattern_str, max_results)`, `search_all_fields(pattern_str, max_results)`.
   - Основная TUI‑логика:
     - Главная функция `main(stdscr, json_file, filename)`, оборачиваемая через `curses.wrapper`.
     - Отдельные функции:
       - `build_visible_list(root, filter_fields)`
       - `should_show_node(node, filter_fields)`
       - `draw(...)` — отрисовка экрана.
       - `show_full_value_viewer(stdscr, node)` — fullscreen просмотр значения листового узла.
       - `show_field_selector(stdscr, available_fields, preselected)` — выбор полей для фильтрации.
       - `input_string(stdscr, prompt, y, x, max_len)` — строковый ввод.
       - `load_object_into_tree(json_file, root, obj_idx, loaded_objects)` — ленивая подгрузка объекта в дерево.
       - `ensure_next_objects_loaded(...)` — упреждающая подгрузка следующих объектов.
       - `navigate_by_path_with_state(root_obj, rel_path)`, `expand_path_to_node(node)`, `find_node_by_path(root_obj, path_str)` — навигация между объектами с сохранением относительного пути.
   - Точка входа `run()`:
     - Разбор аргумента командной строки (путь к файлу).
     - Валидация пути и запуск TUI.

4. **Поведение TUI**

   Экран:
   - Верхняя строка: имя файла, количество объектов, индикатор фильтра.
   - Основная область: дерево JSON (одна строка — один узел).
   - Нижние строки: статус/сообщения и подсказки по управлению.

   Отображение дерева:
   - Отступ по `depth`, маркер `+`/`-` для сворачиваемых узлов, пробел для листьев.
   - На корневых объектах (записях) индекс: `[N]`.
   - Для dict: `{...} (X keys)`.
   - Для list: `[...] (X items)`.
   - Строки обрезаются по ширине терминала с добавлением `...`.

   Управление (клавиши):
   - Стрелки/vi:
     - `↑` / `k` — вверх.
     - `↓` / `j` — вниз (при приближении к концу — подгружать следующие объекты).
     - `→` / `l` — развернуть узел (если не лист).
     - `←` — свернуть узел; если уже свернут — перейти к родителю.
   - Enter:
     - На листовом узле — открыть полноэкранный просмотр значения с прокруткой (строки и столбцы).
     - На нелистовом — toggle (expand/collapse).
   - Объекты:
     - `a` — развернуть весь текущий объект (только этот объект), рекурсивно, с лимитом по числу узлов.
     - `z` — свернуть текущий объект целиком.
     - `A` — развернуть *все уже загруженные* объекты (не загружать весь файл!).
     - `Z` — свернуть все объекты.
   - Переход между объектами:
     - `g` — перейти к объекту по номеру.
     - `Home` — первый объект.
     - `End` — последний объект.
     - `PgDn` — следующий объект с сохранением относительного пути к полю (если возможно).
     - `PgUp` — предыдущий объект с сохранением относительного пути.
   - Поиск:
     - `s` — поиск по текущему полю:
       - Запрос строки (подсказка “regex”).
       - Поиск по всем объектам только по этому полю.
       - Результаты — список `JsonNode`, навигация по ним `n` / `p`.
     - `F` — глобальный поиск:
       - Поиск по всем листовым полям.
       - Возврат списка совпадений и множества имен полей, в которых были найдено.
       - Автоматическое включение фильтра по этим полям.
       - Навигация по результатам `n` / `p`.
   - Фильтрация:
     - `f` — диалог выбора полей:
       - Список уникальных листовых полей (по первому объекту или по уже загруженным).
       - Переключение пробелом, Enter — применить, Esc — отмена.
       - Фильтрация так, чтобы:
         - Лист отображается только если его ключ в фильтре.
         - Внутренние узлы отображаются, если где-то в поддереве есть подходящий лист.
   - Выход:
     - `q` / `Esc` — выход.

5. **Производительность и ленивость**

   - При старте:
     - Если одиночный JSON — загрузить целиком, построить корневой объект.
     - Если JSONL — построить только индекс смещений (позиции строк), сами объекты не загружать.
   - Подгрузка:
     - При первом показе — предзагрузить только `max(list_height + 10, 20)` объектов.
     - При прокрутке вниз, если курсор приближается к концу списка видимых узлов — подгружать следующую пачку (например, по 5 объектов).
   - Кэш:
     - Не хранить всех объектов в памяти.
     - LRU‑кэш на ~200 объектов: при переполнении выкидывать самые старые.
   - `expand_all`:
     - Работает только по уже загруженным объектам.
     - Учитывать лимит общего количества узлов, чтобы не съесть всю память.

6. **Безопасность**

   Реализовать защиту от следующих рисков (без использования внешних библиотек):

   1) **JSON Bomb / DoS по содержимому, а не по размеру файла**:
      - Ввести функцию `validate_json_object(obj, depth=0, path="root")`, которая рекурсивно проверяет объект и выбрасывает `SecurityError`, если:
        - Глубина вложенности > `MAX_JSON_DEPTH` (например, 100).
        - Длина строки > `MAX_STRING_LENGTH` (например, 10 MB).
        - Число содержит > `MAX_NUMBER_DIGITS` цифр (например, 4300 — как защита от CVE‑2020‑10735).
        - Массив содержит > `MAX_ARRAY_ITEMS` элементов (например, 1 000 000).
        - Dict содержит > `MAX_OBJECT_KEYS` ключей (например, 100 000).
      - Эту функцию вызывать:
        - Для одиночного JSON — сразу после `json.load`.
        - Для JSONL — в `__getitem__` после `json.loads(line)` для каждого объекта.
      - Если объект “опасный”:
        - Не падать целиком.
        - Либо выбрасывать `SecurityError` при загрузке одиночного файла.
        - Либо для JSONL:
          - Писать предупреждение в stdout.
          - Возвращать объект‑заглушку вида `{"_error": "Объект N пропущен по соображениям безопасности: ... "}`.

   2) **ReDoS (Regular Expression DoS)**:
      - Пользователь вводит паттерн (строка) для `s` и `F`.
      - Нужно:
        - Скомпилировать regex с ограничением времени (например, через `signal.SIGALRM` на Unix).
        - Ввести функции:
          - `safe_regex_compile(pattern_str, timeout=2)` — компиляция с таймаутом, при истечении — `TimeoutError` и переход на простой поиск подстроки.
          - `safe_regex_search(pattern, text, timeout=2)` — поиск с таймаутом и обрезкой слишком длинных строк (например, до 10 000 символов).
        - Если regex слишком сложный (таймаут или ошибка компиляции) — использовать поиск как `pattern_str.lower() in text.lower()`.

   3) **Resource Exhaustion при `expand_all`**:
      - В `JsonNode.expand_all(node_counter)`:
        - Параметр `node_counter: List[int]` — счётчик уже созданных узлов.
        - Перед созданием новых детей проверять, что `node_counter[0] <= MAX_EXPAND_NODES` (например, 100 000).
        - При превышении — выбросить `SecurityError`.
      - Клавиша `A` должна:
        - НЕ делать цикл `for i in range(len(json_file))` с загрузкой всех объектов.
        - А:
          - Пройти только по `root.children` (уже загруженные объекты).
          - Для каждого вызвать `expand_all(node_counter)`.
          - Вывести в статусе, сколько узлов было развёрнуто.
      - Клавиша `a` — только по текущему объекту с тем же лимитом.

   4) **Path / device safety**:
      - Файл открывается с путём из аргумента командной строки.
      - Ввести `validate_file_path(filepath: str) -> Path`, которая:
        - Нормализует путь через `Path.resolve()`.
        - Проверяет, что файл существует и это обычный файл (`is_file()`).
        - Запрещает пути, начинающиеся с `/dev/`, `/proc/`, `/sys/` (чтение псевдо‑устройств типа `/dev/zero` и т.п.).
      - При нарушении — выбросить `SecurityError` и вывести пользователю понятное сообщение.

7. **Пользовательский опыт**

   - При старте:
     - Понятное сообщение об ошибках (файл не найден, невалидный JSON, опасная структура и т.п.).
   - В статусной строке:
     - Отображать:
       - Индекс текущего объекта.
       - Общее количество объектов.
       - Количество видимых узлов.
       - Позицию курсора (N/M).
       - Краткие сообщения о результатах поиска, фильтров, ошибок безопасности.
   - Диалоговые окна (`input_string`, выбор полей, просмотр значения) должны корректно обрабатывать Esc/`q`.

8. **Качество кода**

   - Обязательно:
     - Читаемые имена переменных и функций.
     - Краткие docstring’и у основных классов и функций.
     - Однострочные комментарии на русском языке только в местах, где логика неочевидна (например, восстановление пути при PgUp/PgDn, защита от DoS, работа кэша).
   - Код должен быть готов к прямому запуску:
     - `python json_tui_viewer_secure.py path/to/file.jsonl`.

***

Сформируй полный исходный код `json_tui_viewer_secure.py`, строго удовлетворя требованиям выше.
