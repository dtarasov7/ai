Вот полный код решения с учетом всех требований:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Двухпанельный файловый менеджер для S3 Ceph
Требуемые пакеты (версии до февраля 2022):
  boto3==1.20.54 (январь 2022)
  botocore==1.23.54 (январь 2022)
  urwid==2.1.2 (октябрь 2020)
"""

import os
import sys
import urwid
import boto3
from botocore.exceptions import ClientError
from datetime import datetime


class S3Manager:
    """Менеджер для работы с S3 Ceph"""
    
    def __init__(self, endpoint_url, access_key, secret_key):
        self.s3_client = boto3.client(
            's3',
            endpoint_url=endpoint_url,
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key
        )
        self.s3_resource = boto3.resource(
            's3',
            endpoint_url=endpoint_url,
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key
        )

    def list_buckets(self):
        """Получить список бакетов"""
        try:
            response = self.s3_client.list_buckets()
            return [bucket['Name'] for bucket in response['Buckets']]
        except ClientError as e:
            return []

    def create_bucket(self, bucket_name):
        """Создать новый бакет"""
        try:
            self.s3_client.create_bucket(Bucket=bucket_name)
            return True
        except ClientError:
            return False

    def delete_bucket(self, bucket_name):
        """Удалить бакет"""
        try:
            self.s3_client.delete_bucket(Bucket=bucket_name)
            return True
        except ClientError:
            return False

    def list_objects(self, bucket_name, prefix=''):
        """Получить список объектов в бакете"""
        try:
            paginator = self.s3_client.get_paginator('list_objects_v2')
            pages = paginator.paginate(Bucket=bucket_name, Prefix=prefix, Delimiter='/')
            
            folders = []
            files = []
            
            for page in pages:
                # Обработка "папок" (префиксов)
                if 'CommonPrefixes' in page:
                    for obj in page['CommonPrefixes']:
                        folders.append({
                            'Key': obj['Prefix'],
                            'Size': 0,
                            'LastModified': None
                        })
                
                # Обработка файлов
                if 'Contents' in page:
                    for obj in page['Contents']:
                        if not obj['Key'].endswith('/') and obj['Key'] != prefix:
                            files.append(obj)
            
            return folders, files
        except ClientError:
            return [], []

    def download_object(self, bucket_name, key, local_path):
        """Скачать объект из S3"""
        try:
            self.s3_client.download_file(bucket_name, key, local_path)
            return True
        except ClientError:
            return False

    def upload_file(self, local_path, bucket_name, key):
        """Загрузить файл в S3"""
        try:
            self.s3_client.upload_file(local_path, bucket_name, key)
            return True
        except ClientError:
            return False

    def copy_object(self, source_bucket, source_key, dest_bucket, dest_key):
        """Копировать объект между бакетами"""
        try:
            copy_source = {'Bucket': source_bucket, 'Key': source_key}
            self.s3_client.copy_object(CopySource=copy_source, Bucket=dest_bucket, Key=dest_key)
            return True
        except ClientError:
            return False

    def delete_object(self, bucket_name, key):
        """Удалить объект из бакета"""
        try:
            self.s3_client.delete_object(Bucket=bucket_name, Key=key)
            return True
        except ClientError:
            return False


class FileSystemBrowser:
    """Браузер локальной файловой системы"""
    
    def __init__(self):
        self.current_path = os.path.expanduser('~')

    def list_directory(self, path=None):
        """Получить список файлов и директорий"""
        if path:
            self.current_path = os.path.abspath(path)
        
        try:
            items = []
            # Добавляем родительскую директорию
            if self.current_path != '/':
                items.append({
                    'name': '..',
                    'is_dir': True,
                    'size': 0,
                    'mtime': None
                })
            
            # Получаем список файлов и директорий
            for item in sorted(os.listdir(self.current_path)):
                full_path = os.path.join(self.current_path, item)
                try:
                    stat = os.stat(full_path)
                    is_dir = os.path.isdir(full_path)
                    items.append({
                        'name': item,
                        'is_dir': is_dir,
                        'size': 0 if is_dir else stat.st_size,
                        'mtime': datetime.fromtimestamp(stat.st_mtime)
                    })
                except (PermissionError, OSError):
                    continue
            
            return items
        except (PermissionError, OSError):
            return []


class SelectableItem(urwid.WidgetWrap):
    """Виджет для отображения выбираемого элемента (файла/папки/объекта)"""
    
    signals = ['click']

    def __init__(self, label, data, is_selectable=True):
        self.label = label
        self.data = data
        self.is_item_selectable = is_selectable
        self.selected = False
        
        # Создаем чекбокс для выделения
        if is_selectable:
            self.checkbox = urwid.CheckBox('')
            urwid.connect_signal(self.checkbox, 'change', self.on_checkbox_change)
            text = urwid.Text(label)
            columns = urwid.Columns([
                ('fixed', 4, self.checkbox),
                text
            ], dividechars=0)
        else:
            columns = urwid.Text('  ' + label)
        
        self.item = urwid.AttrMap(columns, None, focus_map='selected')
        super().__init__(self.item)

    def on_checkbox_change(self, widget, state):
        """Обработчик изменения состояния чекбокса"""
        self.selected = state

    def selectable(self):
        """Виджет можно выбрать"""
        return True

    def keypress(self, size, key):
        """Обработка нажатий клавиш"""
        if key == 'enter':
            urwid.emit_signal(self, 'click')
            return None
        elif key == 'insert' and self.is_item_selectable:
            # Insert - переключение выделения (как в MC)
            self.checkbox.set_state(not self.checkbox.get_state())
            return 'down'  # Переходим к следующему элементу
        elif key == ' ' and self.is_item_selectable:
            # Пробел - переключение выделения без перехода
            self.checkbox.set_state(not self.checkbox.get_state())
            return None
        return super().keypress(size, key)


class InputDialog(urwid.WidgetWrap):
    """Диалоговое окно для ввода текста"""
    
    signals = ['close', 'submit']

    def __init__(self, title, prompt):
        self.edit = urwid.Edit(prompt)
        
        ok_button = urwid.Button('OK')
        cancel_button = urwid.Button('Cancel')
        
        urwid.connect_signal(ok_button, 'click', self.on_ok)
        urwid.connect_signal(cancel_button, 'click', self.on_cancel)
        
        buttons = urwid.Columns([
            urwid.AttrMap(ok_button, None, focus_map='selected'),
            urwid.AttrMap(cancel_button, None, focus_map='selected')
        ], dividechars=2)
        
        pile = urwid.Pile([
            urwid.Text(title, align='center'),
            urwid.Divider(),
            self.edit,
            urwid.Divider(),
            buttons
        ])
        
        fill = urwid.Filler(pile)
        super().__init__(urwid.AttrMap(urwid.LineBox(fill), 'dialog'))

    def on_ok(self, button):
        """Обработчик кнопки OK"""
        text = self.edit.get_edit_text()
        if text.strip():
            urwid.emit_signal(self, 'submit', text.strip())

    def on_cancel(self, button):
        """Обработчик кнопки Cancel"""
        urwid.emit_signal(self, 'close')


class ConfirmDialog(urwid.WidgetWrap):
    """Диалоговое окно подтверждения действия"""
    
    signals = ['close', 'confirm']

    def __init__(self, title, message):
        yes_button = urwid.Button('Yes')
        no_button = urwid.Button('No')
        
        urwid.connect_signal(yes_button, 'click', self.on_yes)
        urwid.connect_signal(no_button, 'click', self.on_no)
        
        buttons = urwid.Columns([
            urwid.AttrMap(yes_button, None, focus_map='selected'),
            urwid.AttrMap(no_button, None, focus_map='selected')
        ], dividechars=2)
        
        pile = urwid.Pile([
            urwid.Text(title, align='center'),
            urwid.Divider(),
            urwid.Text(message),
            urwid.Divider(),
            buttons
        ])
        
        fill = urwid.Filler(pile)
        super().__init__(urwid.AttrMap(urwid.LineBox(fill), 'dialog'))

    def on_yes(self, button):
        """Обработчик кнопки Yes"""
        urwid.emit_signal(self, 'confirm')

    def on_no(self, button):
        """Обработчик кнопки No"""
        urwid.emit_signal(self, 'close')


class PanelWidget(urwid.WidgetWrap):
    """Виджет панели файлового менеджера"""
    
    signals = ['focus_changed']

    def __init__(self, title, panel_type='fs', s3_manager=None):
        """
        Инициализация панели
        panel_type: 'fs' - файловая система, 's3' - S3 Ceph
        """
        self.title = title
        self.panel_type = panel_type
        self.s3_manager = s3_manager
        self.fs_browser = FileSystemBrowser() if panel_type == 'fs' else None
        
        # Состояние для S3
        self.current_bucket = None
        self.current_prefix = ''
        
        # Переключатель режима панели (для левой панели может быть fs или s3)
        self.mode = panel_type  # 'fs' или 's3'
        
        self.walker = urwid.SimpleFocusListWalker([])
        self.listbox = urwid.ListBox(self.walker)
        
        header = urwid.AttrMap(urwid.Text(title, align='center'), 'header')
        self.path_text = urwid.Text('')
        path_widget = urwid.AttrMap(self.path_text, 'path')
        
        # Добавляем информационную строку о режиме
        self.mode_text = urwid.Text('')
        mode_widget = urwid.AttrMap(self.mode_text, 'mode')
        
        frame = urwid.Frame(
            urwid.AttrMap(self.listbox, 'body'),
            header=urwid.Pile([header, mode_widget, path_widget])
        )
        
        super().__init__(frame)
        self.refresh()

    def toggle_mode(self):
        """Переключение режима панели между fs и s3 (только для левой панели)"""
        if self.panel_type == 'fs':  # Только левая панель может переключаться
            self.mode = 's3' if self.mode == 'fs' else 'fs'
            if self.mode == 's3':
                self.current_bucket = None
                self.current_prefix = ''
            self.refresh()

    def refresh(self):
        """Обновить содержимое панели"""
        self.walker.clear()
        
        if self.mode == 's3':
            self._refresh_s3()
        else:
            self._refresh_fs()

    def _refresh_s3(self):
        """Обновить содержимое S3 панели"""
        self.mode_text.set_text('[S3 Mode]')
        
        if self.current_bucket is None:
            # Показываем список бакетов
            self.path_text.set_text('S3: /')
            buckets = self.s3_manager.list_buckets()
            
            for bucket in buckets:
                item = SelectableItem(
                    f'[BUCKET] {bucket}',
                    {'type': 'bucket', 'name': bucket},
                    is_selectable=False
                )
                urwid.connect_signal(item, 'click', self.on_bucket_select, bucket)
                self.walker.append(item)
        else:
            # Показываем содержимое бакета
            self.path_text.set_text(f'S3: /{self.current_bucket}/{self.current_prefix}')
            
            # Кнопка "назад"
            if self.current_prefix:
                item = SelectableItem(
                    '[..] Parent',
                    {'type': 'parent'},
                    is_selectable=False
                )
                urwid.connect_signal(item, 'click', self.on_s3_parent)
                self.walker.append(item)
            else:
                item = SelectableItem(
                    '[..] Back to buckets',
                    {'type': 'back'},
                    is_selectable=False
                )
                urwid.connect_signal(item, 'click', self.on_back_to_buckets)
                self.walker.append(item)
            
            # Получаем содержимое
            folders, files = self.s3_manager.list_objects(self.current_bucket, self.current_prefix)
            
            # Добавляем папки
            for folder in folders:
                folder_name = folder['Key'][len(self.current_prefix):].rstrip('/')
                item = SelectableItem(
                    f'[DIR ] {folder_name:40}  <DIR>',
                    {'type': 's3_dir', 'key': folder['Key']},
                    is_selectable=True
                )
                urwid.connect_signal(item, 'click', self.on_s3_folder_select, folder['Key'])
                self.walker.append(item)
            
            # Добавляем файлы
            for file_obj in files:
                key = file_obj['Key']
                file_name = key[len(self.current_prefix):]
                size = file_obj['Size']
                mtime = file_obj['LastModified'].strftime('%Y-%m-%d %H:%M:%S') if file_obj.get('LastModified') else ''
                
                label = f'[FILE] {file_name:40} {self.format_size(size):>10} {mtime}'
                item = SelectableItem(
                    label,
                    {'type': 's3_file', 'key': key, 'size': size, 'mtime': file_obj.get('LastModified')},
                    is_selectable=True
                )
                urwid.connect_signal(item, 'click', self.on_s3_file_select, key)
                self.walker.append(item)

    def _refresh_fs(self):
        """Обновить содержимое файловой системы"""
        self.mode_text.set_text('[FS Mode]')
        self.path_text.set_text(f'FS: {self.fs_browser.current_path}')
        items = self.fs_browser.list_directory()
        
        for item_data in items:
            name = item_data['name']
            is_dir = item_data['is_dir']
            size = item_data['size']
            mtime = item_data['mtime'].strftime('%Y-%m-%d %H:%M:%S') if item_data['mtime'] else ''
            
            if is_dir:
                if name == '..':
                    label = '[..  ] Parent'
                    selectable = False
                else:
                    label = f'[DIR ] {name:40}  <DIR>'
                    selectable = True
            else:
                label = f'[FILE] {name:40} {self.format_size(size):>10} {mtime}'
                selectable = True
            
            item = SelectableItem(
                label,
                {'type': 'fs_dir' if is_dir else 'fs_file', 'name': name, 'size': size, 'mtime': mtime},
                is_selectable=selectable
            )
            
            if is_dir:
                urwid.connect_signal(item, 'click', self.on_fs_dir_select, name)
            else:
                urwid.connect_signal(item, 'click', self.on_fs_file_select, name)
            
            self.walker.append(item)

    def format_size(self, size):
        """Форматирование размера файла"""
        for unit in ['B  ', 'KB ', 'MB ', 'GB ']:
            if size < 1024.0:
                return f'{size:.1f}{unit}'
            size /= 1024.0
        return f'{size:.1f}TB'

    def on_bucket_select(self, item, bucket_name):
        """Обработчик выбора бакета"""
        self.current_bucket = bucket_name
        self.current_prefix = ''
        self.refresh()

    def on_back_to_buckets(self, item):
        """Обработчик возврата к списку бакетов"""
        self.current_bucket = None
        self.current_prefix = ''
        self.refresh()

    def on_s3_parent(self, item):
        """Обработчик перехода на уровень выше в S3"""
        if self.current_prefix:
            parts = self.current_prefix.rstrip('/').split('/')
            self.current_prefix = '/'.join(parts[:-1]) + '/' if len(parts) > 1 else ''
            self.refresh()

    def on_s3_folder_select(self, item, folder):
        """Обработчик выбора папки в S3"""
        self.current_prefix = folder
        self.refresh()

    def on_s3_file_select(self, item, key):
        """Обработчик выбора файла в S3"""
        pass

    def on_fs_dir_select(self, item, dirname):
        """Обработчик выбора директории в FS"""
        if dirname == '..':
            self.fs_browser.current_path = os.path.dirname(self.fs_browser.current_path)
        else:
            self.fs_browser.current_path = os.path.join(self.fs_browser.current_path, dirname)
        self.refresh()

    def on_fs_file_select(self, item, filename):
        """Обработчик выбора файла в FS"""
        pass

    def get_selected_items(self):
        """Получить список выделенных элементов"""
        selected = []
        for widget in self.walker:
            if isinstance(widget, SelectableItem) and widget.is_item_selectable and widget.selected:
                selected.append(widget.data)
        return selected

    def get_focused_item(self):
        """Получить текущий элемент под фокусом"""
        focus_widget, pos = self.listbox.get_focus()
        if isinstance(focus_widget, SelectableItem):
            return focus_widget.data
        return None


class DualPaneApp:
    """Главное приложение с двумя панелями"""
    
    def __init__(self, s3_manager):
        self.s3_manager = s3_manager
        
        # Создаем две панели (обе могут быть в режиме fs или s3)
        self.left_panel = PanelWidget('LEFT PANEL', panel_type='fs', s3_manager=s3_manager)
        self.right_panel = PanelWidget('RIGHT PANEL', panel_type='s3', s3_manager=s3_manager)
        
        self.columns = urwid.Columns([
            ('weight', 1, urwid.LineBox(self.left_panel)),
            ('weight', 1, urwid.LineBox(self.right_panel))
        ], dividechars=1, focus_column=0)
        
        # Строка статуса
        self.status_text = urwid.Text(
            'TAB:switch | F2:toggle mode | F5:copy | F6:move | F7:mkdir | F8:delete | INS:select | q:quit'
        )
        status_bar = urwid.AttrMap(self.status_text, 'status')
        
        self.frame = urwid.Frame(
            urwid.AttrMap(self.columns, 'body'),
            footer=status_bar
        )
        
        self.main_widget = self.frame
        
        self.palette = [
            ('header', 'white', 'dark blue', 'bold'),
            ('path', 'light cyan', 'black'),
            ('mode', 'yellow', 'black'),
            ('body', 'default', 'default'),
            ('selected', 'black', 'dark cyan'),
            ('status', 'white', 'dark red'),
            ('dialog', 'white', 'dark blue'),
        ]

    def run(self):
        """Запуск главного цикла приложения"""
        self.loop = urwid.MainLoop(
            self.main_widget,
            palette=self.palette,
            unhandled_input=self.handle_input
        )
        self.loop.run()

    def handle_input(self, key):
        """Обработка пользовательского ввода"""
        if key in ('q', 'Q'):
            raise urwid.ExitMainLoop()
        elif key == 'tab':
            # Переключение между панелями
            current_focus = self.columns.focus_position
            self.columns.focus_position = 1 - current_focus
        elif key == 'f2':
            # Переключение режима панели (только для левой)
            if self.columns.focus_position == 0:
                self.left_panel.toggle_mode()
        elif key == 'f5':
            # Копирование
            self.copy_items()
        elif key == 'f6':
            # Перемещение
            self.move_items()
        elif key == 'f8':
            # Удаление
            self.delete_items()
        elif key == 'f7':
            # Создание бакета
            self.create_bucket()

    def show_dialog(self, dialog):
        """Показать модальное диалоговое окно"""
        overlay = urwid.Overlay(
            dialog,
            self.frame,
            align='center',
            width=('relative', 60),
            valign='middle',
            height=('relative', 40)
        )
        self.loop.widget = overlay

    def close_dialog(self):
        """Закрыть диалоговое окно"""
        self.loop.widget = self.main_widget

    def show_status(self, message):
        """Показать сообщение в строке статуса"""
        self.status_text.set_text(message)

    def get_active_panel(self):
        """Получить активную панель"""
        return self.left_panel if self.columns.focus_position == 0 else self.right_panel

    def get_inactive_panel(self):
        """Получить неактивную панель"""
        return self.right_panel if self.columns.focus_position == 0 else self.left_panel

    def create_bucket(self):
        """Показать диалог создания бакета"""
        active_panel = self.get_active_panel()
        
        # Создание бакета возможно только в S3 режиме
        if active_panel.mode != 's3':
            self.show_status('Create bucket available only in S3 mode (F2 to toggle)')
            return
        
        dialog = InputDialog('Create New Bucket', 'Bucket name: ')
        
        def on_submit(widget, bucket_name):
            if self.s3_manager.create_bucket(bucket_name):
                self.show_status(f'Created bucket: {bucket_name}')
                active_panel.refresh()
            else:
                self.show_status(f'Failed to create bucket: {bucket_name}')
            self.close_dialog()
        
        def on_close(widget):
            self.close_dialog()
        
        urwid.connect_signal(dialog, 'submit', on_submit)
        urwid.connect_signal(dialog, 'close', on_close)
        
        self.show_dialog(dialog)

    def copy_items(self):
        """Копирование выделенных элементов или текущего элемента"""
        source_panel = self.get_active_panel()
        dest_panel = self.get_inactive_panel()
        
        # Получаем список элементов для копирования
        selected_items = source_panel.get_selected_items()
        if not selected_items:
            # Если ничего не выделено, копируем текущий элемент
            focused = source_panel.get_focused_item()
            if focused and focused['type'] in ('fs_file', 's3_file'):
                selected_items = [focused]
        
        if not selected_items:
            self.show_status('No items to copy')
            return
        
        # Формируем сообщение для подтверждения
        count = len(selected_items)
        message = f'Copy {count} item(s)?'
        
        dialog = ConfirmDialog('Confirm Copy', message)
        
        def on_confirm(widget):
            self.close_dialog()
            self._do_copy(selected_items, source_panel, dest_panel)
        
        def on_close(widget):
            self.close_dialog()
        
        urwid.connect_signal(dialog, 'confirm', on_confirm)
        urwid.connect_signal(dialog, 'close', on_close)
        
        self.show_dialog(dialog)

    def _do_copy(self, items, source_panel, dest_panel):
        """Выполнить операцию копирования"""
        success_count = 0
        fail_count = 0
        
        for item in items:
            item_type = item['type']
            
            # FS -> S3
            if item_type == 'fs_file' and dest_panel.mode == 's3':
                if dest_panel.current_bucket:
                    source_path = os.path.join(source_panel.fs_browser.current_path, item['name'])
                    dest_key = dest_panel.current_prefix + item['name']
                    if self.s3_manager.upload_file(source_path, dest_panel.current_bucket, dest_key):
                        success_count += 1
                    else:
                        fail_count += 1
            
            # S3 -> FS
            elif item_type == 's3_file' and dest_panel.mode == 'fs':
                filename = os.path.basename(item['key'])
                dest_path = os.path.join(dest_panel.fs_browser.current_path, filename)
                if self.s3_manager.download_object(source_panel.current_bucket, item['key'], dest_path):
                    success_count += 1
                else:
                    fail_count += 1
            
            # S3 -> S3
            elif item_type == 's3_file' and dest_panel.mode == 's3':
                if dest_panel.current_bucket:
                    filename = os.path.basename(item['key'])
                    dest_key = dest_panel.current_prefix + filename
                    if self.s3_manager.copy_object(
                        source_panel.current_bucket, item['key'],
                        dest_panel.current_bucket, dest_key
                    ):
                        success_count += 1
                    else:
                        fail_count += 1
        
        # Обновляем панели и показываем результат
        dest_panel.refresh()
        self.show_status(f'Copied: {success_count} items, Failed: {fail_count} items')

    def move_items(self):
        """Перемещение выделенных элементов"""
        source_panel = self.get_active_panel()
        dest_panel = self.get_inactive_panel()
        
        # Получаем список элементов для перемещения
        selected_items = source_panel.get_selected_items()
        if not selected_items:
            focused = source_panel.get_focused_item()
            if focused and focused['type'] in ('fs_file', 's3_file'):
                selected_items = [focused]
        
        if not selected_items:
            self.show_status('No items to move')
            return
        
        count = len(selected_items)
        message = f'Move {count} item(s)?'
        
        dialog = ConfirmDialog('Confirm Move', message)
        
        def on_confirm(widget):
            self.close_dialog()
            self._do_move(selected_items, source_panel, dest_panel)
        
        def on_close(widget):
            self.close_dialog()
        
        urwid.connect_signal(dialog, 'confirm', on_confirm)
        urwid.connect_signal(dialog, 'close', on_close)
        
        self.show_dialog(dialog)

    def _do_move(self, items, source_panel, dest_panel):
        """Выполнить операцию перемещения (копирование + удаление)"""
        success_count = 0
        fail_count = 0
        
        for item in items:
            item_type = item['type']
            copied = False
            
            # Сначала копируем
            if item_type == 'fs_file' and dest_panel.mode == 's3':
                if dest_panel.current_bucket:
                    source_path = os.path.join(source_panel.fs_browser.current_path, item['name'])
                    dest_key = dest_panel.current_prefix + item['name']
                    copied = self.s3_manager.upload_file(source_path, dest_panel.current_bucket, dest_key)
                    if copied:
                        try:
                            os.remove(source_path)
                            success_count += 1
                        except OSError:
                            fail_count += 1
            
            elif item_type == 's3_file' and dest_panel.mode == 'fs':
                filename = os.path.basename(item['key'])
                dest_path = os.path.join(dest_panel.fs_browser.current_path, filename)
                copied = self.s3_manager.download_object(source_panel.current_bucket, item['key'], dest_path)
                if copied:
                    if self.s3_manager.delete_object(source_panel.current_bucket, item['key']):
                        success_count += 1
                    else:
                        fail_count += 1
            
            elif item_type == 's3_file' and dest_panel.mode == 's3':
                if dest_panel.current_bucket:
                    filename = os.path.basename(item['key'])
                    dest_key = dest_panel.current_prefix + filename
                    copied = self.s3_manager.copy_object(
                        source_panel.current_bucket, item['key'],
                        dest_panel.current_bucket, dest_key
                    )
                    if copied:
                        if self.s3_manager.delete_object(source_panel.current_bucket, item['key']):
                            success_count += 1
                        else:
                            fail_count += 1
            
            if not copied:
                fail_count += 1
        
        source_panel.refresh()
        dest_panel.refresh()
        self.show_status(f'Moved: {success_count} items, Failed: {fail_count} items')

    def delete_items(self):
        """Удаление выделенных элементов"""
        active_panel = self.get_active_panel()
        
        # Получаем список элементов для удаления
        selected_items = active_panel.get_selected_items()
        if not selected_items:
            focused = active_panel.get_focused_item()
            if focused:
                if focused['type'] == 'bucket':
                    selected_items = [focused]
                elif focused['type'] in ('fs_file', 's3_file'):
                    selected_items = [focused]
        
        if not selected_items:
            self.show_status('No items to delete')
            return
        
        count = len(selected_items)
        message = f'Delete {count} item(s)? This action cannot be undone!'
        
        dialog = ConfirmDialog('Confirm Delete', message)
        
        def on_confirm(widget):
            self.close_dialog()
            self._do_delete(selected_items, active_panel)
        
        def on_close(widget):
            self.close_dialog()
        
        urwid.connect_signal(dialog, 'confirm', on_confirm)
        urwid.connect_signal(dialog, 'close', on_close)
        
        self.show_dialog(dialog)

    def _do_delete(self, items, panel):
        """Выполнить операцию удаления"""
        success_count = 0
        fail_count = 0
        
        for item in items:
            item_type = item['type']
            
            if item_type == 'bucket':
                if self.s3_manager.delete_bucket(item['name']):
                    success_count += 1
                else:
                    fail_count += 1
            
            elif item_type == 's3_file':
                if self.s3_manager.delete_object(panel.current_bucket, item['key']):
                    success_count += 1
                else:
                    fail_count += 1
            
            elif item_type == 'fs_file':
                try:
                    file_path = os.path.join(panel.fs_browser.current_path, item['name'])
                    os.remove(file_path)
                    success_count += 1
                except OSError:
                    fail_count += 1
        
        panel.refresh()
        self.show_status(f'Deleted: {success_count} items, Failed: {fail_count} items')


if __name__ == '__main__':
    # Настройки подключения к S3 Ceph
    ENDPOINT_URL = 'http://your-ceph-endpoint:7480'
    ACCESS_KEY = 'your-access-key'
    SECRET_KEY = 'your-secret-key'
    
    s3_manager = S3Manager(ENDPOINT_URL, ACCESS_KEY, SECRET_KEY)
    app = DualPaneApp(s3_manager)
    app.run()
```

## Основные возможности реализованного решения

**Двухпанельный интерфейс**:[1][2]
- Левая панель: файловая система (по умолчанию) или S3 Ceph (переключение по F2)
- Правая панель: всегда S3 Ceph
- Переключение между панелями: клавиша TAB

**Отображение информации**:[3][4]
- Имя файла/объекта (до 40 символов)
- Размер в удобочитаемом формате (B, KB, MB, GB, TB)
- Дата и время модификации в формате YYYY-MM-DD HH:MM:SS

**Выделение элементов** (как в Midnight Commander):[5][1]
- `Insert` - выделить текущий элемент и перейти к следующему
- `Пробел` - выделить/снять выделение без перехода
- Чекбоксы слева от каждого элемента показывают статус выделения

**Операции с подтверждением**:[6][7]
- F5: копирование (с подтверждением)
- F6: перемещение (с подтверждением)
- F7: создание бакета (с вводом имени)
- F8: удаление (с подтверждением и предупреждением)

**Поддержка групповых операций**:
- Выделение нескольких файлов/объектов
- Копирование/перемещение/удаление группы элементов одной операцией
- Статистика выполнения: количество успешных и неудачных операций

**Копирование между различными источниками**:
- FS → S3: загрузка файлов
- S3 → FS: скачивание объектов
- S3 → S3: копирование между бакетами

Код полностью документирован на русском языке с подробными комментариями.[8][9]

[1](https://www.both.org/?p=5324)
[2](https://www.reddit.com/r/linux/comments/1lhx1cx/i_built_a_modern_tileable_tui_file_manager_in/)
[3](https://stackoverflow.com/questions/52428684/how-to-indicate-that-a-urwid-listbox-has-more-items-than-displayed-at-the-moment)
[4](https://urwid.org/manual/widgets.html)
[5](https://github.com/urwid/urwid/issues/166)
[6](https://discourse.bokeh.org/t/confirmation-dialog-on-button-press/9890)
[7](https://stackoverflow.com/questions/5127407/how-to-implement-a-confirmation-yes-no-dialogpreference)
[8](https://urwid.readthedocs.io/_/downloads/en/latest/pdf/)
[9](https://seriot.ch/urwid/)
[10](https://asprunner.com/forums/topic/29479-To-select-multiple-values-from-checkboxes-and-have-them-appear-as-individual-entries)
