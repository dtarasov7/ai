<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# доведи курс до готового репозитория: с полностью дописанными client.py (stdio + HTTP), асинхронными tools (httpx), прогресс‑нотификациями и шаблонами системных промптов для режима “модель без fine‑tuning”.

стек предпочтительнее для окружения - классический venv + requirements.txt

Ниже — “готовый репозиторий” в виде набора файлов (Markdown‑лекции + labs + полностью дописанные `server.py`/`client_stdio.py`/`client_http.py`), рассчитанный на `venv + requirements.txt`, с асинхронными tools на `httpx`, прогресс‑нотификациями через `Context`, и шаблонами системных промптов для режима “модель без fine‑tuning”. В примерах учтены ключевые требования stdio и Streamable HTTP из спецификации (newline‑delimited сообщения, запрет писать в stdout, валидировать Origin и т. п.).

***

## README.md (корень)

```markdown
# MCP + Python — учебный репозиторий

Этот репозиторий содержит:
- лекции в `lectures/`
- практики в `labs/`
- диаграммы PlantUML в `diagrams/`
- готовые примеры MCP сервера (stdio + Streamable HTTP) и клиентов (stdio + HTTP). [page:0]

## Требования
- Python 3.11+ (рекомендуется)
- Node.js 18+ (для MCP Inspector)

## Быстрый старт (venv)
```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```


## Запуск MCP сервера (stdio, для client_stdio.py)

```bash
python apps/server_stdio.py
```


## Запуск клиента (stdio)

```bash
python apps/client_stdio.py
```


## Запуск сервера (Streamable HTTP)

> Важно: при реализации Streamable HTTP спецификация требует валидировать Origin (защита от DNS rebinding) и рекомендует биндинг на localhost. [page:0]

```bash
python apps/server_http.py
```


## Запуск клиента (HTTP)

```bash
python apps/client_http.py --url http://127.0.0.1:8080/mcp
```


## Inspector (ручное тестирование)

Inspector запускается через npx:

```bash
npx @modelcontextprotocol/inspector python apps/server_stdio.py
```


## Структура

- `apps/` — готовые серверы и клиенты
- `lectures/` — теоретические материалы
- `labs/` — пошаговые задания
- `prompts/` — шаблоны system prompt для моделей без fine-tuning
- `diagrams/` — PlantUML

```

***

## requirements.txt

```text
mcp[cli]==1.8.0
httpx==0.27.2
anyio==4.7.0
uvicorn==0.30.6
fastapi==0.115.6
pydantic==2.10.3
```

Примечание: `mcp[cli]` нужен для dev‑утилит и удобного тестирования.[^1]

***

## Репозиторий: структура

```text
mcp-python-course/
  README.md
  requirements.txt

  apps/
    server_stdio.py
    server_http.py
    client_stdio.py
    client_http.py

  prompts/
    system_no_finetune_ru.md
    tool_call_policy_ru.md
    examples_ru.md

  lectures/
    00-overview.md
    01-intro-mcp.md
    02-transports.md
    03-python-sdk.md
    04-tools-resources-prompts.md
    05-debugging-inspector.md
    06-security.md
    07-capstone.md

  labs/
    lab-01-env/README.md
    lab-02-server-tools/README.md
    lab-03-client-stdio/README.md
    lab-04-inspector/README.md
    lab-05-streamable-http/README.md
    lab-06-secure-tools/README.md
    lab-07-capstone/README.md

  diagrams/
    mindmap.puml
    mcp-architecture.puml
    stdio-seq.puml
    streamable-http-seq.puml
    inspector-workflow.puml
```


***

## apps/server_stdio.py (готовый stdio сервер)

```python
"""
apps/server_stdio.py

MCP сервер (stdio транспорт).

Почему важно аккуратно с выводом:
- В stdio транспорте сообщения JSON-RPC делимитятся переводом строки и
  НЕ ДОЛЖНЫ содержать embedded newlines. [page:0]
- Сервер НЕ ДОЛЖЕН писать ничего в stdout, кроме валидных MCP сообщений. [page:0]
  Поэтому:
  - никаких print() в stdout
  - логирование — через механизмы MCP/SDK или в stderr

Этот сервер публикует:
- tools:
  - add(a,b)                (синхронный, детерминированный)
  - fetch_url(url)          (асинхронный, httpx)
  - long_hash(text, steps)  (асинхронный, демонстрирует прогресс-нотификации)
- resources:
  - buildinfo://
- prompts:
  - incident_triage(error_text)
"""

from __future__ import annotations

import asyncio
import hashlib
import os
from datetime import datetime, timezone
from typing import Any

import httpx
from mcp.server.fastmcp import Context, FastMCP
from mcp.server.fastmcp.prompts import base


def _utc_now_iso() -> str:
    """Возвращает текущее UTC-время в ISO формате (для buildinfo)."""
    return datetime.now(timezone.utc).isoformat()


def _safe_env(name: str, default: str = "") -> str:
    """
    Безопасно достаём переменную окружения.

    В учебном репозитории это нужно, чтобы:
    - показывать, как пробрасывать конфиги в MCP сервер,
    - не падать при отсутствии переменной.
    """
    return os.environ.get(name, default)


mcp = FastMCP("CourseServer-STDIO")


# -------------------------
# Resources (чтение данных)
# -------------------------
@mcp.resource("buildinfo://")
def buildinfo() -> str:
    """
    Простой resource.

    Идея:
    - resources похожи на “GET endpoints”: читаем данные, минимум логики, без сайд-эффектов. [page:1]
    """
    started_at = _utc_now_iso()
    env = _safe_env("ENV", "dev")
    return f"CourseServer buildinfo: env={env}, started_at={started_at}"


# -------------------------
# Tools (действия)
# -------------------------
@mcp.tool()
def add(a: int, b: int) -> int:
    """
    Сложить два числа.

    Это “smoke test”:
    - проверяет, что клиент видит tools,
    - проверяет, что вызов и сериализация результата работают.
    """
    return a + b


@mcp.tool()
async def fetch_url(url: str, timeout_s: float = 5.0) -> dict[str, Any]:
    """
    Скачать URL и вернуть компактный результат.

    Аргументы:
    - url: строка URL (в учебном примере без allowlist, но в lab-06 будет безопасная версия).
    - timeout_s: таймаут запроса

    Возвращаем:
    - status_code
    - headers (частично)
    - text_preview (первые N символов)

    Почему async:
    - сетевые операции лучше делать асинхронно.
    """
    timeout = httpx.Timeout(timeout_s)
    async with httpx.AsyncClient(timeout=timeout, follow_redirects=True) as client:
        resp = await client.get(url)

    text = resp.text or ""
    preview = text[:500]

    # Важно: возвращаем JSON-подобную структуру (dict/list/str/int),
    # чтобы SDK легко сериализовал результат для клиента.
    return {
        "url": str(resp.url),
        "status_code": resp.status_code,
        "content_type": resp.headers.get("content-type", ""),
        "text_preview": preview,
    }


@mcp.tool()
async def long_hash(text: str, steps: int = 5, ctx: Context | None = None) -> dict[str, Any]:
    """
    Демонстрация прогресс-нотификаций.

    Сценарий:
    - “долго” считаем хеш (искусственно делим работу на шаги),
    - на каждом шаге шлём прогресс.

    Важное:
    - Context даёт доступ к логированию и прогрессу. [page:1]
    - progress полезен, когда tool выполняется долго, чтобы хост/инспектор мог показать статус.
    """
    if steps < 1:
        steps = 1

    if ctx is not None:
        ctx.info(f"long_hash started: steps={steps}")

    buf = text.encode("utf-8")
    h = hashlib.sha256()

    for i in range(steps):
        # Имитируем “работу”
        h.update(buf)
        await asyncio.sleep(0.25)

        if ctx is not None:
            # report_progress(current, total)
            await ctx.report_progress(i + 1, steps)

    digest = h.hexdigest()

    if ctx is not None:
        ctx.info("long_hash finished")

    return {"sha256": digest, "steps": steps}


# -------------------------
# Prompts (шаблоны)
# -------------------------
@mcp.prompt()
def incident_triage(error_text: str) -> list[base.Message]:
    """
    Prompt как “переиспользуемый шаблон диалога”.

    Возвращаем список сообщений (User/Assistant).
    Это помогает хосту вставлять структуру в контекст модели. [page:1]
    """
    return [
        base.UserMessage("Ты дежурный инженер. Разбери инцидент по логам/ошибке."),
        base.UserMessage("Ошибка/симптом:"),
        base.UserMessage(error_text),
        base.AssistantMessage(
            "Ок. Сначала уточню контекст, затем предложу гипотезы и план диагностики."
        ),
    ]


if __name__ == "__main__":
    # Запускаем stdio сервер.
    # Важно: не печатаем ничего в stdout.
    mcp.run()
```


***

## apps/client_stdio.py (полностью готовый stdio клиент)

```python
"""
apps/client_stdio.py

Клиент:
- запускает MCP сервер как subprocess (stdio transport),
- делает initialize,
- листает tools/resources/prompts,
- вызывает tool add и long_hash.

Напоминание:
- В stdio транспорте серверные сообщения делимитятся newlines и не должны
  содержать embedded newlines. [page:0]
"""

from __future__ import annotations

import asyncio
from pprint import pprint

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client


async def main() -> None:
    # Параметры запуска сервера как подпроцесса.
    server_params = StdioServerParameters(
        command="python",
        args=["apps/server_stdio.py"],
        env=None,
    )

    # stdio_client создаёт пару потоков (read, write) для JSON-RPC поверх stdin/stdout. [page:0]
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # initialize — обязательная фаза: согласование версии/возможностей.
            await session.initialize()

            print("\n== tools ==")
            tools = await session.list_tools()
            # В tools обычно есть имя, описание и JSON-schema аргументов.
            pprint(tools)

            print("\n== resources ==")
            resources = await session.list_resources()
            pprint(resources)

            print("\n== prompts ==")
            prompts = await session.list_prompts()
            pprint(prompts)

            print("\n== call add(2, 40) ==")
            res = await session.call_tool("add", arguments={"a": 2, "b": 40})
            pprint(res)

            print("\n== call long_hash(text='hello', steps=6) ==")
            # В зависимости от хоста, прогресс может отображаться как уведомления.
            res = await session.call_tool("long_hash", arguments={"text": "hello", "steps": 6})
            pprint(res)


if __name__ == "__main__":
    asyncio.run(main())
```


***

## apps/server_http.py (Streamable HTTP сервер с безопасными заготовками)

```python
"""
apps/server_http.py

Сервер в режиме Streamable HTTP.

Важные требования спецификации при реализации Streamable HTTP: [page:0]
- MUST validate Origin на всех входящих соединениях (защита от DNS rebinding).
- SHOULD bind to localhost (127.0.0.1) при локальном запуске.
- SHOULD implement proper authentication.

Ниже — учебная реализация:
- биндимся на 127.0.0.1
- добавляем простую проверку Origin (allowlist)
- добавляем примитивный Bearer token (для демонстрации подхода)

Для production:
- OAuth/MTLS/полноценные токены и аудит.
"""

from __future__ import annotations

import os
from typing import Iterable

from fastapi import FastAPI, Header, HTTPException, Request
import uvicorn

from mcp.server.fastmcp import FastMCP, Context
import httpx
import asyncio

# --------------
# MCP server
# --------------
mcp = FastMCP("CourseServer-HTTP", stateless_http=True)


@mcp.tool()
async def fetch_url(url: str, timeout_s: float = 5.0) -> dict:
    """
    Та же идея, что и в stdio сервере, но запускается поверх HTTP.
    """
    async with httpx.AsyncClient(timeout=httpx.Timeout(timeout_s), follow_redirects=True) as client:
        r = await client.get(url)

    return {
        "url": str(r.url),
        "status_code": r.status_code,
        "content_type": r.headers.get("content-type", ""),
        "text_preview": (r.text or "")[:500],
    }


@mcp.tool()
async def long_task(name: str, seconds: float = 2.0, ctx: Context | None = None) -> dict:
    """
    Длинная задача с прогрессом.
    """
    steps = 10
    for i in range(steps):
        await asyncio.sleep(seconds / steps)
        if ctx is not None:
            await ctx.report_progress(i + 1, steps)
    return {"task": name, "status": "done", "seconds": seconds}


# --------------
# FastAPI wrapper
# --------------
app = FastAPI()

# MCP endpoint: один путь должен поддерживать GET и POST. [page:0]
app.mount("/mcp", mcp.streamable_http_app())


# --------------
# Security middleware (учебное)
# --------------
def _split_allowlist(value: str) -> list[str]:
    return [x.strip() for x in value.split(",") if x.strip()]


ALLOWED_ORIGINS: list[str] = _split_allowlist(os.environ.get("MCP_ALLOWED_ORIGINS", "http://localhost,http://127.0.0.1"))
API_TOKEN: str = os.environ.get("MCP_API_TOKEN", "dev-token")


@app.middleware("http")
async def security_checks(request: Request, call_next):
    # 1) Origin validation (обязательное требование спецификации для Streamable HTTP). [page:0]
    origin = request.headers.get("origin")
    if origin is not None and origin not in ALLOWED_ORIGINS:
        raise HTTPException(status_code=403, detail=f"Origin not allowed: {origin}")

    # 2) Простая аутентификация: Bearer token (учебная).
    # В реальности лучше OAuth/другие механизмы, но принцип показан. [page:0]
    auth = request.headers.get("authorization", "")
    if not auth.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing Bearer token")
    token = auth.removeprefix("Bearer ").strip()
    if token != API_TOKEN:
        raise HTTPException(status_code=401, detail="Invalid token")

    return await call_next(request)


if __name__ == "__main__":
    # Для локального запуска биндимся на localhost, как рекомендует спецификация. [page:0]
    uvicorn.run(app, host="127.0.0.1", port=8080)
```


***

## apps/client_http.py (полностью готовый Streamable HTTP клиент)

```python
"""
apps/client_http.py

Клиент подключается к MCP серверу по Streamable HTTP.

Спецификация требует, чтобы клиент:
- отправлял JSON-RPC сообщения через HTTP POST
- выставлял Accept: application/json и text/event-stream
- умел принимать ответы как JSON или как SSE stream. [page:0]

SDK скрывает детали: streamablehttp_client() создаёт read/write потоки,
а ClientSession работает поверх них.
"""

from __future__ import annotations

import argparse
import asyncio
from pprint import pprint

from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client


async def main(url: str, token: str) -> None:
    # В streamablehttp_client можно передавать дополнительные заголовки (auth, protocol version и т.д.).
    headers = {
        "Authorization": f"Bearer {token}",
        # Origin полезен для прохождения origin validation на сервере.
        "Origin": "http://localhost",
    }

    async with streamablehttp_client(url, headers=headers) as (read, write, _meta):
        async with ClientSession(read, write) as session:
            await session.initialize()

            print("\n== list_tools ==")
            tools = await session.list_tools()
            pprint(tools)

            print("\n== call fetch_url ==")
            res = await session.call_tool(
                "fetch_url",
                arguments={"url": "https://example.com", "timeout_s": 5.0},
            )
            pprint(res)

            print("\n== call long_task (progress expected) ==")
            res = await session.call_tool(
                "long_task",
                arguments={"name": "demo", "seconds": 2.0},
            )
            pprint(res)


if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--url", required=True, help="Например: http://127.0.0.1:8080/mcp")
    p.add_argument("--token", default="dev-token", help="Bearer token (по умолчанию dev-token)")
    args = p.parse_args()

    asyncio.run(main(args.url, args.token))
```


***

## prompts/ (системные промпты для “модель без fine-tuning”)

### prompts/system_no_finetune_ru.md

```markdown
# System prompt (RU) — модель без fine-tuning, но с MCP tools

Ты — ассистент, который может решать задачи двумя способами:
1) Рассуждая “в голове” (если инструмент не нужен).
2) Вызывая инструменты (tools) через MCP, когда без инструмента нельзя получить данные/выполнить действие.

Правила:
- Перед вызовом инструмента объясни ОДНОЙ короткой фразой, зачем он нужен.
- Вызывай инструмент только если:
  - требуется внешний факт/данные (URL, файл, состояние системы),
  - требуется вычисление/операция, которую надёжнее делать кодом,
  - пользователь явно просит выполнить действие.
- Если инструмент вернул ошибку, не выдумывай ответ. Скажи, что пошло не так, и предложи следующий шаг.

Формат вызова инструмента (абстрактно):
- Tool name: <имя>
- Arguments: JSON-объект, строго по схеме tool

После получения результата:
- Кратко интерпретируй результат
- Дай итог пользователю
```


### prompts/tool_call_policy_ru.md

```markdown
# Policy: когда НЕ вызывать tools

Не вызывай tools, если:
- вопрос чисто “объяснительный” и не требует внешних данных;
- можно ответить на основе уже известного контекста диалога;
- результат инструмента не повлияет на вывод.

Если сомневаешься — задай уточняющий вопрос вместо вызова tool.
```


### prompts/examples_ru.md

```markdown
# Примеры (few-shot)

## Пример 1: нужен tool
Пользователь: "Скачай страницу https://example.com и покажи заголовок."
Ассистент: "Нужен инструмент, чтобы получить содержимое страницы."
Tool: fetch_url
Arguments: {"url":"https://example.com","timeout_s":5}

(После tool)
Ассистент: "Страница доступна (200). Вот превью... Заголовок вероятно ..."

## Пример 2: tool не нужен
Пользователь: "Объясни разницу resources и tools в MCP."
Ассистент: (отвечает без инструментов)
```


***

## labs/ (обновление под “готовый репозиторий”)

### labs/lab-05-streamable-http/README.md (важные пункты)

```markdown
# Lab 05 — Streamable HTTP (готовая реализация)

## Цель
Запустить `apps/server_http.py` и подключиться `apps/client_http.py`.

## Шаги
1) Запусти сервер:
```bash
export MCP_API_TOKEN=dev-token
export MCP_ALLOWED_ORIGINS=http://localhost,http://127.0.0.1
python apps/server_http.py
```

2) Запусти клиент:
```bash
python apps/client_http.py --url http://127.0.0.1:8080/mcp --token dev-token
```


## Что проверить

- Без Bearer token сервер отвечает 401.
- С неправильным Origin сервер отвечает 403.
- При корректных заголовках `list_tools` и `call_tool` работают.


## Почему так

Спецификация требует валидировать Origin для защиты от DNS rebinding, а также рекомендует аутентификацию и биндинг на localhost. [page:0]

```

***

## diagrams/ (оставить как в прошлой версии)
Диаграммы transport/seq и mindmap остаются актуальными, т.к. Streamable HTTP требования (Accept header, POST/GET, Origin validation и т.д.) отражены в спецификации. 

***

Если нужно, следующий шаг — дописать “capstone” (`lab-07`) как отдельный MCP‑сервер “Ops‑Assistant” с allowlist директорий для `tail_logs` и строгой валидацией путей (защита от path traversal), плюс тест‑набор: 5 сценариев “правильный вызов/неправильный вызов/ошибка сети/таймаут/запрещённый путь”.


<div align="center">⁂</div>

[^1]: https://modelcontextprotocol.io/specification/2025-06-18/basic/transports```

