Отлично! Создаю детальные лабораторные работы.[1]

***

### Лабораторные работы

#### `labs/lab01_basic_server/README.md`

```markdown
# Лабораторная работа 1: Базовый MCP-сервер с инструментами

## Цели обучения

После выполнения этой лабораторной работы вы сможете:

- Создавать MCP-сервер с stdio транспортом
- Регистрировать инструменты через декораторы
- Определять JSON Schema для валидации аргументов
- Обрабатывать вызовы инструментов
- Возвращать различные типы контента
- Запускать и тестировать сервер с помощью MCP Inspector

## Задание

Создайте MCP-сервер "text-tools-server" с инструментами для обработки текста.

### Требования

#### Инструмент 1: `count_words`

Подсчитывает количество слов в тексте.

**Параметры:**
- `text` (string, обязательно) - текст для анализа

**Возвращает:**
- Количество слов
- Количество символов
- Количество строк

**Пример вызова:**
```json
{
  "name": "count_words",
  "arguments": {
    "text": "Привет, мир!\nЭто тест."
  }
}
```

**Ожидаемый результат:**
```
Анализ текста:
- Слов: 4
- Символов: 24
- Строк: 2
```

#### Инструмент 2: `to_uppercase`

Преобразует текст в верхний регистр.

**Параметры:**
- `text` (string, обязательно) - текст для преобразования

**Возвращает:**
- Текст в верхнем регистре

#### Инструмент 3: `replace_text`

Заменяет все вхождения одной подстроки на другую.

**Параметры:**
- `text` (string, обязательно) - исходный текст
- `search` (string, обязательно) - что искать
- `replace` (string, обязательно) - на что заменить
- `case_sensitive` (boolean, опционально, по умолчанию true) - учитывать регистр

**Возвращает:**
- Текст с выполненными заменами
- Количество замен

## Пошаговая инструкция

### Шаг 1: Создание структуры проекта

```bash
cd labs/lab01_basic_server
touch server.py
```

### Шаг 2: Импорты и создание сервера

```python
#!/usr/bin/env python3

import asyncio
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types

# Создаём сервер
app = Server("text-tools-server")
```

### Шаг 3: Регистрация инструментов

Используйте декоратор `@app.list_tools()` для регистрации списка инструментов.

Пример JSON Schema для параметров:

```python
{
    "type": "object",
    "properties": {
        "text": {
            "type": "string",
            "description": "Текст для обработки"
        }
    },
    "required": ["text"]
}
```

### Шаг 4: Реализация обработчика вызовов

Используйте декоратор `@app.call_tool()` для обработки вызовов.

Структура функции:

```python
@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "count_words":
        # Ваша реализация
        pass
    elif name == "to_uppercase":
        # Ваша реализация
        pass
    # ... и т.д.
```

### Шаг 5: Точка входа

```python
async def main():
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

### Шаг 6: Тестирование

#### Вариант 1: С помощью MCP Inspector

```bash
mcp dev server.py
```

Откройте браузер и протестируйте каждый инструмент.

#### Вариант 2: Напишите тестового клиента

```python
# test_client.py
import asyncio
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

async def test():
    server_params = StdioServerParameters(
        command="python",
        args=["server.py"]
    )
    
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            
            # Тест count_words
            result = await session.call_tool(
                "count_words",
                {"text": "Привет мир"}
            )
            print(result.content.text)

asyncio.run(test())
```

## Критерии проверки

- [ ] Сервер запускается без ошибок
- [ ] Все три инструмента регистрируются корректно
- [ ] `count_words` правильно подсчитывает слова, символы и строки
- [ ] `to_uppercase` корректно преобразует текст
- [ ] `replace_text` выполняет замену с учётом параметра case_sensitive
- [ ] Обрабатываются ошибки (отсутствующие параметры, неизвестный инструмент)
- [ ] Код снабжён комментариями на русском языке
- [ ] Сервер проходит тестирование через Inspector или клиента

## Дополнительное задание (необязательно)

Добавьте инструмент `find_pattern`:

**Параметры:**
- `text` (string) - текст для поиска
- `pattern` (string) - регулярное выражение

**Возвращает:**
- Все найденные совпадения
- Их позиции в тексте

## Подсказки

1. Для подсчёта слов используйте `text.split()`
2. Для подсчёта строк используйте `text.count('\n') + 1`
3. Для замены без учёта регистра используйте `re.sub` с флагом `re.IGNORECASE`
4. Всегда проверяйте наличие обязательных параметров
5. Используйте `types.TextContent` для возврата результатов

## Время выполнения

Ожидаемое время: 45-60 минут

## Следующие шаги

После успешного выполнения переходите к Lab 02: Resources и Prompts
```

***

#### `labs/lab01_basic_server/solution/server.py`

```python
#!/usr/bin/env python3
"""
Решение Lab 01: Базовый MCP-сервер с инструментами для обработки текста.

Автор: MCP Python Course
"""

import asyncio
import re
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём экземпляр сервера
app = Server("text-tools-server")


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """
    Регистрирует все доступные инструменты для обработки текста.
    
    Returns:
        Список инструментов с их описаниями и схемами параметров
    """
    return [
        types.Tool(
            name="count_words",
            description="Подсчитывает количество слов, символов и строк в тексте",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Текст для анализа"
                    }
                },
                "required": ["text"]
            }
        ),
        types.Tool(
            name="to_uppercase",
            description="Преобразует весь текст в верхний регистр",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Текст для преобразования"
                    }
                },
                "required": ["text"]
            }
        ),
        types.Tool(
            name="replace_text",
            description="Заменяет все вхождения одной подстроки на другую",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Исходный текст"
                    },
                    "search": {
                        "type": "string",
                        "description": "Подстрока для поиска"
                    },
                    "replace": {
                        "type": "string",
                        "description": "Подстрока для замены"
                    },
                    "case_sensitive": {
                        "type": "boolean",
                        "description": "Учитывать регистр при поиске",
                        "default": True
                    }
                },
                "required": ["text", "search", "replace"]
            }
        )
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    """
    Обрабатывает вызовы инструментов.
    
    Args:
        name: Имя вызываемого инструмента
        arguments: Словарь с аргументами
        
    Returns:
        Список текстовых контентов с результатом
        
    Raises:
        ValueError: При невалидных аргументах или неизвестном инструменте
    """
    
    if name == "count_words":
        # Валидация параметров
        if "text" not in arguments:
            raise ValueError("Отсутствует обязательный параметр 'text'")
        
        text = arguments["text"]
        
        # Подсчёт слов (разделение по пробелам)
        words = text.split()
        word_count = len(words)
        
        # Подсчёт символов
        char_count = len(text)
        
        # Подсчёт строк
        line_count = text.count('\n') + 1 if text else 0
        
        # Формируем результат
        result_text = (
            f"Анализ текста:\n"
            f"- Слов: {word_count}\n"
            f"- Символов: {char_count}\n"
            f"- Строк: {line_count}"
        )
        
        return [types.TextContent(type="text", text=result_text)]
    
    elif name == "to_uppercase":
        # Валидация
        if "text" not in arguments:
            raise ValueError("Отсутствует обязательный параметр 'text'")
        
        text = arguments["text"]
        
        # Преобразование в верхний регистр
        result = text.upper()
        
        return [types.TextContent(type="text", text=result)]
    
    elif name == "replace_text":
        # Валидация всех обязательных параметров
        required = ["text", "search", "replace"]
        for param in required:
            if param not in arguments:
                raise ValueError(f"Отсутствует обязательный параметр '{param}'")
        
        text = arguments["text"]
        search = arguments["search"]
        replace = arguments["replace"]
        case_sensitive = arguments.get("case_sensitive", True)
        
        # Выполняем замену
        if case_sensitive:
            # Простая замена с учётом регистра
            result = text.replace(search, replace)
            # Подсчитываем количество замен
            count = text.count(search)
        else:
            # Замена без учёта регистра через регулярное выражение
            pattern = re.compile(re.escape(search), re.IGNORECASE)
            # Подсчитываем совпадения
            count = len(pattern.findall(text))
            # Выполняем замену
            result = pattern.sub(replace, text)
        
        # Формируем результат
        result_text = (
            f"Выполнено замен: {count}\n\n"
            f"Результат:\n{result}"
        )
        
        return [types.TextContent(type="text", text=result_text)]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


async def main():
    """
    Точка входа сервера.
    
    Запускает MCP сервер с stdio транспортом.
    """
    import sys
    print("Text Tools Server запущен", file=sys.stderr)
    
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
```

***

#### `labs/lab02_resources_prompts/README.md`

```markdown
# Лабораторная работа 2: Resources и Prompts

## Цели обучения

После выполнения этой лабораторной работы вы сможете:

- Предоставлять ресурсы (resources) через MCP
- Создавать промпты (prompts) с параметрами
- Использовать различные URI схемы для ресурсов
- Генерировать динамический контент для промптов
- Тестировать ресурсы и промпты через клиента

## Задание

Создайте MCP-сервер "knowledge-base-server", который предоставляет базу знаний через ресурсы и шаблоны промптов.

### Требования

#### Ресурсы

1. **config://server-info**
   - Информация о сервере (версия, возможности)
   - MIME type: application/json

2. **kb://python-basics**
   - Статья о базовых концепциях Python
   - MIME type: text/markdown

3. **kb://mcp-introduction**
   - Введение в MCP
   - MIME type: text/markdown

4. **stats://usage**
   - Статистика использования сервера (счётчик обращений)
   - MIME type: text/plain

#### Промпты

1. **explain_concept**
   - Параметры:
     - `concept` (string, обязательно) - концепция для объяснения
     - `level` (string, опционально) - уровень детализации (beginner/intermediate/advanced)
   - Генерирует промпт для объяснения концепции с использованием ресурсов

2. **code_review**
   - Параметры:
     - `language` (string, обязательно) - язык программирования
     - `code` (string, обязательно) - код для ревью
   - Генерирует промпт для проверки кода

3. **compare_technologies**
   - Параметры:
     - `tech1` (string, обязательно) - первая технология
     - `tech2` (string, обязательно) - вторая технология
   - Генерирует промпт для сравнения технологий

## Пошаговая инструкция

### Шаг 1: Создание структуры

```bash
cd labs/lab02_resources_prompts
touch server.py
mkdir knowledge_base
```

### Шаг 2: Регистрация ресурсов

```python
@app.list_resources()
async def list_resources() -> list[types.Resource]:
    """
    Возвращает список доступных ресурсов.
    """
    return [
        types.Resource(
            uri="config://server-info",
            name="Server Information",
            mimeType="application/json",
            description="Информация о сервере и его возможностях"
        ),
        # ... остальные ресурсы
    ]
```

### Шаг 3: Чтение ресурсов

```python
@app.read_resource()
async def read_resource(uri: str) -> str:
    """
    Читает содержимое ресурса по URI.
    """
    if uri == "config://server-info":
        import json
        return json.dumps({
            "name": "knowledge-base-server",
            "version": "1.0.0",
            "resources": 4,
            "prompts": 3
        }, indent=2)
    # ... обработка других URI
```

### Шаг 4: Регистрация промптов

```python
@app.list_prompts()
async def list_prompts() -> list[types.Prompt]:
    """
    Возвращает список доступных промптов.
    """
    return [
        types.Prompt(
            name="explain_concept",
            description="Объясняет концепцию программирования",
            arguments=[
                types.PromptArgument(
                    name="concept",
                    description="Название концепции",
                    required=True
                ),
                types.PromptArgument(
                    name="level",
                    description="Уровень детализации",
                    required=False
                )
            ]
        ),
        # ... остальные промпты
    ]
```

### Шаг 5: Генерация промптов

```python
@app.get_prompt()
async def get_prompt(name: str, arguments: dict) -> types.GetPromptResult:
    """
    Генерирует промпт с подставленными аргументами.
    """
    if name == "explain_concept":
        concept = arguments.get("concept", "")
        level = arguments.get("level", "beginner")
        
        message = f"""Объясни концепцию "{concept}" на уровне {level}.

Структура объяснения:
1. Определение
2. Зачем это нужно
3. Примеры использования
4. Распространённые ошибки
"""
        
        return types.GetPromptResult(
            description=f"Объяснение концепции {concept}",
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(type="text", text=message)
                )
            ]
        )
```

### Шаг 6: Тестирование

Создайте тестового клиента:

```python
# test_client.py
async def test_resources_and_prompts():
    # ... подключение к серверу ...
    
    # Тест ресурсов
    resources = await session.list_resources()
    print(f"Ресурсов: {len(resources.resources)}")
    
    # Чтение ресурса
    content = await session.read_resource("config://server-info")
    print(content.contents.text)
    
    # Тест промптов
    prompts = await session.list_prompts()
    print(f"Промптов: {len(prompts.prompts)}")
    
    # Получение промпта
    prompt = await session.get_prompt(
        "explain_concept",
        {"concept": "async/await", "level": "intermediate"}
    )
    print(prompt.messages.content.text)
```

## Критерии проверки

- [ ] Сервер предоставляет все 4 ресурса
- [ ] Ресурсы читаются корректно по URI
- [ ] Все 3 промпта регистрируются
- [ ] Промпты генерируются с корректными параметрами
- [ ] Опциональные параметры обрабатываются правильно
- [ ] Статистика использования обновляется при обращениях
- [ ] Код содержит подробные комментарии

## Дополнительное задание

1. Добавьте счётчик обращений к каждому ресурсу
2. Создайте ресурс `stats://popular` с топ-3 самых запрашиваемых ресурса
3. Добавьте промпт с вложенным чтением ресурсов

## Подсказки

1. Используйте глобальную переменную для счётчика обращений
2. Для JSON ресурсов используйте `json.dumps()`
3. Для Markdown ресурсов можно хранить текст в переменных или файлах
4. В промптах можно использовать f-strings для подстановки параметров

## Время выполнения

Ожидаемое время: 60-75 минут

## Следующие шаги

После выполнения переходите к Lab 03: Асинхронные инструменты
```

***

#### `labs/lab02_resources_prompts/solution/server.py`

```python
#!/usr/bin/env python3
"""
Решение Lab 02: Resources и Prompts

Сервер базы знаний с ресурсами и промптами.
"""

import asyncio
import json
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём сервер
app = Server("knowledge-base-server")

# Глобальный счётчик обращений к ресурсам
resource_access_count = {}


# Содержимое статей базы знаний
PYTHON_BASICS = """# Основы Python

## Что такое Python?

Python - высокоуровневый язык программирования общего назначения, 
созданный Гвидо ван Россумом в 1991 году.

## Ключевые особенности

- **Простой синтаксис**: Код легко читается и пишется
- **Динамическая типизация**: Типы определяются автоматически
- **Множество библиотек**: Богатая экосистема пакетов
- **Мультипарадигменность**: ООП, функциональное, процедурное программирование

## Примеры использования

- Веб-разработка (Django, Flask)
- Data Science (Pandas, NumPy)
- Machine Learning (TensorFlow, PyTorch)
- Автоматизация и скриптинг
"""

MCP_INTRODUCTION = """# Введение в Model Context Protocol (MCP)

## Что такое MCP?

MCP - открытый протокол для стандартизированной интеграции LLM-приложений
с внешними источниками данных и инструментами.

## Архитектура

- **Host**: LLM-приложение (Claude Desktop, IDE)
- **Client**: Коннектор внутри хоста
- **Server**: Сервис, предоставляющий данные и инструменты

## Транспорты

- **stdio**: Локальные процессы
- **HTTP/SSE**: Удалённые сервисы

## Возможности

- **Tools**: Функции для выполнения
- **Resources**: Контекстные данные
- **Prompts**: Шаблонные сообщения
"""


@app.list_resources()
async def list_resources() -> list[types.Resource]:
    """
    Возвращает список всех доступных ресурсов базы знаний.
    """
    return [
        types.Resource(
            uri="config://server-info",
            name="Server Information",
            mimeType="application/json",
            description="Информация о сервере и его возможностях"
        ),
        types.Resource(
            uri="kb://python-basics",
            name="Python Basics",
            mimeType="text/markdown",
            description="Введение в основы языка Python"
        ),
        types.Resource(
            uri="kb://mcp-introduction",
            name="MCP Introduction",
            mimeType="text/markdown",
            description="Введение в Model Context Protocol"
        ),
        types.Resource(
            uri="stats://usage",
            name="Usage Statistics",
            mimeType="text/plain",
            description="Статистика обращений к ресурсам"
        )
    ]


@app.read_resource()
async def read_resource(uri: str) -> str:
    """
    Читает содержимое ресурса по URI.
    
    Args:
        uri: URI ресурса для чтения
        
    Returns:
        Содержимое ресурса в виде строки
        
    Raises:
        ValueError: Если ресурс не найден
    """
    
    # Увеличиваем счётчик обращений
    resource_access_count[uri] = resource_access_count.get(uri, 0) + 1
    
    if uri == "config://server-info":
        # Возвращаем JSON с информацией о сервере
        info = {
            "name": "knowledge-base-server",
            "version": "1.0.0",
            "resources": 4,
            "prompts": 3,
            "total_accesses": sum(resource_access_count.values())
        }
        return json.dumps(info, indent=2, ensure_ascii=False)
    
    elif uri == "kb://python-basics":
        return PYTHON_BASICS
    
    elif uri == "kb://mcp-introduction":
        return MCP_INTRODUCTION
    
    elif uri == "stats://usage":
        # Формируем статистику обращений
        if not resource_access_count:
            return "Статистика пуста - ресурсы ещё не запрашивались"
        
        stats_lines = ["Статистика обращений к ресурсам:\n"]
        
        # Сортируем по количеству обращений
        sorted_stats = sorted(
            resource_access_count.items(),
            key=lambda x: x[1],
            reverse=True
        )
        
        for uri, count in sorted_stats:
            stats_lines.append(f"  {uri}: {count} обращений")
        
        stats_lines.append(f"\nВсего обращений: {sum(resource_access_count.values())}")
        
        return "\n".join(stats_lines)
    
    else:
        raise ValueError(f"Ресурс '{uri}' не найден")


@app.list_prompts()
async def list_prompts() -> list[types.Prompt]:
    """
    Возвращает список доступных промптов.
    """
    return [
        types.Prompt(
            name="explain_concept",
            description="Генерирует промпт для объяснения концепции программирования",
            arguments=[
                types.PromptArgument(
                    name="concept",
                    description="Название концепции для объяснения",
                    required=True
                ),
                types.PromptArgument(
                    name="level",
                    description="Уровень детализации (beginner/intermediate/advanced)",
                    required=False
                )
            ]
        ),
        types.Prompt(
            name="code_review",
            description="Генерирует промпт для ревью кода",
            arguments=[
                types.PromptArgument(
                    name="language",
                    description="Язык программирования",
                    required=True
                ),
                types.PromptArgument(
                    name="code",
                    description="Код для проверки",
                    required=True
                )
            ]
        ),
        types.Prompt(
            name="compare_technologies",
            description="Генерирует промпт для сравнения технологий",
            arguments=[
                types.PromptArgument(
                    name="tech1",
                    description="Первая технология",
                    required=True
                ),
                types.PromptArgument(
                    name="tech2",
                    description="Вторая технология",
                    required=True
                )
            ]
        )
    ]


@app.get_prompt()
async def get_prompt(name: str, arguments: dict) -> types.GetPromptResult:
    """
    Генерирует промпт с подставленными аргументами.
    
    Args:
        name: Имя промпта
        arguments: Аргументы для подстановки
        
    Returns:
        Сгенерированный промпт
        
    Raises:
        ValueError: Если промпт не найден
    """
    
    if name == "explain_concept":
        concept = arguments.get("concept", "")
        level = arguments.get("level", "beginner")
        
        # Определяем детализацию в зависимости от уровня
        detail_map = {
            "beginner": "простыми словами для новичков",
            "intermediate": "с техническими деталями",
            "advanced": "глубоко, включая внутреннее устройство"
        }
        detail = detail_map.get(level, "простыми словами")
        
        message = f"""Объясни концепцию "{concept}" {detail}.

Структура объяснения:

1. **Определение**
   Что это такое простыми словами?

2. **Зачем это нужно**
   Какую проблему решает?

3. **Примеры использования**
   Покажи практические примеры кода

4. **Распространённые ошибки**
   Какие ошибки часто делают при использовании?

5. **Рекомендации**
   Best practices и советы
"""
        
        return types.GetPromptResult(
            description=f"Объяснение концепции '{concept}' на уровне {level}",
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(type="text", text=message)
                )
            ]
        )
    
    elif name == "code_review":
        language = arguments.get("language", "")
        code = arguments.get("code", "")
        
        message = f"""Проверь следующий код на {language}:

```{language}
{code}
```

Проанализируй код по следующим критериям:

1. **Корректность**
   - Нет ли синтаксических ошибок?
   - Логика работает правильно?

2. **Best Practices**
   - Соответствует ли код стандартам {language}?
   - Используются ли идиоматичные конструкции?

3. **Производительность**
   - Есть ли узкие места?
   - Можно ли оптимизировать?

4. **Читаемость**
   - Понятны ли имена переменных?
   - Достаточно ли комментариев?

5. **Безопасность**
   - Нет ли уязвимостей?
   - Обрабатываются ли ошибки?

Дай конкретные рекомендации для улучшения.
"""
        
        return types.GetPromptResult(
            description=f"Code review для {language}",
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(type="text", text=message)
                )
            ]
        )
    
    elif name == "compare_technologies":
        tech1 = arguments.get("tech1", "")
        tech2 = arguments.get("tech2", "")
        
        message = f"""Сравни технологии {tech1} и {tech2}.

Структура сравнения:

| Критерий | {tech1} | {tech2} |
|----------|---------|---------|
| Назначение | ? | ? |
| Производительность | ? | ? |
| Сложность изучения | ? | ? |
| Экосистема | ? | ? |
| Популярность | ? | ? |

**Когда использовать {tech1}?**
- Случай 1
- Случай 2

**Когда использовать {tech2}?**
- Случай 1
- Случай 2

**Вывод:**
Какую технологию выбрать для типичных задач?
"""
        
        return types.GetPromptResult(
            description=f"Сравнение {tech1} vs {tech2}",
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(type="text", text=message)
                )
            ]
        )
    
    else:
        raise ValueError(f"Промпт '{name}' не найден")


async def main():
    """Точка входа сервера."""
    import sys
    print("Knowledge Base Server запущен", file=sys.stderr)
    
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
```

***

Продолжу создание оставшихся лабораторных работ (Lab 03-06) и утилит в следующем ответе. Всё ли понятно с текущим материалом?

[1](https://modelcontextprotocol.io/specification/2024-11-05)
