Отлично! Продолжаю создание материалов.[1]

***

#### `labs/lab03_async_tools/README.md`

```markdown
# Лабораторная работа 3: Асинхронные инструменты с httpx

## Цели обучения

После выполнения этой лабораторной работы вы сможете:

- Создавать асинхронные инструменты для HTTP запросов
- Использовать httpx для неблокирующих сетевых операций
- Реализовывать параллельное выполнение запросов через asyncio.gather
- Обрабатывать таймауты и ошибки HTTP
- Оптимизировать производительность через переиспользование соединений

## Задание

Создайте MCP-сервер "api-client-server" с асинхронными инструментами для работы с REST API.

### Требования

#### Инструмент 1: `fetch_json`

Загружает JSON данные с указанного URL.

**Параметры:**
- `url` (string, обязательно) - URL для запроса
- `headers` (object, опционально) - дополнительные HTTP заголовки

**Возвращает:**
- Статус код
- Распарсенный JSON
- Время выполнения запроса

#### Инструмент 2: `post_data`

Отправляет POST запрос с JSON данными.

**Параметры:**
- `url` (string, обязательно)
- `data` (object, обязательно) - данные для отправки
- `headers` (object, опционально)

**Возвращает:**
- Статус код ответа
- Тело ответа

#### Инструмент 3: `batch_fetch`

Параллельно загружает данные с нескольких URL.

**Параметры:**
- `urls` (array of strings, обязательно) - список URL
- `timeout` (number, опционально, по умолчанию 30) - таймаут в секундах

**Возвращает:**
- Результаты для каждого URL
- Статистику (успешных/неудачных запросов)
- Общее время выполнения

#### Инструмент 4: `check_status`

Проверяет доступность URL (HEAD запрос).

**Параметры:**
- `url` (string, обязательно)

**Возвращает:**
- Доступен/недоступен
- Статус код
- Время ответа

## Пошаговая инструкция

### Шаг 1: Создание HTTP клиента

```python
import httpx
from typing import Optional

# Глобальный клиент для переиспользования соединений
http_client: Optional[httpx.AsyncClient] = None

async def get_http_client() -> httpx.AsyncClient:
    """
    Возвращает или создаёт глобальный HTTP клиент.
    
    Переиспользование клиента позволяет сохранять TCP соединения
    и повышает производительность при множественных запросах.
    """
    global http_client
    
    if http_client is None:
        http_client = httpx.AsyncClient(
            timeout=30.0,
            follow_redirects=True,
            headers={"User-Agent": "MCP-API-Client/1.0"}
        )
    
    return http_client
```

### Шаг 2: Реализация fetch_json

```python
import time

@app.call_tool()
async def call_tool(name: str, arguments: dict):
    client = await get_http_client()
    
    if name == "fetch_json":
        url = arguments["url"]
        custom_headers = arguments.get("headers", {})
        
        start_time = time.time()
        
        try:
            response = await client.get(url, headers=custom_headers)
            response.raise_for_status()
            
            elapsed = time.time() - start_time
            
            # Парсим JSON
            data = response.json()
            
            result = {
                "status": response.status_code,
                "elapsed_seconds": round(elapsed, 3),
                "data": data
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, ensure_ascii=False)
            )]
        
        except httpx.HTTPError as e:
            return [types.TextContent(
                type="text",
                text=f"HTTP Error: {e}"
            )]
```

### Шаг 3: Параллельные запросы (batch_fetch)

```python
import asyncio

async def fetch_one_url(client: httpx.AsyncClient, url: str) -> dict:
    """Вспомогательная функция для загрузки одного URL."""
    try:
        start = time.time()
        response = await client.get(url)
        elapsed = time.time() - start
        
        return {
            "url": url,
            "status": response.status_code,
            "size": len(response.content),
            "elapsed": round(elapsed, 3),
            "success": True
        }
    except Exception as e:
        return {
            "url": url,
            "error": str(e),
            "success": False
        }

# В call_tool:
if name == "batch_fetch":
    urls = arguments["urls"]
    
    # Запускаем все запросы параллельно
    results = await asyncio.gather(*[
        fetch_one_url(client, url) for url in urls
    ])
    
    # Подсчитываем статистику
    success_count = sum(1 for r in results if r["success"])
    # ... форматируем результат
```

### Шаг 4: Очистка ресурсов

```python
async def main():
    try:
        async with stdio_server() as (read_stream, write_stream):
            await app.run(...)
    finally:
        # Закрываем HTTP клиент при завершении
        global http_client
        if http_client is not None:
            await http_client.aclose()
```

### Шаг 5: Тестирование

Создайте тестовый клиент или используйте публичные API:

```python
# Тестовые URL
urls = [
    "https://jsonplaceholder.typicode.com/posts/1",
    "https://api.github.com/users/octocat",
    "https://httpbin.org/delay/2"
]

# Тест batch_fetch
result = await session.call_tool(
    "batch_fetch",
    {"urls": urls, "timeout": 10}
)
```

## Критерии проверки

- [ ] Все 4 инструмента реализованы корректно
- [ ] HTTP клиент переиспользуется между запросами
- [ ] Параллельные запросы выполняются действительно параллельно
- [ ] Таймауты обрабатываются правильно
- [ ] HTTP ошибки не ломают сервер, а возвращаются как результат
- [ ] Время выполнения измеряется точно
- [ ] Клиент закрывается при завершении сервера

## Дополнительное задание

1. Добавьте инструмент `download_file` для загрузки больших файлов
2. Реализуйте retry логику с экспоненциальным backoff
3. Добавьте кэширование результатов GET запросов

## Подсказки

1. Используйте `time.perf_counter()` для точного измерения времени
2. `asyncio.gather()` выполняет задачи параллельно
3. `response.raise_for_status()` выбрасывает исключение для HTTP ошибок
4. Используйте `try/except httpx.HTTPError` для обработки всех HTTP ошибок
5. Не забудьте `await client.aclose()` в finally блоке

## Время выполнения

Ожидаемое время: 60-75 минут

## Следующие шаги

После выполнения переходите к Lab 04: HTTP/SSE транспорт
```

***

#### `labs/lab03_async_tools/solution/server.py`

```python
#!/usr/bin/env python3
"""
Решение Lab 03: Асинхронные инструменты с httpx

MCP сервер для работы с REST API через асинхронные запросы.
"""

import asyncio
import httpx
import json
import time
from typing import Optional
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём сервер
app = Server("api-client-server")

# Глобальный HTTP клиент для переиспользования соединений
http_client: Optional[httpx.AsyncClient] = None


async def get_http_client() -> httpx.AsyncClient:
    """
    Возвращает или создаёт глобальный HTTP клиент.
    
    Переиспользование клиента позволяет:
    - Сохранять TCP соединения (connection pooling)
    - Уменьшить overhead на создание соединений
    - Повысить производительность при множественных запросах
    
    Returns:
        Асинхронный HTTP клиент
    """
    global http_client
    
    if http_client is None:
        http_client = httpx.AsyncClient(
            timeout=30.0,  # Таймаут по умолчанию
            follow_redirects=True,  # Следовать HTTP редиректам
            headers={
                "User-Agent": "MCP-API-Client/1.0"
            },
            limits=httpx.Limits(
                max_connections=100,  # Максимум соединений
                max_keepalive_connections=20  # Keepalive соединений
            )
        )
    
    return http_client


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """Регистрирует асинхронные инструменты для работы с API."""
    return [
        types.Tool(
            name="fetch_json",
            description="Асинхронно загружает JSON данные с указанного URL",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для GET запроса"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Дополнительные HTTP заголовки (опционально)",
                        "additionalProperties": {"type": "string"}
                    }
                },
                "required": ["url"]
            }
        ),
        types.Tool(
            name="post_data",
            description="Отправляет POST запрос с JSON данными",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для POST запроса"
                    },
                    "data": {
                        "type": "object",
                        "description": "JSON данные для отправки"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Дополнительные HTTP заголовки (опционально)"
                    }
                },
                "required": ["url", "data"]
            }
        ),
        types.Tool(
            name="batch_fetch",
            description="Параллельно загружает данные с нескольких URL",
            inputSchema={
                "type": "object",
                "properties": {
                    "urls": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Список URL для загрузки"
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Таймаут для каждого запроса в секундах",
                        "default": 30
                    }
                },
                "required": ["urls"]
            }
        ),
        types.Tool(
            name="check_status",
            description="Проверяет доступность URL через HEAD запрос",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для проверки"
                    }
                },
                "required": ["url"]
            }
        )
    ]


async def fetch_one_url(
    client: httpx.AsyncClient,
    url: str,
    timeout: float = 30.0
) -> dict:
    """
    Вспомогательная функция для загрузки одного URL.
    
    Args:
        client: HTTP клиент
        url: URL для загрузки
        timeout: Таймаут в секундах
        
    Returns:
        Словарь с результатом (успех или ошибка)
    """
    try:
        start = time.perf_counter()
        
        # Выполняем GET запрос с таймаутом
        response = await client.get(url, timeout=timeout)
        
        elapsed = time.perf_counter() - start
        
        return {
            "url": url,
            "status": response.status_code,
            "size_bytes": len(response.content),
            "elapsed_seconds": round(elapsed, 3),
            "success": True,
            "content_type": response.headers.get("content-type", "unknown")
        }
    
    except httpx.TimeoutException:
        return {
            "url": url,
            "error": f"Timeout after {timeout}s",
            "success": False
        }
    except httpx.HTTPError as e:
        return {
            "url": url,
            "error": str(e),
            "success": False
        }
    except Exception as e:
        return {
            "url": url,
            "error": f"Unexpected error: {str(e)}",
            "success": False
        }


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    """
    Обрабатывает вызовы асинхронных инструментов.
    """
    
    # Получаем HTTP клиент
    client = await get_http_client()
    
    if name == "fetch_json":
        url = arguments["url"]
        custom_headers = arguments.get("headers", {})
        
        start_time = time.perf_counter()
        
        try:
            # Выполняем GET запрос
            response = await client.get(url, headers=custom_headers)
            response.raise_for_status()
            
            elapsed = time.perf_counter() - start_time
            
            # Парсим JSON
            try:
                data = response.json()
            except json.JSONDecodeError:
                data = {"raw_text": response.text[:500]}  # Первые 500 символов
            
            # Формируем результат
            result = {
                "url": url,
                "status": response.status_code,
                "elapsed_seconds": round(elapsed, 3),
                "content_type": response.headers.get("content-type"),
                "data": data
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, ensure_ascii=False)
            )]
        
        except httpx.HTTPError as e:
            return [types.TextContent(
                type="text",
                text=f"HTTP Error при загрузке {url}: {e}"
            )]
    
    elif name == "post_data":
        url = arguments["url"]
        data = arguments["data"]
        custom_headers = arguments.get("headers", {})
        
        try:
            # Отправляем POST запрос с JSON
            response = await client.post(
                url,
                json=data,
                headers=custom_headers
            )
            response.raise_for_status()
            
            # Формируем результат
            result = {
                "url": url,
                "status": response.status_code,
                "response_body": response.text[:1000]  # Первые 1000 символов
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, ensure_ascii=False)
            )]
        
        except httpx.HTTPError as e:
            return [types.TextContent(
                type="text",
                text=f"HTTP Error при POST запросе к {url}: {e}"
            )]
    
    elif name == "batch_fetch":
        urls = arguments["urls"]
        timeout = arguments.get("timeout", 30.0)
        
        # Засекаем общее время
        batch_start = time.perf_counter()
        
        # Запускаем все запросы параллельно через asyncio.gather
        results = await asyncio.gather(*[
            fetch_one_url(client, url, timeout)
            for url in urls
        ])
        
        batch_elapsed = time.perf_counter() - batch_start
        
        # Подсчитываем статистику
        success_count = sum(1 for r in results if r["success"])
        failed_count = len(results) - success_count
        
        # Подсчитываем общий размер загруженных данных
        total_bytes = sum(r.get("size_bytes", 0) for r in results if r["success"])
        
        # Формируем отчёт
        report_lines = [
            f"Параллельная загрузка {len(urls)} URL завершена\n",
            f"📊 Статистика:",
            f"  ✅ Успешных: {success_count}",
            f"  ❌ Неудачных: {failed_count}",
            f"  📦 Загружено: {total_bytes} байт",
            f"  ⏱️  Общее время: {round(batch_elapsed, 3)}s\n",
            f"📋 Детали по каждому URL:\n"
        ]
        
        for result in results:
            if result["success"]:
                report_lines.append(
                    f"  ✅ {result['url']}: "
                    f"{result['status']} ({result['size_bytes']} байт, "
                    f"{result['elapsed_seconds']}s)"
                )
            else:
                report_lines.append(
                    f"  ❌ {result['url']}: {result['error']}"
                )
        
        return [types.TextContent(
            type="text",
            text="\n".join(report_lines)
        )]
    
    elif name == "check_status":
        url = arguments["url"]
        
        try:
            start = time.perf_counter()
            
            # HEAD запрос для проверки доступности
            response = await client.head(url)
            
            elapsed = time.perf_counter() - start
            
            # Формируем результат
            is_available = 200 <= response.status_code < 400
            
            result = (
                f"URL: {url}\n"
                f"Статус: {'✅ Доступен' if is_available else '❌ Недоступен'}\n"
                f"HTTP код: {response.status_code}\n"
                f"Время ответа: {round(elapsed * 1000, 1)} мс\n"
                f"Сервер: {response.headers.get('server', 'unknown')}"
            )
            
            return [types.TextContent(type="text", text=result)]
        
        except httpx.HTTPError as e:
            return [types.TextContent(
                type="text",
                text=f"❌ URL недоступен: {e}"
            )]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


async def main():
    """Точка входа сервера."""
    import sys
    print("API Client Server запущен", file=sys.stderr)
    
    try:
        async with stdio_server() as (read_stream, write_stream):
            await app.run(
                read_stream,
                write_stream,
                app.create_initialization_options()
            )
    finally:
        # Обязательно закрываем HTTP клиент при завершении
        global http_client
        if http_client is not None:
            await http_client.aclose()
            print("HTTP клиент закрыт", file=sys.stderr)


if __name__ == "__main__":
    asyncio.run(main())
```

***

#### `labs/lab04_http_transport/README.md`

```markdown
# Лабораторная работа 4: HTTP/SSE транспорт

## Цели обучения

После выполнения этой лабораторной работы вы сможете:

- Создавать MCP-сервер с HTTP/SSE транспортом
- Настраивать Starlette приложение для MCP
- Понимать разницу между stdio и HTTP транспортами
- Тестировать удалённый сервер через SSE клиента
- Развёртывать масштабируемый MCP сервер

## Задание

Преобразуйте один из ваших предыдущих серверов (Lab 01 или Lab 02) для работы через HTTP/SSE транспорт.

### Требования

1. Сервер должен работать на HTTP (порт 8000)
2. SSE эндпоинт: `GET /sse`
3. Эндпоинт для сообщений: `POST /messages/`
4. Все инструменты должны работать идентично stdio версии
5. Добавьте health-check эндпоинт: `GET /health`

### Архитектура HTTP/SSE транспорта

```
Client                          Server
  │                               │
  │────GET /sse──────────────────►│ Открывает SSE stream
  │                               │
  │◄───SSE event (ready)──────────│
  │                               │
  │────POST /messages/────────────►│ Отправляет request
  │◄───SSE event (response)───────│ Получает response
  │                               │
  │────POST /messages/────────────►│ Следующий request
  │◄───SSE event (response)───────│
```

## Пошаговая инструкция

### Шаг 1: Установка зависимостей

Убедитесь, что установлены необходимые пакеты:

```bash
pip install starlette uvicorn
```

### Шаг 2: Создание SSE транспорта

```python
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Route, Mount
from starlette.responses import Response
import uvicorn

# Создаём SSE транспорт
sse = SseServerTransport("/messages/")

async def handle_sse(request):
    """
    Обработчик SSE соединения.
    
    Держит соединение открытым и передаёт события клиенту.
    """
    async with sse.connect_sse(
        request.scope,
        request.receive,
        request._send
    ) as streams:
        await app.run(
            streams,
            streams,[1]
            app.create_initialization_options()
        )
    return Response()
```

### Шаг 3: Создание Starlette приложения

```python
# Health-check эндпоинт
async def health_check(request):
    return JSONResponse({"status": "healthy"})

# Создаём Starlette приложение
starlette_app = Starlette(
    debug=True,
    routes=[
        Route("/health", endpoint=health_check, methods=["GET"]),
        Route("/sse", endpoint=handle_sse, methods=["GET"]),
        Mount("/messages/", app=sse.handle_post_message)
    ]
)
```

### Шаг 4: Запуск сервера

```python
def main():
    uvicorn.run(
        starlette_app,
        host="127.0.0.1",
        port=8000,
        log_level="info"
    )

if __name__ == "__main__":
    main()
```

### Шаг 5: Создание клиента для тестирования

```python
# client.py
import asyncio
from mcp import ClientSession
from mcp.client.sse import sse_client

async def test_http_server():
    server_url = "http://127.0.0.1:8000/sse"
    
    async with sse_client(server_url) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            
            # Тестируем инструменты
            tools = await session.list_tools()
            print(f"Инструментов: {len(tools.tools)}")
            
            # Вызываем инструмент
            result = await session.call_tool(...)
            print(result)

asyncio.run(test_http_server())
```

### Шаг 6: Тестирование

**Терминал 1: Запуск сервера**
```bash
python server.py
```

**Терминал 2: Тест health-check**
```bash
curl http://127.0.0.1:8000/health
```

**Терминал 3: Запуск клиента**
```bash
python client.py
```

## Критерии проверки

- [ ] Сервер запускается на порту 8000
- [ ] `/health` эндпоинт возвращает 200 OK
- [ ] `/sse` эндпоинт устанавливает SSE соединение
- [ ] Клиент успешно подключается и получает список инструментов
- [ ] Все инструменты работают идентично stdio версии
- [ ] Сервер можно остановить через Ctrl+C без ошибок
- [ ] Множественные клиенты могут подключаться одновременно

## Дополнительное задание

1. Добавьте CORS middleware для доступа из браузера
2. Реализуйте аутентификацию через API ключи
3. Добавьте rate limiting
4. Создайте простой веб-интерфейс для тестирования

## Сравнение stdio vs HTTP/SSE

| Аспект | stdio | HTTP/SSE |
|--------|-------|----------|
| Сценарий использования | Локальные инструменты | Удалённые сервисы |
| Масштабируемость | Один процесс | Множество клиентов |
| Безопасность | Локальная изоляция | HTTPS, токены |
| Развёртывание | Простое | Требует веб-сервер |
| Отладка | Простая | Сложнее |

## Подсказки

1. Убедитесь, что порт 8000 свободен
2. Используйте `debug=True` в Starlette для детальных логов
3. SSE соединение держится открытым - это нормально
4. Для остановки сервера используйте Ctrl+C (SIGINT)
5. Проверьте логи uvicorn для диагностики проблем

## Время выполнения

Ожидаемое время: 45-60 минут

## Следующие шаги

После выполнения переходите к Lab 05: Progress notifications
```

***

#### `labs/lab04_http_transport/solution/server.py`

```python
#!/usr/bin/env python3
"""
Решение Lab 04: HTTP/SSE транспорт

Text Tools Server с HTTP/SSE транспортом вместо stdio.
"""

import asyncio
import re
from mcp.server.lowlevel import Server
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Route, Mount
from starlette.responses import Response, JSONResponse
import uvicorn
import mcp.types as types


# Создаём MCP сервер (переиспользуем логику из Lab 01)
app = Server("text-tools-http-server")


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """Регистрирует инструменты для обработки текста."""
    return [
        types.Tool(
            name="count_words",
            description="Подсчитывает количество слов, символов и строк в тексте",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Текст для анализа"
                    }
                },
                "required": ["text"]
            }
        ),
        types.Tool(
            name="to_uppercase",
            description="Преобразует весь текст в верхний регистр",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Текст для преобразования"
                    }
                },
                "required": ["text"]
            }
        ),
        types.Tool(
            name="replace_text",
            description="Заменяет все вхождения одной подстроки на другую",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {"type": "string"},
                    "search": {"type": "string"},
                    "replace": {"type": "string"},
                    "case_sensitive": {
                        "type": "boolean",
                        "default": True
                    }
                },
                "required": ["text", "search", "replace"]
            }
        )
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    """Обрабатывает вызовы инструментов."""
    
    if name == "count_words":
        text = arguments["text"]
        words = text.split()
        
        result_text = (
            f"Анализ текста:\n"
            f"- Слов: {len(words)}\n"
            f"- Символов: {len(text)}\n"
            f"- Строк: {text.count(chr(10)) + 1 if text else 0}"
        )
        
        return [types.TextContent(type="text", text=result_text)]
    
    elif name == "to_uppercase":
        text = arguments["text"]
        return [types.TextContent(type="text", text=text.upper())]
    
    elif name == "replace_text":
        text = arguments["text"]
        search = arguments["search"]
        replace = arguments["replace"]
        case_sensitive = arguments.get("case_sensitive", True)
        
        if case_sensitive:
            result = text.replace(search, replace)
            count = text.count(search)
        else:
            pattern = re.compile(re.escape(search), re.IGNORECASE)
            count = len(pattern.findall(text))
            result = pattern.sub(replace, text)
        
        result_text = f"Выполнено замен: {count}\n\nРезультат:\n{result}"
        
        return [types.TextContent(type="text", text=result_text)]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


def create_http_app():
    """
    Создаёт Starlette приложение с SSE транспортом для MCP.
    
    Returns:
        Starlette приложение, готовое к запуску через uvicorn
    """
    
    # Создаём SSE транспорт с эндпоинтом для POST сообщений
    sse = SseServerTransport("/messages/")
    
    async def handle_sse(request):
        """
        Обработчик SSE соединения.
        
        Устанавливает долгоживущее Server-Sent Events соединение
        с клиентом для передачи MCP сообщений.
        """
        async with sse.connect_sse(
            request.scope,
            request.receive,
            request._send
        ) as streams:
            # Запускаем MCP сервер на этом SSE соединении
            await app.run(
                streams[0],  # read stream
                streams[1],  # write stream
                app.create_initialization_options()
            )
        return Response()
    
    async def health_check(request):
        """
        Health-check эндпоинт для мониторинга состояния сервера.
        
        Возвращает JSON с информацией о сервере.
        """
        return JSONResponse({
            "status": "healthy",
            "server": "text-tools-http-server",
            "version": "1.0.0",
            "transport": "HTTP/SSE"
        })
    
    async def root(request):
        """Корневой эндпоинт с информацией о сервере."""
        return JSONResponse({
            "name": "Text Tools MCP Server",
            "endpoints": {
                "sse": "GET /sse - SSE connection for MCP",
                "messages": "POST /messages/ - MCP messages endpoint",
                "health": "GET /health - Health check"
            },
            "usage": "Use MCP SSE client to connect to /sse endpoint"
        })
    
    # Создаём Starlette приложение с маршрутами
    starlette_app = Starlette(
        debug=True,
        routes=[
            Route("/", endpoint=root, methods=["GET"]),
            Route("/health", endpoint=health_check, methods=["GET"]),
            Route("/sse", endpoint=handle_sse, methods=["GET"]),
            Mount("/messages/", app=sse.handle_post_message)
        ]
    )
    
    return starlette_app


def main():
    """
    Точка входа для HTTP сервера.
    
    Запускает uvicorn на localhost:8000.
    """
    import sys
    print("=" * 60, file=sys.stderr)
    print("Text Tools HTTP/SSE Server", file=sys.stderr)
    print("=" * 60, file=sys.stderr)
    print(f"Server starting on http://127.0.0.1:8000", file=sys.stderr)
    print(f"SSE endpoint: http://127.0.0.1:8000/sse", file=sys.stderr)
    print(f"Health check: http://127.0.0.1:8000/health", file=sys.stderr)
    print("=" * 60, file=sys.stderr)
    
    # Создаём приложение
    starlette_app = create_http_app()
    
    # Запускаем uvicorn
    uvicorn.run(
        starlette_app,
        host="127.0.0.1",
        port=8000,
        log_level="info",
        access_log=True
    )


if __name__ == "__main__":
    main()
```

***

Продолжу с Lab 05, Lab 06 и утилитами в следующем ответе. Готов?

[1](https://modelcontextprotocol.io/specification/2024-11-05)
