Отлично! Продолжаю создание материалов курса.[1]

***

### Примеры кода

#### `examples/simple_server_stdio.py`

```python
#!/usr/bin/env python3
"""
Простейший MCP сервер с stdio транспортом.

Демонстрирует базовую структуру сервера с одним инструментом.
"""

import asyncio
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём экземпляр сервера с уникальным именем
app = Server("simple-calculator")


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """
    Регистрирует доступные инструменты сервера.
    
    Этот handler вызывается клиентом для обнаружения возможностей.
    
    Returns:
        Список объектов Tool с описанием инструментов
    """
    return [
        types.Tool(
            name="add",
            description="Складывает два числа и возвращает результат",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {
                        "type": "number",
                        "description": "Первое слагаемое"
                    },
                    "b": {
                        "type": "number",
                        "description": "Второе слагаемое"
                    }
                },
                "required": ["a", "b"]
            }
        ),
        types.Tool(
            name="multiply",
            description="Умножает два числа",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {
                        "type": "number",
                        "description": "Первый множитель"
                    },
                    "b": {
                        "type": "number",
                        "description": "Второй множитель"
                    }
                },
                "required": ["a", "b"]
            }
        )
    ]


@app.call_tool()
async def call_tool(
    name: str,
    arguments: dict
) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
    """
    Обрабатывает вызов инструмента.
    
    Args:
        name: Имя вызываемого инструмента
        arguments: Словарь с аргументами инструмента
        
    Returns:
        Список контент-объектов с результатом выполнения
        
    Raises:
        ValueError: Если инструмент не найден или аргументы невалидны
    """
    
    # Валидация наличия обязательных аргументов
    if "a" not in arguments or "b" not in arguments:
        raise ValueError("Отсутствуют обязательные параметры 'a' и 'b'")
    
    # Получаем значения аргументов
    a = arguments["a"]
    b = arguments["b"]
    
    # Выполняем операцию в зависимости от имени инструмента
    if name == "add":
        result = a + b
        operation = "сложения"
    elif name == "multiply":
        result = a * b
        operation = "умножения"
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")
    
    # Формируем текстовый ответ
    response_text = f"Результат {operation}: {a} и {b} = {result}"
    
    # Возвращаем результат как TextContent
    return [
        types.TextContent(
            type="text",
            text=response_text
        )
    ]


async def main():
    """
    Точка входа сервера.
    
    Создаёт stdio транспорт и запускает сервер в бесконечном цикле
    обработки запросов от клиента.
    """
    # Создаём stdio транспорт (читает из stdin, пишет в stdout)
    async with stdio_server() as (read_stream, write_stream):
        # Запускаем основной цикл сервера
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )


if __name__ == "__main__":
    # Запускаем асинхронную main функцию
    asyncio.run(main())
```

#### `examples/simple_server_http.py`

```python
#!/usr/bin/env python3
"""
Простейший MCP сервер с HTTP/SSE транспортом.

Демонстрирует создание удалённого сервера, доступного по HTTP.
"""

import asyncio
from mcp.server.lowlevel import Server
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Route, Mount
from starlette.responses import Response
import uvicorn
import mcp.types as types


# Создаём MCP сервер
app = Server("simple-http-server")


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """
    Возвращает список инструментов для HTTP сервера.
    """
    return [
        types.Tool(
            name="echo",
            description="Возвращает переданное сообщение",
            inputSchema={
                "type": "object",
                "properties": {
                    "message": {
                        "type": "string",
                        "description": "Сообщение для возврата"
                    }
                },
                "required": ["message"]
            }
        ),
        types.Tool(
            name="reverse",
            description="Переворачивает строку задом наперёд",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Текст для переворота"
                    }
                },
                "required": ["text"]
            }
        )
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    """
    Обрабатывает вызов инструмента.
    """
    if name == "echo":
        # Просто возвращаем сообщение
        message = arguments.get("message", "")
        return [types.TextContent(type="text", text=f"Echo: {message}")]
    
    elif name == "reverse":
        # Переворачиваем текст
        text = arguments.get("text", "")
        reversed_text = text[::-1]
        return [types.TextContent(type="text", text=reversed_text)]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


def create_app():
    """
    Создаёт Starlette приложение с SSE транспортом.
    
    Returns:
        Starlette приложение, готовое к запуску
    """
    # Создаём SSE транспорт с эндпоинтом для POST сообщений
    sse = SseServerTransport("/messages/")
    
    async def handle_sse(request):
        """
        Обработчик SSE соединения.
        
        Устанавливает долгоживущее SSE соединение с клиентом
        и обрабатывает MCP протокол через него.
        """
        async with sse.connect_sse(
            request.scope,
            request.receive,
            request._send
        ) as streams:
            # Запускаем MCP сервер на этом соединении
            await app.run(
                streams[0],  # read stream
                streams[1],  # write stream
                app.create_initialization_options()
            )
        return Response()
    
    # Создаём Starlette приложение с маршрутами
    starlette_app = Starlette(
        debug=True,
        routes=[
            # GET /sse - устанавливает SSE соединение
            Route("/sse", endpoint=handle_sse, methods=["GET"]),
            # POST /messages/* - принимает сообщения от клиента
            Mount("/messages/", app=sse.handle_post_message)
        ]
    )
    
    return starlette_app


def main():
    """
    Точка входа для HTTP сервера.
    
    Запускает uvicorn сервер на localhost:8000.
    """
    starlette_app = create_app()
    
    # Запускаем uvicorn
    uvicorn.run(
        starlette_app,
        host="127.0.0.1",
        port=8000,
        log_level="info"
    )


if __name__ == "__main__":
    main()
```

#### `examples/simple_client_stdio.py`

```python
#!/usr/bin/env python3
"""
Простой MCP клиент для подключения к stdio серверу.

Демонстрирует базовое взаимодействие клиента с сервером.
"""

import asyncio
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client


async def main():
    """
    Основная функция клиента.
    
    Подключается к серверу, получает список инструментов и вызывает их.
    """
    
    # Параметры запуска серверного процесса
    server_params = StdioServerParameters(
        command="python",  # Команда для запуска
        args=["examples/simple_server_stdio.py"],  # Путь к серверу
        env=None  # Переменные окружения (опционально)
    )
    
    print("🚀 Подключение к MCP серверу...\n")
    
    # Создаём контекстный менеджер для stdio клиента
    # Это автоматически запускает серверный процесс
    async with stdio_client(server_params) as (read, write):
        # Создаём клиентскую сессию
        async with ClientSession(read, write) as session:
            
            # === Инициализация ===
            print("🔗 Инициализация соединения...")
            await session.initialize()
            print("✅ Соединение установлено\n")
            
            # === Получение списка инструментов ===
            print("📦 Получение списка инструментов...")
            tools_result = await session.list_tools()
            
            print(f"✅ Доступно инструментов: {len(tools_result.tools)}\n")
            
            for tool in tools_result.tools:
                print(f"  🔧 {tool.name}: {tool.description}")
            
            print()
            
            # === Вызов инструмента add ===
            print("➕ Вызов инструмента 'add' с аргументами a=15, b=27...")
            
            result = await session.call_tool(
                name="add",
                arguments={"a": 15, "b": 27}
            )
            
            # Извлекаем текст из результата
            for content_item in result.content:
                if hasattr(content_item, 'text'):
                    print(f"✅ Результат: {content_item.text}\n")
            
            # === Вызов инструмента multiply ===
            print("✖️  Вызов инструмента 'multiply' с аргументами a=8, b=7...")
            
            result = await session.call_tool(
                name="multiply",
                arguments={"a": 8, "b": 7}
            )
            
            for content_item in result.content:
                if hasattr(content_item, 'text'):
                    print(f"✅ Результат: {content_item.text}\n")
            
            # === Обработка ошибки ===
            print("❌ Попытка вызова с отсутствующим параметром...")
            
            try:
                result = await session.call_tool(
                    name="add",
                    arguments={"a": 5}  # Отсутствует параметр 'b'
                )
            except Exception as e:
                print(f"🚨 Получена ожидаемая ошибка: {e}\n")
    
    print("👋 Соединение закрыто")


if __name__ == "__main__":
    asyncio.run(main())
```

#### `examples/simple_client_http.py`

```python
#!/usr/bin/env python3
"""
Простой MCP клиент для подключения к HTTP/SSE серверу.

Демонстрирует удалённое взаимодействие через HTTP.
"""

import asyncio
from mcp import ClientSession
from mcp.client.sse import sse_client


async def main():
    """
    Основная функция HTTP клиента.
    
    Подключается к удалённому серверу через SSE.
    """
    
    # URL SSE эндпоинта сервера
    server_url = "http://127.0.0.1:8000/sse"
    
    print(f"🚀 Подключение к HTTP/SSE серверу: {server_url}\n")
    
    # Создаём SSE клиент
    async with sse_client(server_url) as (read, write):
        async with ClientSession(read, write) as session:
            
            # === Инициализация ===
            print("🔗 Инициализация соединения...")
            await session.initialize()
            print("✅ Соединение установлено\n")
            
            # === Получение инструментов ===
            print("📦 Получение списка инструментов...")
            tools_result = await session.list_tools()
            
            print(f"✅ Доступно инструментов: {len(tools_result.tools)}\n")
            
            for tool in tools_result.tools:
                print(f"  🔧 {tool.name}: {tool.description}")
            
            print()
            
            # === Тест echo ===
            print("📢 Вызов инструмента 'echo'...")
            
            result = await session.call_tool(
                name="echo",
                arguments={"message": "Привет из MCP клиента!"}
            )
            
            for content_item in result.content:
                if hasattr(content_item, 'text'):
                    print(f"✅ Ответ: {content_item.text}\n")
            
            # === Тест reverse ===
            print("🔄 Вызов инструмента 'reverse'...")
            
            result = await session.call_tool(
                name="reverse",
                arguments={"text": "Model Context Protocol"}
            )
            
            for content_item in result.content:
                if hasattr(content_item, 'text'):
                    print(f"✅ Результат: {content_item.text}\n")
    
    print("👋 Соединение закрыто")


if __name__ == "__main__":
    # Примечание: перед запуском необходимо запустить simple_server_http.py
    print("⚠️  Убедитесь, что simple_server_http.py запущен!\n")
    asyncio.run(main())
```

#### `examples/async_tools_example.py`

```python
#!/usr/bin/env python3
"""
Пример MCP сервера с асинхронными инструментами.

Использует httpx для асинхронных HTTP запросов.
Демонстрирует работу с внешними API в инструментах.
"""

import asyncio
import httpx
from typing import Optional
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём сервер
app = Server("async-tools-server")

# Глобальный HTTP клиент для повторного использования соединений
http_client: Optional[httpx.AsyncClient] = None


async def get_http_client() -> httpx.AsyncClient:
    """
    Возвращает или создаёт глобальный HTTP клиент.
    
    Использование глобального клиента позволяет переиспользовать
    TCP соединения и повышает производительность.
    
    Returns:
        Асинхронный HTTP клиент
    """
    global http_client
    
    if http_client is None:
        http_client = httpx.AsyncClient(
            timeout=30.0,  # Таймаут 30 секунд
            follow_redirects=True,  # Следовать редиректам
            headers={
                "User-Agent": "MCP-Async-Tools/1.0"
            }
        )
    
    return http_client


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """
    Регистрирует асинхронные инструменты.
    """
    return [
        types.Tool(
            name="fetch_url",
            description="Асинхронно загружает содержимое URL через HTTP GET",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для загрузки"
                    }
                },
                "required": ["url"]
            }
        ),
        types.Tool(
            name="fetch_multiple",
            description="Параллельно загружает несколько URL",
            inputSchema={
                "type": "object",
                "properties": {
                    "urls": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Список URL для загрузки"
                    }
                },
                "required": ["urls"]
            }
        ),
        types.Tool(
            name="post_json",
            description="Отправляет POST запрос с JSON данными",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для POST запроса"
                    },
                    "data": {
                        "type": "object",
                        "description": "JSON данные для отправки"
                    }
                },
                "required": ["url", "data"]
            }
        )
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    """
    Обрабатывает вызовы асинхронных инструментов.
    """
    
    # Получаем HTTP клиент
    client = await get_http_client()
    
    if name == "fetch_url":
        # Одиночный асинхронный запрос
        url = arguments["url"]
        
        try:
            # Асинхронный GET запрос
            response = await client.get(url)
            response.raise_for_status()  # Вызывает исключение для HTTP ошибок
            
            # Формируем результат
            result_text = (
                f"URL: {url}\n"
                f"Статус: {response.status_code}\n"
                f"Content-Type: {response.headers.get('content-type', 'unknown')}\n"
                f"Размер: {len(response.content)} байт\n\n"
                f"Содержимое (первые 500 символов):\n{response.text[:500]}"
            )
            
            return [types.TextContent(type="text", text=result_text)]
        
        except httpx.HTTPError as e:
            return [types.TextContent(type="text", text=f"Ошибка HTTP: {e}")]
    
    elif name == "fetch_multiple":
        # Параллельные асинхронные запросы
        urls = arguments["urls"]
        
        async def fetch_one(url: str) -> dict:
            """
            Вспомогательная функция для загрузки одного URL.
            
            Args:
                url: URL для загрузки
                
            Returns:
                Словарь с результатом
            """
            try:
                response = await client.get(url)
                response.raise_for_status()
                
                return {
                    "url": url,
                    "status": response.status_code,
                    "size": len(response.content),
                    "success": True
                }
            except Exception as e:
                return {
                    "url": url,
                    "error": str(e),
                    "success": False
                }
        
        # Запускаем все запросы параллельно с помощью asyncio.gather
        results = await asyncio.gather(*[fetch_one(url) for url in urls])
        
        # Форматируем результаты
        result_lines = [f"Загружено {len(urls)} URL параллельно:\n"]
        
        for result in results:
            if result["success"]:
                result_lines.append(
                    f"✅ {result['url']}: {result['status']} ({result['size']} байт)"
                )
            else:
                result_lines.append(
                    f"❌ {result['url']}: {result['error']}"
                )
        
        return [types.TextContent(type="text", text="\n".join(result_lines))]
    
    elif name == "post_json":
        # Асинхронный POST запрос с JSON
        url = arguments["url"]
        data = arguments["data"]
        
        try:
            # Отправляем JSON данные
            response = await client.post(url, json=data)
            response.raise_for_status()
            
            result_text = (
                f"POST {url}\n"
                f"Статус ответа: {response.status_code}\n"
                f"Ответ сервера:\n{response.text[:500]}"
            )
            
            return [types.TextContent(type="text", text=result_text)]
        
        except httpx.HTTPError as e:
            return [types.TextContent(type="text", text=f"Ошибка POST: {e}")]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


async def main():
    """
    Точка входа сервера.
    """
    import sys
    print("Async Tools Server запущен", file=sys.stderr)
    
    try:
        async with stdio_server() as (read_stream, write_stream):
            await app.run(
                read_stream,
                write_stream,
                app.create_initialization_options()
            )
    finally:
        # Закрываем HTTP клиент при завершении
        global http_client
        if http_client is not None:
            await http_client.aclose()
            print("HTTP клиент закрыт", file=sys.stderr)


if __name__ == "__main__":
    asyncio.run(main())
```

#### `examples/progress_notifications.py`

```python
#!/usr/bin/env python3
"""
Пример MCP сервера с поддержкой progress notifications.

Демонстрирует отправку уведомлений о прогрессе выполнения
длительных операций.
"""

import asyncio
from typing import Optional
from mcp.server.lowlevel import Server, NotificationOptions
from mcp.server.stdio import stdio_server
import mcp.types as types


# Создаём сервер
app = Server("progress-server")


@app.list_tools()
async def list_tools() -> list[types.Tool]:
    """
    Регистрирует инструменты с поддержкой прогресса.
    """
    return [
        types.Tool(
            name="process_large_file",
            description="Обрабатывает большой файл с отчётом о прогрессе",
            inputSchema={
                "type": "object",
                "properties": {
                    "filename": {
                        "type": "string",
                        "description": "Имя файла для обработки"
                    },
                    "chunks": {
                        "type": "integer",
                        "description": "Количество чанков для обработки",
                        "default": 10
                    }
                },
                "required": ["filename"]
            }
        ),
        types.Tool(
            name="download_with_progress",
            description="Симулирует загрузку с отчётом о прогрессе",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL для загрузки"
                    },
                    "total_mb": {
                        "type": "integer",
                        "description": "Размер загрузки в МБ",
                        "default": 100
                    }
                },
                "required": ["url"]
            }
        )
    ]


async def send_progress(
    progress_token: Optional[str],
    progress: int,
    total: int,
    message: Optional[str] = None
):
    """
    Вспомогательная функция для отправки progress notification.
    
    Args:
        progress_token: Токен прогресса из запроса клиента
        progress: Текущий прогресс
        total: Общее количество единиц работы
        message: Опциональное текстовое сообщение
    """
    if progress_token is None:
        # Клиент не запросил progress notifications
        return
    
    # Отправляем notification через сессию
    # Примечание: в реальном коде нужен доступ к request context
    # Это упрощённая версия для демонстрации концепции
    import sys
    print(
        f"[PROGRESS] {progress}/{total} - {message or ''}",
        file=sys.stderr
    )


@app.call_tool()
async def call_tool(
    name: str,
    arguments: dict
) -> list[types.TextContent]:
    """
    Обрабатывает инструменты с progress notifications.
    
    В реальной реализации progress_token извлекается из request context:
    request_context.meta.get('progressToken')
    """
    
    # В этом примере мы симулируем progressToken
    # В реальном коде он берётся из request context
    progress_token = "demo-token-123"
    
    if name == "process_large_file":
        filename = arguments["filename"]
        chunks = arguments.get("chunks", 10)
        
        results = []
        
        # Инициализация - 0% прогресс
        await send_progress(progress_token, 0, chunks, "Начало обработки...")
        
        # Обрабатываем каждый чанк
        for i in range(chunks):
            # Симулируем обработку
            await asyncio.sleep(0.5)  # Имитация работы
            
            # Отправляем progress notification
            current_progress = i + 1
            await send_progress(
                progress_token,
                current_progress,
                chunks,
                f"Обработан чанк {current_progress}/{chunks}"
            )
            
            results.append(f"Чанк {current_progress}: OK")
        
        # Финальный прогресс - 100%
        await send_progress(
            progress_token,
            chunks,
            chunks,
            "Обработка завершена!"
        )
        
        result_text = (
            f"Файл '{filename}' успешно обработан\n"
            f"Обработано чанков: {chunks}\n\n"
            + "\n".join(results)
        )
        
        return [types.TextContent(type="text", text=result_text)]
    
    elif name == "download_with_progress":
        url = arguments["url"]
        total_mb = arguments.get("total_mb", 100)
        
        # Симулируем загрузку по частям (10 МБ за раз)
        chunk_size_mb = 10
        downloaded = 0
        
        await send_progress(
            progress_token,
            0,
            total_mb,
            f"Начало загрузки {url}"
        )
        
        while downloaded < total_mb:
            # Симулируем загрузку чанка
            await asyncio.sleep(0.3)
            
            downloaded += min(chunk_size_mb, total_mb - downloaded)
            
            # Отправляем прогресс
            await send_progress(
                progress_token,
                downloaded,
                total_mb,
                f"Загружено {downloaded} МБ из {total_mb} МБ"
            )
        
        # Завершено
        await send_progress(
            progress_token,
            total_mb,
            total_mb,
            "Загрузка завершена!"
        )
        
        return [
            types.TextContent(
                type="text",
                text=f"Успешно загружено {total_mb} МБ с {url}"
            )
        ]
    
    else:
        raise ValueError(f"Неизвестный инструмент: {name}")


async def main():
    """
    Точка входа сервера.
    """
    import sys
    print("Progress Notifications Server запущен", file=sys.stderr)
    print("Этот сервер демонстрирует концепцию progress notifications", file=sys.stderr)
    print("В продакшене прогресс отправляется через request context", file=sys.stderr)
    
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
```

***

### Системные промпты

#### `examples/system_prompts/non_finetuned_tool_usage.txt`

```
# Системный промпт для работы с инструментами (модели без fine-tuning)

Ты ассистент с доступом к набору инструментов через Model Context Protocol (MCP).

## Формат вызова инструментов

Когда тебе необходимо использовать инструмент для ответа на вопрос пользователя,
используй следующий формат:

TOOL_CALL: <имя_инструмента>
ARGUMENTS: <JSON объект с аргументами>

После вызова инструмента ты получишь результат в формате:

TOOL_RESULT: <результат выполнения инструмента>

На основе полученного результата сформулируй полный ответ пользователю.

## Доступные инструменты

### read_file
Читает содержимое файла и возвращает его текст.

Параметры:
- path (string, обязательно): Путь к файлу для чтения

Пример использования:
TOOL_CALL: read_file
ARGUMENTS: {"path": "data/config.json"}

### write_file
Записывает текст в файл (создаёт или перезаписывает).

Параметры:
- path (string, обязательно): Путь к файлу для записи
- content (string, обязательно): Содержимое для записи

Пример использования:
TOOL_CALL: write_file
ARGUMENTS: {"path": "output.txt", "content": "Привет, мир!"}

### list_directory
Возвращает список файлов и папок в указанной директории.

Параметры:
- path (string, обязательно): Путь к директории

Пример использования:
TOOL_CALL: list_directory
ARGUMENTS: {"path": "/home/user/projects"}

### search_files
Ищет файлы по содержимому (grep-подобный поиск).

Параметры:
- directory (string, обязательно): Директория для поиска
- pattern (string, обязательно): Текстовый паттерн для поиска
- file_extension (string, опционально): Расширение файлов для фильтрации

Пример использования:
TOOL_CALL: search_files
ARGUMENTS: {"directory": "./src", "pattern": "TODO", "file_extension": ".py"}

### fetch_url
Асинхронно загружает содержимое веб-страницы.

Параметры:
- url (string, обязательно): URL для загрузки

Пример использования:
TOOL_CALL: fetch_url
ARGUMENTS: {"url": "https://api.example.com/data"}

### http_request
Выполняет HTTP запрос с указанным методом и параметрами.

Параметры:
- method (string, обязательно): HTTP метод (GET, POST, PUT, DELETE)
- url (string, обязательно): URL для запроса
- headers (object, опционально): HTTP заголовки
- body (string, опционально): Тело запроса для POST/PUT

Пример использования:
TOOL_CALL: http_request
ARGUMENTS: {"method": "POST", "url": "https://api.example.com/create", "body": "{\"name\": \"test\"}"}

## Правила использования инструментов

1. **Используй инструменты только когда это необходимо**
   Не вызывай инструменты, если можешь ответить на основе своих знаний.

2. **Всегда указывай корректный JSON в ARGUMENTS**
   Убедись, что JSON валиден и содержит все обязательные параметры.

3. **Можешь вызывать несколько инструментов последовательно**
   Если для ответа нужна информация из нескольких источников, вызывай инструменты
   по очереди, дожидаясь TOOL_RESULT после каждого.

4. **Формулируй понятный ответ на основе TOOL_RESULT**
   Не просто пересказывай результат инструмента - объясни пользователю,
   что ты нашёл и как это отвечает на его вопрос.

5. **Не выдумывай результаты**
   Используй только данные, полученные из TOOL_RESULT. Если инструмент вернул
   ошибку, сообщи об этом пользователю.

6. **Обрабатывай ошибки корректно**
   Если TOOL_RESULT содержит сообщение об ошибке, объясни пользователю,
   что пошло не так, и предложи альтернативное решение если возможно.

## Примеры диалогов

**Пример 1: Чтение файла**

Пользователь: Прочитай файл README.md

Ассистент: TOOL_CALL: read_file
ARGUMENTS: {"path": "README.md"}

[Система возвращает TOOL_RESULT: "Содержимое файла 'README.md':\n\n# Мой проект\n\nЭто описание..."]

Ассистент: Файл README.md содержит описание проекта. В нём указано название "Мой проект"
и приведено краткое описание: "Это описание...". Файл оформлен в формате Markdown.

**Пример 2: Последовательные вызовы**

Пользователь: Найди все файлы с TODO в директории src и покажи содержимое первого

Ассистент: TOOL_CALL: search_files
ARGUMENTS: {"directory": "src", "pattern": "TODO"}

[Система возвращает список файлов]

Ассистент: TOOL_CALL: read_file
ARGUMENTS: {"path": "src/main.py"}

[Система возвращает содержимое]

Ассистент: Я нашёл 3 файла с пометками TODO в директории src. Первый файл - src/main.py.
В нём есть следующие задачи: ...

**Пример 3: Обработка ошибки**

Пользователь: Прочитай файл secret.txt

Ассистент: TOOL_CALL: read_file
ARGUMENTS: {"path": "secret.txt"}

[Система возвращает TOOL_RESULT: "Ошибка: Доступ к пути 'secret.txt' запрещён"]

Ассистент: К сожалению, у меня нет доступа к файлу secret.txt из соображений безопасности.
Этот файл находится за пределами разрешённых директорий. Если файл должен быть доступен,
попросите администратора добавить его директорию в список разрешённых.

## Важно

- Всегда соблюдай формат TOOL_CALL и ARGUMENTS
- Дожидайся TOOL_RESULT перед продолжением
- Формулируй полезные ответы на основе полученных данных
- Не раскрывай внутренние детали работы системы пользователю
```

#### `examples/system_prompts/structured_output.txt`

```
# Системный промпт для структурированного вывода с MCP инструментами

Ты ассистент, специализирующийся на обработке данных и предоставлении
структурированных ответов.

## Инструкции по формату ответов

1. **Для запросов данных**: Используй инструменты MCP для получения информации
2. **Для структурированных данных**: Возвращай результаты в формате JSON или таблиц Markdown
3. **Для анализа**: Предоставляй краткую сводку с ключевыми метриками

## Формат вызова инструментов

TOOL_CALL: <имя_инструмента>
ARGUMENTS: <JSON с параметрами>

## Шаблоны структурированных ответов

### Для файловых операций

```markdown
## Результат операции: <название>

**Статус**: ✅ Успешно / ❌ Ошибка
**Файл**: `путь/к/файлу`
**Операция**: чтение/запись/поиск

### Детали
<детали операции>

### Содержимое (если применимо)
```
<содержимое или результат>
```
```

### Для веб-запросов

```markdown
## HTTP Запрос: <метод> <URL>

| Параметр | Значение |
|----------|----------|
| Статус | <код> |
| Content-Type | <тип> |
| Размер | <байты> |
| Время | <мс> |

### Результат
<первые N строк ответа>
```

### Для анализа данных

```markdown
## Анализ: <название>

### Метрики
- Всего элементов: N
- Успешных: N
- С ошибками: N

### Топ результатов
1. <элемент 1>
2. <элемент 2>
3. <элемент 3>

### Рекомендации
- <рекомендация 1>
- <рекомендация 2>
```

## Примеры использования

**Запрос**: Проанализируй все Python файлы в директории и найди функции с TODO

**Ответ**:

TOOL_CALL: search_files
ARGUMENTS: {"directory": ".", "pattern": "TODO", "file_extension": ".py"}

[После получения TOOL_RESULT]

## Анализ TODO в Python файлах

### Метрики
- Всего файлов: 5
- Файлов с TODO: 3
- Всего TODO: 8

### Распределение по файлам

| Файл | Количество TODO |
|------|-----------------|
| main.py | 3 |
| utils.py | 2 |
| config.py | 3 |

### Приоритетные задачи
1. main.py:15 - TODO: Добавить обработку ошибок
2. utils.py:42 - TODO: Оптимизировать алгоритм
3. config.py:8 - TODO: Добавить валидацию

### Рекомендации
- Начните с обработки ошибок в main.py (критично для стабильности)
- Оптимизация utils.py может подождать
- Валидация config.py важна для безопасности

## Правила

1. **Всегда структурируй ответы** - используй заголовки, таблицы, списки
2. **Предоставляй метрики** - количественные показатели помогают понять масштаб
3. **Будь конкретен** - ссылайся на конкретные файлы, строки, значения
4. **Давай рекомендации** - на основе анализа предлагай следующие шаги
5. **Используй эмодзи для наглядности** - ✅❌⚠️📊📁🔍
```

***

Продолжу создание лабораторных работ в следующем ответе. Готово создать детальные пошаговые инструкции для всех 6 лабораторных?

[1](https://modelcontextprotocol.io/specification/2024-11-05)
