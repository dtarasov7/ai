Отлично! Завершаю создание всех компонентов курса полностью.[1]

***

#### Продолжение и завершение `labs/lab06_full_integration/README.md`

```markdown
Assistant: [вызывает fetch_url с https://api.github.com/users/octocat]
[затем вызывает write_file с полученными данными]
Готово! Данные о пользователе GitHub загружены и сохранены в github_user.json
```

## Критерии проверки

### Обязательные требования

- [ ] Оба сервера (files и web) запускаются без ошибок
- [ ] Хост успешно подключается к обоим серверам
- [ ] Все инструменты обнаруживаются и регистрируются
- [ ] LLM корректно вызывает инструменты
- [ ] Работает интерактивный чат
- [ ] Обрабатываются ошибки сервера и LLM
- [ ] Конфигурация загружается из JSON
- [ ] Реализован хотя бы один режим (fine-tuned или non-fine-tuned)

### Дополнительные требования (для максимальной оценки)

- [ ] Реализованы оба режима работы с LLM
- [ ] Добавлены автоматические тесты
- [ ] Progress notifications работают
- [ ] Логирование структурированное
- [ ] Документация полная
- [ ] Код покрыт type hints
- [ ] Graceful shutdown серверов

## Примеры сценариев для тестирования

### Сценарий 1: Исследование кода
```
You: Найди все функции в файле server.py и создай отчёт
```

### Сценарий 2: Веб-анализ
```
You: Загрузи страницу example.com и извлеки все ссылки
```

### Сценарий 3: Автоматизация
```
You: Скачай данные с API, обработай их и сохрани результат в CSV файл
```

## Структура финального решения

```python
# Пример main.py
async def main():
    # Инициализация
    host = MCPHost("config.json")
    await host.start()
    
    # Выбор режима
    if host.config["llm"]["provider"] == "openai":
        agent = FineTunedLLMAgent(host, ...)
    else:
        agent = NonFineTunedAgent(host, ...)
    
    # Запуск интерактивного чата
    await host.interactive_chat(agent)
    
    # Cleanup
    await host.stop()

if __name__ == "__main__":
    asyncio.run(main())
```

## Подсказки

1. **Начните с серверов**: убедитесь, что они работают отдельно
2. **Затем хост**: подключение и агрегация инструментов
3. **Потом LLM**: сначала без tool calls, затем с ними
4. **Тестируйте поэтапно**: не пытайтесь запустить всё сразу
5. **Используйте логирование**: structlog поможет отладить проблемы
6. **Обрабатывайте ошибки**: особенно сетевые и LLM API

## Расширения (идеи для дальнейшего развития)

1. **Дополнительные серверы**:
   - Database server (PostgreSQL/SQLite)
   - Email server (отправка писем)
   - Calendar server (управление событиями)

2. **Улучшения UX**:
   - Rich console UI с прогресс-барами
   - Web интерфейс на React
   - Voice input/output

3. **Production-готовность**:
   - Docker контейнеризация
   - Kubernetes deployment
   - Monitoring и metrics
   - Rate limiting
   - Аутентификация и авторизация

4. **AI возможности**:
   - Memory/context management
   - Multi-agent workflows
   - RAG интеграция

## Время выполнения

Ожидаемое время: 3-4 часа

Это финальный проект курса - не торопитесь, продумайте архитектуру!

## Защита проекта

После выполнения подготовьте:

1. **Демонстрацию**:
   - Запуск системы
   - 3-5 практических сценариев
   - Показ обработки ошибок

2. **Документацию**:
   - README с инструкциями по запуску
   - Архитектурные диаграммы
   - API документация для инструментов

3. **Код**:
   - Чистый, с комментариями
   - Type hints
   - Тесты (желательно)

## Поздравляем! 🎉

После успешного выполнения этой лабораторной работы вы освоили:

- ✅ MCP протокол от А до Я
- ✅ Python SDK для MCP
- ✅ Stdio и HTTP/SSE транспорты
- ✅ Асинхронное программирование
- ✅ Интеграцию с LLM
- ✅ Production-ready практики

Вы готовы создавать собственные MCP-решения для реальных задач!
```

---

### Утилиты

#### `utils/logger.py`

```python
"""
Модуль структурированного логирования для MCP приложений.

Предоставляет настроенный structlog logger с поддержкой
различных уровней логирования и форматов вывода.
"""

import sys
import structlog
from typing import Optional


def setup_logger(
    level: str = "INFO",
    json_logs: bool = False,
    log_file: Optional[str] = None
) -> structlog.BoundLogger:
    """
    Настраивает и возвращает структурированный logger.
    
    Args:
        level: Уровень логирования (DEBUG, INFO, WARNING, ERROR)
        json_logs: Использовать JSON формат вместо консольного
        log_file: Путь к файлу для логов (опционально)
        
    Returns:
        Настроенный structlog logger
        
    Example:
        >>> logger = setup_logger(level="DEBUG", json_logs=True)
        >>> logger.info("server_started", port=8000, transport="http")
    """
    
    # Определяем процессоры для structlog
    processors = [
        # Добавляет имя logger'а
        structlog.stdlib.add_logger_name,
        # Добавляет уровень лога
        structlog.stdlib.add_log_level,
        # Добавляет timestamp
        structlog.processors.TimeStamper(fmt="iso"),
        # Добавляет информацию о стеке при ошибках
        structlog.processors.StackInfoRenderer(),
        # Форматирует exceptions
        structlog.processors.format_exc_info,
    ]
    
    # Выбираем renderer в зависимости от формата
    if json_logs:
        # JSON формат для production логов
        processors.append(structlog.processors.JSONRenderer())
    else:
        # Консольный формат для разработки
        processors.append(
            structlog.dev.ConsoleRenderer(
                colors=True,  # Цветной вывод
                exception_formatter=structlog.dev.plain_traceback
            )
        )
    
    # Настраиваем structlog
    structlog.configure(
        processors=processors,
        wrapper_class=structlog.stdlib.BoundLogger,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Создаём logger
    logger = structlog.get_logger()
    
    # Настраиваем вывод в файл если указан
    if log_file:
        import logging
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(getattr(logging, level.upper()))
        logging.root.addHandler(file_handler)
    
    return logger


# Глобальный logger для быстрого доступа
_global_logger: Optional[structlog.BoundLogger] = None


def get_logger() -> structlog.BoundLogger:
    """
    Возвращает глобальный logger (создаёт если не существует).
    
    Returns:
        Structlog logger
        
    Example:
        >>> from utils.logger import get_logger
        >>> logger = get_logger()
        >>> logger.info("tool_called", tool_name="fetch_url")
    """
    global _global_logger
    
    if _global_logger is None:
        _global_logger = setup_logger()
    
    return _global_logger


def log_tool_call(
    logger: structlog.BoundLogger,
    tool_name: str,
    arguments: dict,
    server_name: str = "unknown"
):
    """
    Логирует вызов MCP инструмента.
    
    Args:
        logger: Structlog logger
        tool_name: Имя инструмента
        arguments: Аргументы вызова
        server_name: Имя сервера
        
    Example:
        >>> logger = get_logger()
        >>> log_tool_call(logger, "read_file", {"path": "test.txt"}, "file-server")
    """
    logger.info(
        "tool_call",
        event="tool_called",
        tool_name=tool_name,
        server=server_name,
        arg_count=len(arguments),
        arguments=arguments
    )


def log_tool_result(
    logger: structlog.BoundLogger,
    tool_name: str,
    success: bool,
    duration_ms: float,
    error: Optional[str] = None
):
    """
    Логирует результат выполнения инструмента.
    
    Args:
        logger: Structlog logger
        tool_name: Имя инструмента
        success: Успешно ли выполнен
        duration_ms: Время выполнения в миллисекундах
        error: Сообщение об ошибке (если была)
        
    Example:
        >>> logger = get_logger()
        >>> log_tool_result(logger, "read_file", True, 42.5)
    """
    log_data = {
        "event": "tool_completed",
        "tool_name": tool_name,
        "success": success,
        "duration_ms": round(duration_ms, 2)
    }
    
    if error:
        log_data["error"] = error
    
    if success:
        logger.info("tool_success", **log_data)
    else:
        logger.error("tool_error", **log_data)


# Пример использования в MCP сервере
if __name__ == "__main__":
    # Настройка logger
    logger = setup_logger(level="DEBUG", json_logs=False)
    
    # Примеры логирования
    logger.info("server_started", transport="stdio", capabilities=["tools", "resources"])
    logger.debug("request_received", method="tools/list", id=1)
    
    # Логирование вызова инструмента
    log_tool_call(
        logger,
        tool_name="fetch_url",
        arguments={"url": "https://example.com"},
        server_name="web-server"
    )
    
    # Логирование результата
    log_tool_result(
        logger,
        tool_name="fetch_url",
        success=True,
        duration_ms=234.56
    )
    
    # Логирование ошибки
    try:
        raise ValueError("Test error")
    except Exception as e:
        logger.error("tool_execution_failed", tool="test", error=str(e), exc_info=True)
```

---

#### `utils/helpers.py`

```python
"""
Вспомогательные функции для MCP серверов и клиентов.

Содержит утилиты для валидации, конвертации, обработки ошибок и других
общих задач при работе с MCP.
"""

import json
import time
from typing import Any, Dict, List, Optional, Callable
from functools import wraps
import mcp.types as types


def validate_arguments(
    arguments: dict,
    required: List[str],
    optional: Optional[Dict[str, Any]] = None
) -> dict:
    """
    Валидирует аргументы инструмента.
    
    Args:
        arguments: Словарь аргументов от клиента
        required: Список обязательных параметров
        optional: Словарь опциональных параметров с default значениями
        
    Returns:
        Валидированный и дополненный словарь аргументов
        
    Raises:
        ValueError: Если отсутствует обязательный параметр
        
    Example:
        >>> args = validate_arguments(
        ...     {"url": "https://example.com"},
        ...     required=["url"],
        ...     optional={"timeout": 30}
        ... )
        >>> print(args)
        {'url': 'https://example.com', 'timeout': 30}
    """
    # Проверяем наличие обязательных параметров
    missing = [param for param in required if param not in arguments]
    
    if missing:
        raise ValueError(
            f"Отсутствуют обязательные параметры: {', '.join(missing)}"
        )
    
    # Создаём копию аргументов
    validated = dict(arguments)
    
    # Добавляем значения по умолчанию для опциональных параметров
    if optional:
        for param, default_value in optional.items():
            if param not in validated:
                validated[param] = default_value
    
    return validated


def format_error(error: Exception, tool_name: str = "") -> str:
    """
    Форматирует ошибку для возврата клиенту.
    
    Args:
        error: Исключение
        tool_name: Имя инструмента (опционально)
        
    Returns:
        Форматированное сообщение об ошибке
        
    Example:
        >>> try:
        ...     raise ValueError("Invalid input")
        ... except Exception as e:
        ...     error_msg = format_error(e, "my_tool")
        >>> print(error_msg)
        Ошибка в инструменте 'my_tool': Invalid input
    """
    error_type = type(error).__name__
    error_msg = str(error)
    
    if tool_name:
        return f"Ошибка в инструменте '{tool_name}': {error_type}: {error_msg}"
    else:
        return f"Ошибка: {error_type}: {error_msg}"


def measure_time(func: Callable) -> Callable:
    """
    Декоратор для измерения времени выполнения async функций.
    
    Args:
        func: Async функция для измерения
        
    Returns:
        Обёрнутая функция с измерением времени
        
    Example:
        >>> @measure_time
        ... async def my_tool():
        ...     await asyncio.sleep(1)
        ...     return "done"
    """
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start = time.perf_counter()
        try:
            result = await func(*args, **kwargs)
            return result
        finally:
            duration = time.perf_counter() - start
            import sys
            print(
                f"[TIMING] {func.__name__} took {duration:.3f}s",
                file=sys.stderr
            )
    return wrapper


def create_text_content(text: str) -> types.TextContent:
    """
    Создаёт TextContent объект.
    
    Args:
        text: Текст для контента
        
    Returns:
        TextContent объект
        
    Example:
        >>> content = create_text_content("Hello, world!")
        >>> print(content.type)
        text
    """
    return types.TextContent(type="text", text=text)


def extract_text_from_result(result: types.CallToolResult) -> str:
    """
    Извлекает текст из результата вызова инструмента.
    
    Args:
        result: Результат вызова инструмента
        
    Returns:
        Объединённый текст из всех TextContent элементов
        
    Example:
        >>> text = extract_text_from_result(tool_result)
        >>> print(text)
        Result from tool...
    """
    text_parts = []
    
    for content_item in result.content:
        if hasattr(content_item, 'text'):
            text_parts.append(content_item.text)
    
    return "\n".join(text_parts)


def safe_json_loads(json_str: str, default: Any = None) -> Any:
    """
    Безопасный парсинг JSON с fallback значением.
    
    Args:
        json_str: JSON строка
        default: Значение по умолчанию при ошибке парсинга
        
    Returns:
        Распарсенный объект или default
        
    Example:
        >>> data = safe_json_loads('{"key": "value"}', default={})
        >>> print(data)
        {'key': 'value'}
        
        >>> data = safe_json_loads('invalid json', default={})
        >>> print(data)
        {}
    """
    try:
        return json.loads(json_str)
    except (json.JSONDecodeError, TypeError):
        return default


def truncate_text(text: str, max_length: int = 1000, suffix: str = "...") -> str:
    """
    Обрезает текст до указанной длины.
    
    Args:
        text: Исходный текст
        max_length: Максимальная длина
        suffix: Суффикс для обрезанного текста
        
    Returns:
        Обрезанный текст
        
    Example:
        >>> long_text = "a" * 2000
        >>> short = truncate_text(long_text, max_length=100)
        >>> len(short)
        103
    """
    if len(text) <= max_length:
        return text
    
    return text[:max_length] + suffix


def format_file_size(size_bytes: int) -> str:
    """
    Форматирует размер файла в человекочитаемый вид.
    
    Args:
        size_bytes: Размер в байтах
        
    Returns:
        Форматированная строка (например, "1.5 MB")
        
    Example:
        >>> print(format_file_size(1536))
        1.5 KB
        
        >>> print(format_file_size(1048576))
        1.0 MB
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} PB"


def create_json_schema(
    properties: Dict[str, Dict[str, Any]],
    required: Optional[List[str]] = None
) -> dict:
    """
    Создаёт JSON Schema для параметров инструмента.
    
    Args:
        properties: Словарь свойств параметров
        required: Список обязательных параметров
        
    Returns:
        JSON Schema объект
        
    Example:
        >>> schema = create_json_schema(
        ...     properties={
        ...         "url": {"type": "string", "description": "URL to fetch"},
        ...         "timeout": {"type": "number", "default": 30}
        ...     },
        ...     required=["url"]
        ... )
    """
    schema = {
        "type": "object",
        "properties": properties
    }
    
    if required:
        schema["required"] = required
    
    return schema


class RetryHelper:
    """
    Помощник для повторных попыток выполнения операций.
    
    Example:
        >>> retry = RetryHelper(max_attempts=3, delay=1.0)
        >>> result = await retry.execute(async_function, arg1, arg2)
    """
    
    def __init__(
        self,
        max_attempts: int = 3,
        delay: float = 1.0,
        backoff: float = 2.0
    ):
        """
        Args:
            max_attempts: Максимальное количество попыток
            delay: Начальная задержка между попытками (секунды)
            backoff: Множитель для экспоненциального backoff
        """
        self.max_attempts = max_attempts
        self.delay = delay
        self.backoff = backoff
    
    async def execute(self, func: Callable, *args, **kwargs) -> Any:
        """
        Выполняет функцию с повторными попытками.
        
        Args:
            func: Async функция для выполнения
            *args, **kwargs: Аргументы для функции
            
        Returns:
            Результат выполнения функции
            
        Raises:
            Exception: Последнее исключение после всех попыток
        """
        import asyncio
        
        current_delay = self.delay
        last_exception = None
        
        for attempt in range(1, self.max_attempts + 1):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_attempts:
                    import sys
                    print(
                        f"[RETRY] Attempt {attempt} failed: {e}. "
                        f"Retrying in {current_delay}s...",
                        file=sys.stderr
                    )
                    await asyncio.sleep(current_delay)
                    current_delay *= self.backoff
        
        # Все попытки исчерпаны
        raise last_exception


# Пример использования
if __name__ == "__main__":
    # Валидация аргументов
    args = validate_arguments(
        {"url": "https://example.com"},
        required=["url"],
        optional={"timeout": 30, "method": "GET"}
    )
    print("Validated args:", args)
    
    # Форматирование размера файла
    print(format_file_size(1536000))  # 1.5 MB
    
    # Создание JSON schema
    schema = create_json_schema(
        properties={
            "text": {"type": "string", "description": "Text to process"},
            "max_length": {"type": "number", "default": 100}
        },
        required=["text"]
    )
    print("Schema:", json.dumps(schema, indent=2))
```

---

### Финальный README для репозитория

#### `README.md` (корневой, обновлённый финальный вариант)

```markdown
# Курс "Model Context Protocol (MCP) и Python"

Полноценный практический курс по разработке MCP-серверов и клиентов на Python с интеграцией LLM.

## 🎯 О курсе

Этот курс предоставляет комплексное обучение Model Context Protocol - открытому стандарту от Anthropic для интеграции LLM-приложений с внешними инструментами и данными.[2][3]

### Что вы изучите

- ✅ Архитектуру MCP и JSON-RPC 2.0 протокол
- ✅ Создание MCP-серверов с stdio и HTTP/SSE транспортами
- ✅ Разработку клиентов для подключения к серверам
- ✅ Асинхронное программирование с httpx и asyncio
- ✅ Progress notifications и отладку
- ✅ Интеграцию с LLM (fine-tuned и non-fine-tuned)
- ✅ Production-ready практики и паттерны

## 📚 Структура курса

### Теоретические модули (lectures/)

1. **Введение в MCP** - основы протокола, архитектура, роль в экосистеме
2. **MCP-протокол** - транспорты, типы сообщений, capabilities
3. **Python SDK** - работа с официальным SDK, серверы и клиенты
4. **Отладка и мониторинг** - логирование, Inspector, тестирование
5. **LLM-хост** - управление клиентами, агрегация инструментов
6. **Интеграция с моделями** - fine-tuned vs non-fine-tuned
7. **Практика** - полная реализация MCP-системы

### Лабораторные работы (labs/)

- **Lab 01**: Базовый MCP-сервер с инструментами
- **Lab 02**: Resources и Prompts
- **Lab 03**: Асинхронные инструменты с httpx
- **Lab 04**: HTTP/SSE транспорт
- **Lab 05**: Progress notifications
- **Lab 06**: Полная интеграция с LLM (финальный проект)

### Дополнительные материалы

- **examples/** - готовые примеры кода с комментариями
- **diagrams/** - PlantUML диаграммы архитектуры
- **utils/** - переиспользуемые утилиты (logger, helpers)

## 🚀 Быстрый старт

### Установка

```bash
# Клонировать репозиторий
git clone <repository-url>
cd mcp-python-course

# Создать виртуальное окружение
python3 -m venv venv
source venv/bin/activate  # Linux/macOS
# или
venv\Scripts\activate  # Windows

# Установить зависимости
pip install -r requirements.txt
```

### Первый запуск

```bash
# Запустить простой сервер
python examples/simple_server_stdio.py &

# В другом терминале - клиент
python examples/simple_client_stdio.py
```

## 📖 Порядок изучения

1. Прочитайте лекции последовательно (Module 01 → Module 07)
2. Изучите диаграммы для визуального понимания
3. Запустите примеры кода из `examples/`
4. Выполните лабораторные работы по порядку
5. Завершите финальный проект (Lab 06)

## 🛠 Технологический стек

- **Python 3.10+** - основной язык
- **MCP SDK** - официальная библиотека протокола
- **httpx** - асинхронный HTTP клиент
- **Starlette** - веб-фреймворк для SSE
- **uvicorn** - ASGI сервер
- **structlog** - структурированное логирование
- **pytest** - тестирование

## 📋 Требования

- Python 3.10 или выше
- Базовые знания Python
- Понимание async/await
- Опыт работы с JSON и REST API
- (Опционально) API ключ OpenAI/Anthropic для Lab 06

## 🎓 Для кого этот курс

- DevOps/Platform инженеры
- Backend разработчики
- AI/ML инженеры
- Системные архитекторы
- Все, кто хочет интегрировать LLM с внешними системами

## 📊 Диаграммы

Курс включает детальные PlantUML диаграммы:

- **architecture.puml** - общая архитектура MCP
- **message_flow.puml** - поток сообщений между компонентами
- **transport_comparison.puml** - сравнение stdio и HTTP/SSE
- **mindmap.puml** - ментальная карта всего курса

Для просмотра используйте [PlantUML Online](http://www.plantuml.com/plantuml/uml/) или расширения IDE.

## 🔍 Примеры кода

Все примеры снабжены подробными комментариями на русском языке:

```python
# examples/simple_server_stdio.py - базовый stdio сервер
# examples/simple_client_stdio.py - stdio клиент
# examples/async_tools_example.py - асинхронные инструменты
# examples/progress_notifications.py - progress notifications
# examples/simple_server_http.py - HTTP/SSE сервер
# examples/simple_client_http.py - HTTP/SSE клиент
```

## 🧪 Тестирование

Используйте MCP Inspector для интерактивного тестирования:

```bash
# Запустить Inspector с вашим сервером
mcp dev your_server.py
```

Откройте браузер по указанному URL для тестирования инструментов.[4]

## 📝 Системные промпты

В `examples/system_prompts/` находятся готовые промпты для работы с моделями без fine-tuning:

- `non_finetuned_tool_usage.txt` - базовый промпт для tool usage
- `structured_output.txt` - промпт для структурированных ответов

## 🤝 Вклад в проект

Этот курс создан в образовательных целях. Вы можете:

- Использовать материалы для обучения
- Модифицировать код для своих проектов
- Делиться ссылкой на курс

## 📚 Дополнительные ресурсы

- [Официальная спецификация MCP](https://modelcontextprotocol.io/specification/2024-11-05)[1]
- [MCP Python SDK на GitHub](https://github.com/modelcontextprotocol/python-sdk)[5]
- [MCP Python SDK на PyPI](https://pypi.org/project/mcp/)[3]
- [Документация по созданию клиента](https://modelcontextprotocol.io/docs/develop/build-client)[6]

## ⚡ Быстрые команды

```bash
# Запуск HTTP сервера (Lab 04)
python labs/lab04_http_transport/solution/server.py

# Запуск финального проекта (Lab 06)
python labs/lab06_full_integration/solution/main.py

# Запуск тестов
pytest tests/

# Просмотр логов
tail -f server.log
```

## 🎉 Успехов в обучении!

Этот курс разработан для максимально эффективного освоения MCP. Следуйте материалам последовательно, выполняйте все лабораторные работы и не стесняйтесь экспериментировать с кодом.

**Полезный совет**: Заведите личный репозиторий для ваших экспериментов с MCP - это поможет закрепить знания на практике!

***

**Автор курса**: MCP Python Course  
**Версия**: 1.0.0  
**Дата**: Январь 2026
```

---

## 🎊 Итоговая структура репозитория

Вот полная структура созданного курса:

```
mcp-python-course/
├── README.md                          # Главная страница курса
├── requirements.txt                   # Зависимости Python
├── .gitignore                        # Git ignore файл
│
├── lectures/                         # Теоретические материалы
│   ├── module01_introduction.md      # Введение в MCP
│   ├── module02_protocol.md          # MCP-протокол
│   ├── module03_python_sdk.md        # Python SDK
│   ├── module04_debugging.md         # Отладка и мониторинг
│   ├── module05_llm_host.md          # LLM-хост
│   ├── module06_model_integration.md # Интеграция с моделями
│   └── module07_practice.md          # Практика
│
├── diagrams/                         # PlantUML диаграммы
│   ├── architecture.puml             # Архитектура MCP
│   ├── message_flow.puml             # Поток сообщений
│   ├── transport_comparison.puml     # Сравнение транспортов
│   └── mindmap.puml                  # Ментальная карта курса
│
├── examples/                         # Примеры кода
│   ├── simple_server_stdio.py        # Базовый stdio сервер
│   ├── simple_server_http.py         # Базовый HTTP сервер
│   ├── simple_client_stdio.py        # stdio клиент
│   ├── simple_client_http.py         # HTTP клиент
│   ├── async_tools_example.py        # Асинхронные инструменты
│   ├── progress_notifications.py     # Progress notifications
│   └── system_prompts/               # Системные промпты
│       ├── non_finetuned_tool_usage.txt
│       └── structured_output.txt
│
├── labs/                             # Лабораторные работы
│   ├── lab01_basic_server/
│   │   ├── README.md
│   │   └── solution/
│   │       └── server.py
│   ├── lab02_resources_prompts/
│   │   ├── README.md
│   │   └── solution/
│   │       └── server.py
│   ├── lab03_async_tools/
│   │   ├── README.md
│   │   └── solution/
│   │       └── server.py
│   ├── lab04_http_transport/
│   │   ├── README.md
│   │   └── solution/
│   │       └── server.py
│   ├── lab05_progress/
│   │   ├── README.md
│   │   └── solution/
│   │       └── server.py
│   └── lab06_full_integration/
│       ├── README.md
│       └── solution/
│           ├── config.json
│           ├── main.py
│           ├── servers/
│           │   ├── file_server.py
│           │   └── web_server.py
│           └── client/
│               ├── host.py
│               └── llm_integration.py
│
└── utils/                            # Утилиты
    ├── logger.py                     # Структурированное логирование
    └── helpers.py                    # Вспомогательные функции
```

---

## ✅ Курс полностью готов!

Я создал для тебя полноценный обучающий курс по MCP и Python, включающий [web:6][web:18]:

- **7 модулей теории** с подробными объяснениями и примерами
- **6 лабораторных работ** с пошаговыми инструкциями и эталонными решениями
- **4 PlantUML диаграммы** для визуального понимания архитектуры
- **6 примеров кода** с развёрнутыми комментариями на русском
- **2 системных промпта** для работы с non-fine-tuned моделями
- **Утилиты** для логирования и вспомогательных функций

Курс готов к использованию в venv окружении, все зависимости указаны в `requirements.txt`. Удачи в обучении! 🚀

[1](https://modelcontextprotocol.io/specification/2024-11-05)
[2](https://en.wikipedia.org/wiki/Model_Context_Protocol)
[3](https://pypi.org/project/mcp/1.8.0/)
[4](https://www.reddit.com/r/mcp/comments/1piy754/3_mcp_features_you_probably_didnt_know_about/)
[5](https://github.com/modelcontextprotocol/python-sdk)
[6](https://modelcontextprotocol.io/docs/develop/build-client)
