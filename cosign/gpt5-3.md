Короткий разбор по пунктам.

1) Про “ключи vs CA” в cosign и notation
- Не совсем так. 
  - Cosign поддерживает два режима: 
    - ключевой (key-based) — каждая команда/команда проекта хранит свою пару key+pub и вы раздаёте публичные ключи проверяющим;
    - сертификатный (x509) — подпись содержит цепочку X.509, а проверка идёт по доверенному корню (Fulcio или ваш собственный CA). То есть cosign умеет и “независимые ключи”, и “через CA”.
  - Notation изначально заточён под X.509: в подписи всегда лежит сертификат (цепочка), а проверка выполняется строго по доверенному хранилищу (trust store) и политике (trust policy). Пинning на отдельный ключ тоже возможен, но через доверие к конкретному листовому сертификату, а не к “сырым” ключам.

2) «Достаточно передать сертификат CA?» для notation
- В большинстве случаев — да. Вы размещаете корень/корни вашего (или вендорского) CA в trust store, настраиваете trust policy (какие Subject/Issuer допускаются, для каких реестров/репозиториев, уровень strict/permissive), и этого достаточно, чтобы notation verify проходил офлайн.
- Варианты:
  - доверять корню (CA) — удобно для масштабирования, даёт единый ротационный контур;
  - “прибить” доверие к конкретному листовому сертификату (pinning) — жёстче, но управляемо.
- В air‑gapped среде дополнительно решите вопрос с отзыом (CRL/OCSP) и метками времени: либо периодически офлайн‑обновляете списки отзыва/корни TSA, либо используете менее строгий режим для этих проверок.

3) «Можем ли мы сами выпустить закрытый ключ для поставщика и он будет им подписывать?»
- Технически возможно, но операционно и юридически это плохая практика.
  - Рекомендуемый путь: поставщик сам генерирует пару ключей у себя (лучше в HSM/YubiKey/KMS), формирует CSR, а ваша CA выпускает ему именной сертификат (можно через выделенный промежуточный CA для конкретного вендора). Так вы сохраняете:
    - корректную модель владения ключом (private key не покидает сторону поставщика);
    - простую отзыв/ротацию (отзываете конкретный сертификат/интермедиат);
    - трассируемую идентичность (Subject/SAN, серийник, сроки).
  - Если вы сгенерируете ключи за вендора и передадите ему private key, вы берёте на себя риски компрометации и утрачиваете прозрачность владения.

Что в итоге отличается концептуально
- Cosign — гибкая утилита: ключи без PKI, или сертификаты (Fulcio/собственный CA), плюс “keyless” через OIDC — удобно в онлайне.
- Notation — стандартизированная модель Notary v2: всегда X.509 + trust store + политика. Это делает офлайн‑проверку в изолированных сетях предсказуемой и хорошо автоматизируемой.

Практические рекомендации для вашей схемы
- Если уже идёте с Notation:
  - поднимите внутренний CA (или используйте существующий), выписывайте вендорам листовые сертификаты “под подпись артефактов” с коротким сроком жизни и правильными расширениями;
  - раздайте внутрь сети trust store (корни/промежуточные) и один общий trustpolicy.json с level=strict и ограничениями trustedIdentities (subject/issuer) и registryScopes;
  - автоматизируйте импорт: oras cp -r в карантинный репозиторий Nexus → notation verify по вашей политике → промоут в прод по результату; все шаги без ручного участия.
- Если нужен “без PKI” режим — это скорее про cosign с key-based, где вы распространяете/обновляете набор публичных ключей. В изолированной сети это работает, но масштабируется хуже, чем CA+policy у Notation.

Если хотите, помогу набросать минимальный trustpolicy.json и чек‑лист по выпуску сертификатов для ваших поставщиков (CSR, поля Subject/SAN, сроки, ротация, CRL/TSA в офлайне).
